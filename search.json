[{"title":"JavaScript 第三天","path":"//","content":"JavaScript 基础第一天 — for 循环 和 array 数组1. for循环基本使用: for循环也是重复执行代码 好处: 把声明起始值、循环条件、变化值写到一起，一目了然 如果明确循环次数的时候使用for循环 不明确循环次数的时候使用while循环 123for (声明变量; 循环条件; 变化值) &#123; // 循环体&#125; for 输出1到100偶数之间的和 123456let num1 = 0for (let num2 = 1; num2 &lt;= 100; num2++) &#123; if (num2 % 2 === 0) &#123; num1 += num2 &#125;&#125; for循环 最大优势是遍历数组 123456let num1 = [&#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]// num1.length和&lt;=3的区别// for (let num2 = 0; num2 &lt;= 3; num2++) &#123;for (let num2 = 0; num2 &lt; num1.length; num2++) &#123; document.write(num1[num2])&#125; 2. 循环退出: continue：结束本次循环，继续下次循环 break：直接结束本次循环 1234567for (let num1= 1; num1 &lt;= 6; num1++) &#123; if (num1 === 3) &#123; // continue 退出本次循环, 继续下次循环 // break 直接结束本次循环 &#125; document.write(num1)&#125; 3. for 循环嵌套:123456一个循环里再套一个循环，一般用在for循环里for (外部声明变量; 循环条件 变化值) &#123; for (内部声明变量; 循环条件; 变化值) &#123; // 循环体 &#125;&#125; 使用 for 嵌套 用户输入后打印几行几列星星 12345678let num1 = prompt(&#x27;请输入多少列个星&#x27;)let num2 = prompt(&#x27;请输入多少行个星&#x27;)for (let num3 = 1; num3 &lt;= num1; num3++) &#123; for (let num4 = 1; num4 &lt;= num2; num4++) &#123; document.write(&#x27;❤&#x27;) &#125; document.write(`&lt;br&gt;`)&#125; 打印倒三角形星星, 外循环控制行, 内循环控制列打印几个 内循环个数跟第几行是一一对应的 123456for (let num1 = 1; num1 &lt;= 5; num1++) &#123; for (let num2 = 1; num2 &lt;= num1; num2++) &#123; document.write(&#x27;💚&#x27;) &#125; document.write(`&lt;br&gt;`)&#125; 使用for 嵌套 打印九九乘法表 123456for (let num1 = 1; num1 &lt;= 9; num1++) &#123; for (let num2 = 1; num2 &lt;= num1; num2++) &#123; document.write(`$&#123;num2&#125; x $&#123;num1&#125; = $&#123;num1 * num2&#125;`) &#125; document.write(`&lt;br&gt;`)&#125; 4. 数组的基本使用: 数组(Array)是一种可以按顺序保存数据的数据类型 在数组中，数据的编号也叫索引或下标 数组是按顺序保存，每个数据都有自己的编号 数组可以存储任意类型的数据 如果有多个数据可用数组保存 计算机中的编号从0开始，第一个编号为0，第二个编号为1，以此类推 1let 数组名 = [数据1, 数据2, 数据3] 通过下标取数据 取出来什么类型，就根据这种类型特点来访问 12let num = [1, 2, 3]num[0] num[1] num[2] 元素：数组中保存的每个数据都叫数组元素 下标：数组中数据的编号 长度：数组中数据的个数，通过数组的length属性获得 123let num [&#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]console.log(num[0]) // pinkconsole.log(num.length) // 3 5. for 遍历数组: 用循环把数组中每个元素都访问到,一般会用for循环遍历 123for (let i = 0; i &lt; 数组名.length; i++) &#123; // 数组名[i]&#125; 1. 使用for循环 求数组的 和&#x2F;平均值 声明一个求和变量 num2 遍历这个数组，把里面每个数组元素加到 num2 里面 用求和变量 num2 除以数组的长度得到数组的平均值 123456789let num1 = [2, 6, 1, 7, 4]let num2 = 0let num3 = 0for (num4 = 0; num4 &lt; num1.length; num4++) &#123; document.write(num1[num4]) num2 += num1[num4]&#125;num3 = num2 / num1.lengthdocument.write(`和是$&#123;num2&#125;,平均值是$&#123;num3&#125;`) 2. 使用for循环 求数组最大值 声明一个保存最大元素的变量 num2 默认最大值可以取数组中的第一个元素 遍历这个数组，把每个数组元素和 num2 相比较 如果这个数组元素大于num2 就把这个数组元素存到 num2 里面，否则继续下一轮比较 最后输出这个 num2 12345678let num1 = [2, 6, 1, 77, 52, 25, 7]let num2 = num1[0]for (let num3 = 1; num3 &lt; num1.length; num3++) &#123; if (num2 &lt; num1[num3]) &#123; num2 = num1[num3] &#125;&#125;document.write(num2) 3. 使用for循环 求数组中大于等于5的和 4512345678let num1 = [4, 9, 5, 20, 3, 11]let num2 = 0for (let num3 = 0; num3 &lt; num1.length; num3++) &#123; if (num1[num3] &gt;= 5) &#123; num2 += num1[num3] &#125;&#125;document.write(num2) 4. 使用for循环 计算以下数组中能被3整除的偶数的和 241234567let num1 = [2, 6, 18, 15, 40]let num2 = 0for (let num3 = 0; num3 &lt; num1.length; num3++) &#123; if (num1[num3] % 3 === 0 &amp;&amp; num1[num3] % 2 === 0) &#123; num2 += num1[num3] &#125;&#125; 6. 操作数组: 数组本质是数据集合, 操作数据无非是增、删、改、查 查: 查询数组数据, 数组[下标], 称为访问数组数据 改: 重新赋值, 数组[下标] &#x3D; 新值 增: 数组添加新数据, arr.push(新增内容)、arr.unshift(新增内容) 删: 删除数组中数据, arr.pop()、arr.shift()、arr.splice(操作下标,删除个数) 1. 增：数组增加新的数据 数组.push()：将一个或多个元素添加到数组的末尾，并返回该数组的新长度 (重点💖) 123let num1 = [1, 2]// push 添加新数组到末尾num1.push(3) arr.unshift(新增的内容)：将一个或多个元素添加到数组的开头，并返回该数组的新长度 12345let num1 = [1, 2]// unshift 添加新数组到第一个num1.unshift(3)// 添加一个新数组并返回数组的长度console.log(num1.push(4)) １. 数组筛选, 将数组中大于等于10的元素选出来, 放入新数组 声明一个新数组用于存放新数据 num2 遍历原来的旧数组, 找出大于等于10的元素 依次追加给新数组num2 12345678let num1 = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]let num2 = []for (let num3 = 0; num3 &lt; num1.length; num3++) &#123; if (num1[num3] &gt;= 10) &#123; num2.push(num1[num3]) &#125;&#125;document.write(num2) 2. 数组去0, 将数组中0去掉, 形成不包含0的新数组 声明一个新数组用于存放新数据num2 遍历原来的旧数组, 找出不等于0的元素 依次追加给新数组num2 12345678let num1 = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]let num2 = []for (let num3 = 0; num3 &lt; num1.length; num3++) &#123; if (num1[num3] !== 0) &#123; num2.push(num1[num3]) &#125;&#125;document.write(num2) 2. 删: 数组删除元素 数组. pop(): 从数组中删除最后一个元素, 并返回该元素的值 数组. shift(): 从数组中删除第一个元素, 并返回该元素的值 数组. splice(): 删除指定元素 start: 起始位置, 指定修改的开始位置 (从0计数) deletecount: 删除数组的个数, 省略则默认从指定起始位置删除到最后 12345678910let num1 = [10, 20, 30]// 删除数组中最后一个元素num1.pop()// 删除数组中第一个元素num1.shift()// 从第三个元素删除到第六个元素// num1.splice(start起始位置, deletecount删除几个元素)num1.splice(3, 6)// 添加一个新数组并返回删除的元素console.log(num1.pop()) 3. 删除元素的使用场景: 开发很常用, 比如随机抽奖、删除指定商品… 随机抽奖, 中奖用户需要从数组里删除, 不允许重复抽奖 点击删除按钮, 相关数据会从商品数据中删除 后期会用到删除操作, 特别是splice 7. 冒泡排序: 冒泡排序是一种简单的排序算法 它重复的走访要排序的数列, 一次比较两个元素, 如果它们顺序错误就把它交换过来, 走访数列的工作是重复的进行直到没有再需要交换, 也就是说该数列已经排序完成 这个算法名字由来是因为越小元素会由交换慢慢 ‘浮’ 到数列的顶端 比如数组 [2,3,1,4,5] 经过排序成为了 [1,2,3,4,5] 或者 [5,4,3,2,1] 1234567891011121314151617let num1 = [5, 4, 3, 2, 1]// 1.一共需要的趟数, 5个数据我们要走4趟, 用外层for循环// 所以: 数组的长度减去1 length - 1for (let num2 = 0; num2 &lt; num1.length - 1; num2++) &#123; // 2.每一趟交换次数, 用内层循环 // 所以: 减去数组长度1 但我们从0开始, 就是 length - num2 - 1 for (let num3 = 0; num3 &lt; num1.length - num2 - 1; num3++) &#123; // 3.if 做判断 0 大于 1 执行交换变量 if (num1[num3] &gt; num1[num3 + 1]) &#123; // 4.交换变量 let temp = num1[num3] num1[num3] = num1[num3 + 1] num1[num3 + 1] = temp &#125; &#125;&#125;document.write(num1) 8. 根据输入数据生成柱形图 需要输入4次，所以把4个数据放到一个数组里 num1[] 利用循环，弹出4次输入框，同时存到数组里面 num1[] 遍历改数组，根据数据生成4个柱形图，渲染打印到页面中 柱形图就是div盒子, 设置宽度固定, 高度是用户输入的数据 div里面包含显示的数字和第N季度 123456789101112131415161718// 用循环弹出四次输入框, 会得到4个数据，放到num1数组里let num1 = []for (let num2 = 1; num2 &lt;= 4; num2++) &#123; num1.push(prompt(`请输入第$&#123;num2&#125;季度数据`))&#125;console.log(num1)// 注意渲染循环的是柱子document.write(`&lt;div class =&quot;box&quot;&gt;`)// 循环4个柱子 for (let num2 = 0; num2 &lt; num1.length; num2++) &#123; document.write(` &lt;div style=&quot;height: $&#123;num1[num2]&#125;px;&quot;&gt; &lt;span&gt;$&#123;num1[num2]&#125;&lt;/span&gt; &lt;h4&gt;第$&#123;num2 + 1&#125;季度&lt;/h4&gt; &lt;/div&gt; `) &#125;document.write(`&lt;/div&gt;`) 9. 本节单词: for array arr push unshift pop shift splice continue break start deletecount","tags":["JavaScript笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript 第二天","path":"//","content":"JavaScript 基础第二天算术运算符: 经常作为某个数字是否被整除 数学运算也叫算术运算, 主要包括加、减、乘、除、取余(取模) +：求和、-：求差、*：求积、&#x2F;：求商、%：取余 算术运算符优先级顺序: 同时使用多个运算符写程序时, 会按某种顺序先后执行, 称为优先级 js中, 优先级越高越先被执行, 优先级相同时左向右执 乘、除、取余优先级相同, 加、减优先级相同 乘、除、取余优先级大于加、减 使用()可以提升优先级 总结: 先乘除后加减，有括号先算括号里的 计算圆的面积: 1234let num1 = prompt(&#x27;请输入您的半径&#x27;)let num2 = 3.14 * num1 * num1alert(`计算之后圆的面积是: $&#123;3.14 * num1 * num1&#125;`)alert(`计算之后圆的面积是: $&#123;num2&#125;`) 赋值运算符: 对变量进行赋值的运算符, 使用这些可对变量赋值时快速操作 学过的赋值运算：&#x3D; 将等号右边值赋予给左边, 要求左边必须是一个容器 其他赋值运算符: +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D;, %&#x3D;, let num &#x3D; 10 ， num加5 赋值写就是: num +&#x3D; 5 二元运算符: 经常用于计数来使用, 比如进行10次操作，用它来计算进行多少次 众多js运算可根据所需表达式的个数，分为一元、二元、三元运算符 前置和后置自增单独使用没有区别 前置和后置自增参与运算就有区别 前置：先自增后运算 后置：先运算后自增 1let num = 10 + 20 以前让一个变量每次+1 ，我们怎么做的呢？ 12345let num = 1let = num + 1// 现在可以这样做let num = 1num += 1 自增运算符的用法: 一般开发中都是独立使用, 后面 i++ 后置自增会使用较多 123// 面试题 问: 输出结果是多少?let num = 10console.log(num++ + ++num + num) 比较运算符: 比较两个数据大小、是否相等, 尽量不比较小数，因为小数有精度问题 NaN不等于任何值，包括它本身 不同类型之间比较会发生隐式转换, 最终把数据隐式转成number类型再比较 字符串比较，比较的字符对应的ASCII码, 从左往右依次比较 比较运算符的使用: &gt; ： 左边是否大于右边 &lt;：左边是否小于右边 &gt;&#x3D;：左边是否大于等于右边 &lt;&#x3D;：左边是否小于等于右边 &#x3D;&#x3D;：左右两边是否相等 &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;：左右两边是否类型和值都相等 !&#x3D;&#x3D;：左右两边是否不全等 比较结果为布尔型，只会得到true或false 逻辑运算符: 逻辑运算符用来解决多重条件判断 符号 名称 读法 口诀 特点 &amp;&amp; 逻辑与 并且 一假则假 两边都为true 结果才为true || 逻辑或 或者 一真则真 两边有一个true 结果为true ! 逻辑非 取反 真变假, 假变真 true变false false变true 逻辑运算符里的短路: 只存在于**&amp;&amp;和||中**，当满足条件会让右边代码不执行 &amp;&amp;: 左边为false就短路、||: 左边为true就短路 原因：通过左边能得到整个式子结果，因此没必要再判断右边 运算结果: 无论&amp;&amp;还是|| ，结果都是最后被执行的表达式值，一般用在变量赋值 1234567// 五个短路: false 0 &#x27;&#x27; undefined nullconsole.log(false &amp;&amp; 10)console.log(6 &gt; 7 &amp;&amp; 10)console.log(undefined &amp;&amp; 10)console.log(null &amp;&amp; 10)console.log(0 &amp;&amp; 10)console.log(10 &amp;&amp; 20) 用户输入一个数, 判断一个数是4的倍数，且不是100的倍数: 123let num = prompt(&#x27;请输入一个数&#x27;)nm1 = num || 0console.log(num % 4 === 0 &amp;&amp; num % 100 !== 0) 运算符优先级: 一元运算符里的逻辑非优先级很高 逻辑与比逻辑或优先级高 123456789101112// a为false 此时发生了逻辑与中断let a = 3 &gt; 5 &amp;&amp; 2 &lt; 7 &amp;&amp; 3 == 4console.log(a)// b为true 此时发生了逻辑或中断let b = 3 &lt;= 4 || 3 &gt; 1 || 3 != 2console.log(b)// c为false 数据类型不匹配let c = 2 === &#x27;2&#x27;console.log(c)// d为true 此时发生了逻辑或中断let d = !c || b &amp;&amp; aconsole.log(d) 表达式和语句: 表达式是一组代码的集合，js解释器会计算出一个结果 某些情况, 也可把表达式理解为语句, 因为它在计算结果, 也是做事 表达式是计算出一个值，语句用来自行使某件事发生(做什么事) 表达式: 3 + 4 , 语句: alert() 弹出对话框 js语句是以分号结束 (可省略) , 如: if语句 for循环 分支语句: 程序三大流程控制语句: 顺序, 分支, 循环 以前写代码，写几句就从上往下执行几句，这种叫顺序结构 有时候根据条件选择执行代码，这种就叫分支结构 某段代码被重复执行, 叫循环结构 分支语句包含: if分支语句, 三元运算符, switch语句 1. if语句: if语句有三种使用：单分支、双分支、多分支 括号内的条件为true时，就进入大括号里执行代码 小括号内的结果若不是布尔类型时，会发生隐式转换转为布尔类型 1. 单分支if语法：1234// if括号里执行是布尔型, 可以是比较运算和字符串类型if (条件) &#123; alert(&#x27;满足条件执行的代码&#x27;)&#125; 2. 双分支if语法:12345678let num = +prompt(&#x27;请输入年份&#x27;)// 能被4整除但不能被100整除，或被400整除的年份是闰年，否则都是平年if (num % 4 === 0 &amp;&amp; num % 100 !== 0 || num % 400 === 0) &#123; alert(`$&#123;num&#125;年是闰年`)&#125; else &#123;// 不被4整除则执行是平年 alert(`$&#123;num&#125;年是平年`)&#125; 3. 多分支if语法: 先判断条件1, 若满足条件1就执行代码1, 其他不执行 若不满足则向下判断条件2, 满足条件2则执行代码2, 其他不执行 若依然不满足则继续往下判断, 依次类推 若以上条件都不满足, 则执行else里的代码, 可写N个条件 1234567891011// 根据输入不同时间，输出不同问候语let num2 = +prompt(&#x27;请输入当前时间: &#x27;)if (num2 &lt; 12) &#123; alert(&#x27;上午好, 好好工作&#x27;)&#125; else if (num2 &lt; 17) &#123; alert(&#x27;下午好, 好好工作&#x27;)&#125; else if (num2 &lt; 19) &#123; alert(&#x27;晚上好, 好好加班&#x27;)&#125; else &#123; alert(&#x27;夜深了~ 头发还有吗?&#x27;)&#125; 2. 三元运算符: 符号：**? 与 :** 配合使用, 用来取值 其实是比if双分支更简单的写法, 也叫做三元表达 语法：条件 ? 满足条件执行代码 : 不满足条件执行代码 1. 判断2个数的最大值:1234let num1 = +prompt(&#x27;请输入第一个数&#x27;)let num2 = +prompt(&#x27;请输入第二个数&#x27;)let num3 = num1 &gt; num2 ? num1 : num2console.log(num3) 2. 数字小于10补0: 用户输入1个数，如果数字小于10，则前面进行补0, 如: 01 02 1234let num1 = prompt(&#x27;请输入一个数&#x27;)let num2 = num1 &gt;= 10 ? num1 : &#x27;0&#x27; + num1// let num2 = num1 &lt; 10 ? &#x27;0&#x27; + num1 : num1console.log(num2) 3. Switch 语句: switch case语句用于等值判断, 不适合用于区间判断 switch case需要配合break关键字使用, 没有break会造成case穿透 找到跟小括号里数据全等的case值，并执行里面对应的代码 若没有全等 &#x3D;&#x3D;&#x3D; 的则执行default里的代码 break: 结束switch语句，防止穿透 123456789101112switch (1) &#123; case 1: alert(&#x27;我是1&#x27;) break case 2: alert(&#x27;我是2&#x27;) break case 3: alert(&#x27;我是3&#x27;) default: alert(&#x27;没有数据&#x27;)&#125; 简单计算器: 用户输入2个数字, 然后输入+ - * &#x2F;，可执行不同运算结果 12345678910111213141516171819let num1 = +prompt(&#x27;请输入第一个数&#x27;)let num2 = +prompt(&#x27;请输入第二个数&#x27;)let num3 = prompt(&#x27;请输入想要的运算: + - * /&#x27;)switch (num3) &#123; case &#x27;+&#x27;: alert(`你输入了+运算, 两个数结果为$&#123;num1 + num2&#125;`) break case &#x27;-&#x27;: alert(`你输入了-运算, 两个数结果为$&#123;num1 - num2&#125;`) break case &#x27;*&#x27;: alert(`你输入了*运算, 两个数结果为$&#123;num1 * num2&#125;`) break case &#x27;/&#x27;: alert(`你输入了/运算, 两个数结果为$&#123;num1 / num2&#125;`) break default: alert(&#x27;你输入了啥? 请在 + - * / 中选择&#x27;)&#125; 4. 循环结构: 学习时可帮助更好理解代码运行, 工作时可更快找到bug 断点: 在某句代码上加标记叫断点, 程序执行到这句有标记的代码时会暂停下来 While 循环: 循环: 重复执行某段代码 跟if语句很像，都要满足小括号里的条件为true才会执行代码 while大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若满足又执行大括号里的代码，然后再回到小括号判断条件, 直到括号内条件不满足,即跳出 循环的本质就是以某个变量为起始值, 然后不断产生变化量, 慢慢靠近终止条件的过程 循环需要具备三要素： 变量起始值 终止条件 (没有终止条件, 循环会一直执行, 造成死循环 变量变化量 (自增或自减) 123456789// 1.变量的起始值let num = 1// 2.终止条件 循环条件while (num &lt;= 5) &#123;// 4.重复执行的代码(循环体) document.write(&#x27;你好&#x27;)// 3.变量变化 num++&#125; 页面输出1-10: 12345let num = 1while (num &lt;= 10) &#123; document.write(num) num++&#125; 计算从1加到100总和并输出 12345678// 声明累加和的变量num2, 每次把num1加到num2里let num1 = 1let num2 = 0while (num1 &lt;= 10) &#123; num2 += num1 num1++&#125;document.write(num2) 计算1-100之间所有偶数的和 12345678910// 首先利用if语句把num1里是偶数筛选出来, 把筛选的num1加到num2里let num1 = 1let num2 = 0while (num1 &lt;=10) &#123; if (num1 % 2 === 0) &#123; num2 += num1 &#125; num1++&#125;document.write(num2) 弹出对话框，‘你喜欢我吗’，如果输‘喜欢’, 则结束, 否则一直弹出对话框: 1234567while (true) &#123; let num = prompt(&#x27;我喜欢你, 你喜欢我吗?&#x27;) if (num === &#x27;喜欢&#x27;) &#123; alert(&#x27;我也喜欢你&#x27;) break &#125;&#125; 用户登录验证, 输入用户名和密码 123456789101112131415161718// 若用户名为admin, 且密码为123456, 则提示登录成功, 否则让用户一直输入let username = prompt(&#x27;请输入用户名&#x27;)let password = prompt(&#x27;请输入密码&#x27;)while (true) &#123;if (username == &#x27;admin&#x27; &amp;&amp; password == 123456) &#123; alert(&#x27;登录成功&#x27;) break &#125; else &#123; alert(&#x27;用户名或密码错误, 请重新输入&#x27;) let username = prompt(&#x27;请输入用户名&#x27;) let password = prompt(&#x27;请输入密码&#x27;) if (username == &#x27;admin&#x27; &amp;&amp; password == 123456) &#123; alert(&#x27;登录成功&#x27;) break &#125; &#125;&#125; 求1-100之间个位数不为3的数累加和 123456789let num1 = 1let num2 = 0while (num1 &lt;= 100) &#123; if (num1 % 10 !== 3) &#123; num2 += num1 &#125; num1++&#125;console.log(num2) 5. 循环退出: continue和break的区别 continue：结束本次循环, 继续下次循环 break：跳出所在的循环 123456789101112let num1 = 1while (num1 &lt;= 6) &#123; if (num1 === 2) &#123; num1++ // 结束本次循环, 继续下次循环 continue // 退出循环 // break &#125; document.write(`我吃了$&#123;num1&#125;个苹果&lt;br&gt;`) num1++&#125; ATM取款机案例: 输入不同的值, 用Switch来执行不同的操作 用户可存钱、取钱、查看余额和退出 循环的时候, 需反复提示输入框, 所以提示框写到循环里 退出条件是用户输入 4, 如果是4, 则结束循环, 不再弹窗 提前准备100金额预先存储一个数额 取钱存钱则用加减法, 查看余额则直接显示金额 123456789101112131415161718192021222324252627282930// 3. 金额的变量, 先存储100let money = 100// 1. 不断弹出对话框while (true) &#123; let operate = prompt(` 请输入您的操作: 1. 取钱 2. 存钱 3. 查看余额 4. 退出 `)// 2. 输入4退出对话框 不输入则死循环弹出对话框if (operate === &#x27;4&#x27;) &#123; break&#125; // 4. 用switch实现取钱存钱操作switch (operate) &#123; case &#x27;1&#x27;: let take = +prompt(&#x27;请输入取钱金额:&#x27;) money -= take break case &#x27;2&#x27;: let deposit = +prompt(&#x27;请输入存钱金额:&#x27;) money += deposit break case &#x27;3&#x27;: let see = alert(`您的金额还有$&#123;money&#125;`) break&#125;&#125; 本节单词: if else switch case while continue break default","tags":["JavaScript笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript 第一天","path":"//","content":"JavaScript 基础第一天 JavaScript是一种运行在浏览器的编程语言，可实现人机交互效果 网页特效 (监听用户行为让网页作出对应反馈) 表单验证 (针对表单数据的合法性进行判断) 数据交互 (获取后台数据, 渲染到前端) 服务端编程 (node.js) JavaScript的组成: ECMAScript (基础语法 )、Web APIs (DOM、BOM) ECMAScript: 规定了js基础语法核心知识 比如：变量、分支语句、循环语句、对象等等 DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作 BOM 操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等 权威网站：MDN JavaScript 书写位置:内部 JS: 直接写在html文件里，用script标签包住 将script放在HTML文件底部的原因是浏览器会按照代码在文件中的顺序加载HTML 如果先加载的JS修改下方的HTML，那么它可能由于HTML尚未被加载而失效 因此，将JSt代码放在HTML的底部通常是最好的策略 12345&lt;body&gt; &lt;script&gt; document.write(&#x27;Hello World&#x27;) &lt;/script&gt;&lt;/body&gt; 外部 JS: 代码写在以.js结尾的文件里, 通过script标签引入到html中 script标签中间无需写代码，否则会被忽略 外部JS会使代码更加有序，更易于复用，没了脚本的混合，HTML会更加易读 1&lt;script src=&quot;JS.js&quot;&gt;&lt;/script&gt; 内联 JS: 代码写在标签内部, 了解即可，后面vue框架会用这种模式 1&lt;button onclick=&quot;alert(&#x27;你好&#x27;)&quot;&gt;请点击我&lt;/button&gt; JavaScript 注释:单行注释:1// 单行注释 ctrl + / 块注释:1/* 块注释 Shift+Alt+A */ JavaScript 结束符: 代表语句结束、英文分号 ; 、可写可不写 换行符会识别成结束符, 所以一个完整语句，不要手动换行 为了风格统一，要么都写，要么都不写 JavaScript 输入 输出语法: 人和计算机打交道的规则约定，程序员操控计算机，需要计算机能看懂 输出和输入可理解为人和计算机交互，用户通过键盘、鼠标向计算机输入信息，计算机处理后再展示结果给用户 ，这便是一次输入和输出的过程 输入语法： 显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字 1prompt(&#x27;我是输入语法&#x27;) 输出语法： 向body内输出内容, 输出内容写的是html标签，会被解析成网页元素 1document.write(&#x27;&lt;h2&gt;我是输出&lt;/h2&gt;&#x27;) 页面弹出警告对话框:1alert(&#x27;我是警告对话框&#x27;) 控制台输出语法，开发调试使用:1console.log(&#x27;我是控制台输出&#x27;) 字面量: 在计算机科学中，字面量 (literal) 是在计算机中描述事&#x2F;物 我们工资是：100 此时100就是 数字字面量 ‘你好啊’ 字符串字面量 还有 [] 数组字面量 {} 对象字面量 等等… 变量是什么？ 计算机中用来存储数据的“容器”，简单理解就是一个个的盒子，可以让计算机变得有记忆 用来存放数据，变量指的是容器而不是数据 变量的基本使用: 变量通过 let 来声明 通过 &#x3D; 赋值 变量通过变量名来获得里面的数据&#96;&#96;, 可同时声明多个变量 声明变量： 使用变量，首先创建变量 (声明变量) 声明变量有两部分构成：声明关键字、变量名 (标识） let 即关键字 (let: 允许、许可、让、要)，关键字是系统提供专门用来声明变量的词语 变量赋值： 注意：是通过变量名来获得变量里面的数据 定义一个变量后，就能初始化它 (赋值) 在变量名之后跟上一个“&#x3D;”，然后是数值 也可以声明变量的时候同时给变量初始化 1let Number = 10 // Number变量名称，也叫标识符 更新变量： 变量赋值后，可以通过一个不同的值来更新它 let 不允许多次声明一个变量 123let Number = 10Number = 20alert(Number) // 输出结果为20 声明多个变量：1let Number = 10, uname = &#x27;你好&#x27; 交换变量的值: 使用一个临时变量做中间存储 声明一个临时变量 temp 把num1的值赋值给 temp 把num2的值赋值给num1 把temp的值给num2 1234567891011let unm1 = &#x27;周杰伦&#x27;let unm2 = &#x27;林俊杰&#x27;// 使用一个 临时变量 用来做中间存储let temp// 把num1的值赋值给 temptemp = unm1// 把num2的值赋值给num1unm1 = unm2// 把temp的值给num2unm2 = tempdocument.write(unm1, unm2) 变量的本质: 内存：计算机中存储数据的地方，相当于一个空间 变量：是程序在内存中申请的一块用来存放数据的小空间 变量命名规则与规范: 不能有特殊含义字符，如JS内置的一些英语词汇：let、var、if、for 等.. 只能用下划线、字母、数字、$组成，数字不能开头 字母区分大小写，如 Age 和 age 是不同的变量 起名要有意义, 遵守小驼峰命名法, 例：userName let 和 var ： let 为了解决 var 的一些问题 以后声明变量统一使用 let var 声明: 可以先使用 在声明 (不合理) var 声明过的变量可重复声明 (不合理) 比如变量提升、全局变量、没有块级作用域等等.. JS数组: 数组(Array)是一种可以按顺序保存多个数据 数组是按顺序保存，每个数据都有自己的编号 计算机中的编号从0开始，所以星期一编号为0，星期二编号为1，以此类推 在数组中，数据的编号也叫索引或下标 数组可以存储任意类型的数据 取出来是什么类型的，就根据这种类型特点来访问 123let arr = [&#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;]console.log(arr[0]);console.log(arr[2]); 元素：数组中保存的每个数据都叫数组元素 下标：数组中数据的编号 长度：数组中数据的个数，通过数组的length属性获得 数据类型: 更加充分和高效的利用内存 也更加方便开发人员的使用数据 JS 数据类型整体分为 两大类：基本数据类型 : number 数字型 string 字符串型 boolean 布尔型 undefined 未定义型 null 空类型 引用数据类型: object 对象function 函数 array 数组 function 函数 array 数组 数字类型 number : 即数学中的数字，可以是整数、小数、正数、负数 JS中的正数、负数、小数等 统一称为 数字类型 JS是弱数据类型，变量到底属于哪种类型，只有赋值之后，才能确认 Java是强数据类型 例如 int a &#x3D; 3 必须是整数 1let uname = 20 字符串类型 string : 通过单引号 (‘ ‘) 、双引号 (“ “) 或反引号(&#96;&#96;)包裹的数据都叫字符串 无论单引或双引必须成对使用 单引&#x2F;双引可互相嵌套，但不以自已嵌套自已 (外双内单，外单内双) 必要时可使用转义符 \\，输出单引或双引 1let uname = &#x27;我是字符串类型&#x27; 12345// 3. 字符串拼接console.log(&#x27;我叫周杰伦&#x27; + &#x27;我叫林俊杰&#x27;)let uname1 = &#x27;周杰伦&#x27;let uname2 = &#x27;林俊杰&#x27;console.log(uname1 + uname2) 模板字符串: 内容拼接变量时，用 ${} 包住变量, 使得拼接字符串更简便 拼接字符串和变量, 在没有它之前，要拼接变量比较麻烦 1document.write(`大家好, 我叫$&#123;name&#125;, 今年$&#123;name1&#125;岁了`) 布尔类型 boolean : 表示肯定或否定时在计算机中对应的是布尔类型数据 它有两个固定的值 true 和 false，表示肯定的数据用 true (真) ，表示否定的数据用 false (假) 12let name = truelet name = false 未定义类型 undefined : 未定义是比较特殊的类型，只有一个值 undefined 只声明变量，不赋值的情况下，变量默认值为undefined 开发中经常声明一个变量，等待传送过来的数据。 如果不知道这个数据是否传递过来，此时可通过检测这个变量是不是undefined，即可判断用户是否 有数据传递过来 null 空类型 : null 表示 值为空 官方解释：把null作为尚未创建的对象 将来有个变量里面存放的是个对象，但是对象还没创建好，可以先给个null null 和 undefined 区别： undefined 表示没有赋值 null 表示赋值了，但内容为空 控制台 输出语句 和 检测数据类型 : 控制台语句经常用于测试结果来使用 数字型和布尔型颜色为蓝色，字符串和undefined颜色为灰色 1234567891011// 通过 typeof 关键字检测数据类型let unm1 = 10let unm2 = &#x27;10&#x27;let unm3 = truelet unm4 = undefinedlet unm5 = nullconsole.log(typeof unm1)console.log(typeof unm2)console.log(typeof unm3)console.log(typeof unm4)console.log(typeof unm5) 类型转换:为什么需要类型转换? JS是弱数据类型： JS也不知道变量到底属于哪种数据类型，只有赋值了才清楚 坑：使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单进行加法运算 此时需要转换变量的数据类型, 就是把一种数据类型的变量转换成需要的数据类型 1console.log(&#x27;100 + 100&#x27;) // 输出结果100100 隐式转换: 某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为 隐式转换 + 号两边只要有一个是字符串，都会把另外一个转成字符串 除了+以外的算术运算符 比如 - * &#x2F; 等都会把数据转成数字类型 缺点: 转换类型不明确，靠经验才能总结 技巧: +号作为正号解析可以转换成Number 12345let uname = &#x27;10&#x27;console.log(+uname);console.log(+&#x27;10&#x27; + 10)console.log(10 / 10)console.log(10 * 10) 显式转换: 编写程序时过度依靠系统内部的隐式转换是不严谨的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为避免因隐式转换带来的问题，通常跟逻辑需要对数据进行显示转换 转换为数字型:Number 数据 : 转成数字类型 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number) 即不是一个数字 NaN也是Number类型的数据，代表非数字 12let uname = &#x27;10&#x27;console.log(Number(uname)) parseInt ( 数据 ) 只保留整数:12let uname = &#x27;10.99&#x27;console.log(parseInt(uname)) parseFloat ( 数据 ) 可以保留小数:12let uname = &#x27;9.9&#x27;console.log(parseFloat(uname)) 转换为字符型:String( 数据 ):12let uname = 10console.log(String(uname)) 变量.toString( 进制 ) :12let uname = 20console.log(uname.toString(2)) 用户订单信息打印: 点击查看JS简单实现加法器: 点击查看1234567&lt;script&gt; // JS简单实现加法器 let number1 = +prompt(&#x27;请输入第一个数&#x27;) let number2 = +prompt(&#x27;请输入第二个数&#x27;) alert(`计算结果为: $&#123;number1 + number2&#125;`) document.write(`计算结果为: $&#123;number1 + number2&#125;`)&lt;/script&gt; 本节单词: prompt document write alert console log let var number string boolean undefined null typeof true false nan parseInt parsefloat string tostring","tags":["JavaScript笔记"],"categories":["JavaScript笔记"]},{"title":"移动开发-响应式","path":"//","content":"移动开发-响应式布局响应式开发原理: 使用媒体查询针对不同宽度的设备进行布局和样式设置，从而适配不同设备 设备划分 尺寸区间 超小屏幕 (手机) &lt; 768px 小屏设备 (平板) &gt;&#x3D; 768px ~ &lt; 992px 中等屏幕 (桌面显示器) &gt;&#x3D; 992px ~ &lt;1200px 宽屏设备 (大桌面显示器) &gt;&#x3D; 1200px 响应式布局容器: 响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果 原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化 也可以根据实际情况自己定义划分 Bootstrap 简介: Bootstrap 来自Twitter，是目前最受欢迎的前端框架，Bootstrap是基于 HTML、CSS 和Javascript ，它简洁灵活，使得Web开发更快捷 中文官网：http://www.bootcss.com/ 官网：http://getbootstrap.com/ 推荐使用：http://bootstrap.css88.com/ 框架：顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发 Bootstrap优点: 标准化的html+css编码规范 提供了一套简洁、直观、强悍的组件 有自己的生态圈，不断的更新迭代 让开发更简单，提高开发的效率 2.3.2：停止维护,兼容性好,代码不够简洁，功能不够完善 3.4.1：稳定, 但放弃了IE6-IE7，对IE8支持但是界面效果不好,偏向用于开发响应式布局、移动设备优先的Web项目 4.6.1 ：最新版，目前还不是很流行 以上来自2020年的数据 Bootstrap 使用: 控制权在框架本身，使用者要按照框架所规定的某种规范进行开发 123456789&lt;!--要求当前网页使用IE浏览器最高版本的内核来渲染--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!--视口设置：视口宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;!--解决ie9以下浏览器对html5新增标签的不识别，并导致CSS不起作用的问题--&gt; &lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;!--解决ie9以下浏览器对 css3 Media Query 的不识别 --&gt; &lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; 布局容器: Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器，它提供了两个作此用处的类 container 类: 响应式布局的容器 固定宽度 大屏 ( &gt;&#x3D;1200px) 宽度定为 1170px 中屏 ( &gt;&#x3D;992px) 宽度定为 970px 小屏 ( &gt;&#x3D;768px) 宽度定为 750px 超小屏 (100%) container-fluid 类: 流式布局容器 百分百宽度 占据全部视口 (viewport) 的容器 栅格系统介绍: 栅格系统英文为 Grid systems ,翻译为网格系统，是指将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局 Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口 (viewport) 尺寸的增加，系统会自动分为最多12列 栅格选项参数: 超小屏幕 (手机) &lt; 768px 小屏设备 (平板) &gt;&#x3D;768px 中等屏幕 (桌面显示器) &gt;&#x3D;992px 宽屏设备 (大桌面显示器) &gt;&#x3D;1200px .container 最大宽度 自动(100%) 750px 970px 1170px 类前缀 .col-xs- .col-sm- .col-md- .col-lg 栅格系统用于通过一系列行与列的组合来创建页面布局，内容就可以放入这些创建好的布局中 行 (row) 可以去除父容器的15px边距 xs-extra small：超小； sm-small：小； md-medium：中等； lg-large：大； 列 (column) 大于12，多余的列所在的元素将被整体另起一行排列 每一列默认有左右15像素的 padding 可同时为一列指定多个设备的类名，以便划分不同份数 例如 class&#x3D; col-md-4 col-sm-6 列嵌套: 内置的栅格系统将内容再次嵌套，就是一个列内再分若干份小列，可以通过添加一个新的.row元素和一系列 .col-sm 元素到已经存在的 .col-sm 元素内 123456&lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6&quot;&gt;列嵌套&lt;/div&gt; &lt;div class=&quot;col-sm-6&quot;&gt;列嵌套&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列偏移: 使用 .col-md-offset 类可以将列向右侧偏移，这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距 (margin) 1234 &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-4&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-lg-4 col-lg-offset-4&quot;&gt;2&lt;/div&gt;&lt;/div&gt; 列排序: 通过使用 .col-md-push 和 .col-md-pull 类就可以改变列 (column) 的顺序 1234&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-4 col-lg-push-8&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;col-lg-8 col-lg-pull-4&quot;&gt;右侧&lt;/div&gt;&lt;/div&gt; 响应式工具: 类名 超小屏 小屏 中屏 大屏 .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容 Bootstrap 其他 (按钮、表单、表格) 可参考 Bootstrap 文档 本节单词： Bootstrap container container-fluid viewport grid systems col lg md sm xs offset push pull visible","tags":["移动开发"],"categories":["移动开发"]},{"title":"移动开发-媒体查询","path":"//","content":"移动开发-rem适配布局-媒体查询rem单位: rem (root em) 是一个相对单位，类似于em，em是父元素字体大小 不同的是rem的基准是相对于html元素的字体大小 比如, 根元素html设置font-size&#x3D;12px; 非根元素设置width:2rem; 换成px表示就是24px 父元素文字大小可能不一致，但整个页面只有一个html，可以很好来控制整个页面元素大小 什么是媒体查询: 媒体查询 (Media Query) 是CSS3新语法 使用@media查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果、Android手机、平板等设备都用得到多媒体查询 语法规范:1️⃣media type 查询类型: 将不同的终端设备划分成不同的类型，称为媒体类型 值 说明 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等 2️⃣关键词: 关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件 and 可以将多个媒体特性连接到一起，相当于 且 的意思 not 排除某个媒体类型，相当于 非 的意思，可省略 only 指定某个特定的媒体类型，可省略 3️⃣媒体特性:每种媒体类型都有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格，暂且了解三个，注意他们要加小括号包含 值 说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域宽度 max-width 定义输出设备中页面最大可见区域宽度 4️⃣媒体查询+rem实现元素动态大小变化: rem单位是跟着html来走的，有了rem页面元素可以设置不同大小尺寸 媒体查询可以根据不同设备宽度来修改样式 媒体查询+rem 就可以实现不同设备宽度，实现页面元素大小的动态变化 1️⃣引入资源 (理解) : 当样式繁多的时候，可以针对不同的媒体使用不同的css 原理，就是直接在link中判断设备的尺寸，然后引用不同的css文件 1&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt; 2️⃣维护CSS的弊端: CSS是非程序式语言，没有变量、函数、SCOPE（作用域）等概念 CSS需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的 不方便维护及扩展，不利于复用 CSS没有很好的计算能力 非前端开发工程师来讲，往往会因缺少CSS编写经验而很难写出组织良好且易于维护的CSS代码 Less 介绍: Less (Leaner Style Sheets) 是一门CSS扩展语言，也是CSS预处理器 做为CSS一种形式的扩展，它并没有减少CSS功能，而是在现有的CSS语法上，为CSS加入程序式语言的特性 它在CSS的语法基础之上，引入了变量，Mixin(混入)，运算以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本，Less可以让我们用更少的代码做更多的事 Less中文网址： http://lesscss.cn/ 常见的CSS预处理器：Sass、Less、Stylus 一句话：Less是一门CSS预处理语言，它扩展了CSS的动态特性 Less 安装 (如果使用Vscode无需安装node) : 安装nodejs，可选择8.0版本，网址：http://nodejs.cn/download/ 检查是否安装成功，使用cmd命令输入 node –v 查看版本 基于nodejs在线安装Less，使用cmd命令 npm install -g less 检查是否安装成功，使用cmd命令 lessc -v 查看版本 Less 使用:Less变量、Less编译、Less嵌套、Less运算 Less 编译: 本质上，Less包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则 最终会通过解析器，编译生成对应的CSS文件 所以，只需要把我们的less文件 编译生成为css文件 就可以了 Vscode Less 插件🔴: Easy LESS 1️⃣Less 变量:变量是指没有固定的值，可以改变的，因为CSS中的颜色和数值等 经常使用 1@变量名:值; 2️⃣变量命名规范: 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 1@color: pink; 3️⃣Less 嵌套: 如果要用 (交集、伪类、伪元素选择器) 内层选择器的前面没有 &amp; 符号，则会被解析为父选择器的后代 如果有 &amp; 符号，它就被解析为父元素自身或父元素的伪类 Less 嵌套写法: 12345.box &#123; &amp;.content &#123; width: 10px; &#125; &#125; 4️⃣Less 运算: 任何数字、颜色、变量 都可运算, Less提供了 + 、-、乘(*)、除(&#x2F;) 算术运算 乘除法中间左右空格隔开 1px + 5 对于两个不同单位的值的运算，运算结果取第一个值的单位 如果两个值之间只有一个值有单位，运算结果就取该单位 1234@width: 5px + 5;border: @witdh solid pink; /*生成: 10px solid pink;*/width: (@width + 5) * 2; /* 生成的值是15 */@import &#x27;style&#x27;; /* 在less文件中导入less文件 1️⃣ rem 适配方案: 让一些不能等比自适应的元素，达到当设备尺寸发生改变时，等比例适配当前设备 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化 元素尺寸也会发生变化，从而达到等比缩放的适配 rem 实际开发适配方案: 按设计稿与设备宽度的比例，动态计算并设置html根标签的font-size大小 CSS中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为rem为单位的值 2️⃣ Less + 媒体查询 + rem 方案 : 设置html标签font-size大小 把整个屏幕划分为15等份 (划分标准不一 ,可以是20份也可以是10等份) 每一份作为html字体大小 那么假设是320px设备的时候，字体大小为320&#x2F;15 就是 21.33px 用页面元素的大小 除以不同的html字体大小会发现它们比例还是相同的 50*50像素的页面元素，在320屏幕下，就是 50 &#x2F; 21.33 转换为rem 就是2.34rem 320屏幕下，html字体大小为21.33，则 2rem &#x3D; 42.66px 此时宽和高都是42.66 尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px 元素大小取值方法: 公式：页面元素的rem值 &#x3D; 页面元素值 (px) &#x2F; (屏幕宽度 &#x2F; 划分的份数) 屏幕宽度 &#x2F; 划分的份数 就是 html font-size 的大小 或者：页面元素的rem值 &#x3D; 页面元素值 (px) &#x2F; html font-size 字体大小 3️⃣ Flexible.js + rem 方案 : 不需要再写不同屏幕的媒体查询，因为里面js做了处理 它的原理是把当前设备划分为10等份，在不同设备下，比例还是一致的 我们要做的，就是确定好当前设备的html文字大小就可以 比如当前设计稿是750px，那只需把html文字大小设置为 75px(750px &#x2F; 10) 里面页面元素rem值：页面元素的px 值 &#x2F; 75 剩余的，让flexible.js来去算 Github地址：https://github.com/amfe/lib-flexible 4️⃣ VSCode px转换rem插件: CSSrem 用不同的字体大小时记得在设置里 设置字体大小 本节单词： media all print screen min max easy less flexible.js","tags":["移动开发"],"categories":["移动开发"]},{"title":"移动开发-Flex布局","path":"//","content":"移动开发-flex弹性布局 Flex布局案例: 移动端携程网: 点击查看 PC端浏览器支持较差，如果是PC端页面布局，还是传统布局 如果是移动端或不考虑兼容性问题的PC端页面布局，使用flex弹性布局 flex弹性布局是Flexible Box的缩写，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局 当我们父盒子设为flex布局以后，子元素的float、clear 和 vertical-align属性将失效 伸缩布局 &#x3D; 弹性布局 &#x3D; 伸缩盒布局 &#x3D; 弹性盒布局 &#x3D; flex布局 采用Flex布局的元素，称为Flex容器(flex container)，简称容器，它的所有子元素自动成为容器成员，称为Flex项目(flex item)，简称项目 常见父项属性: flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-items：设置侧轴上的子元素排列方式 (单行) align-content：设置侧轴上的子元素的排列方式 (多行) flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap 更多flex属性: W3C Flexbox flex-direction 设置主轴的方向: 主轴与侧轴: 在flex布局中，分为主轴和侧轴两个方向，同样叫法有: 行和列、x轴和y轴 默认主轴方向是x轴方向，水平向右 默认侧轴方向是y轴方向，水平向下 flex-direction 属性决定主轴的方向 (即项目的排列方向) 注意: 主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴，而我们的子元素是跟着主轴来排列的 属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content 设置主轴上的子元素排列方式: justify-content 属性定义了项目在主轴上的对齐方式 注意: 使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值 从头部开始 如果主轴是x轴，则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐 (如果主轴是x轴则水平居中) space-around 平分剩余空间 space-between 先两边贴边 再平分剩余空间 (重要) flex-设置子元素是否换行:默认情况下，项目都排在一条 (又称轴线)上，flex布局中默认不换行的 属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items 设置侧轴上的子元素排列方式（单行）:控制子项在侧轴 (默认是y轴) 上的排列方式，在子项为单项 (单行) 的时候使用 属性值 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中 (垂直居中) stretch 拉伸 (默认值) align-content 设置侧轴上的子元素的排列方式（多行）:设置子项在侧轴上的排列方式，并且只能用于子项出现换行的情况 (多行)，在单行下是没有效果的 属性值 说明 flex-start 默认值 在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 align-content 和 align-items 的区别: align-items 适用于单行情况下，只有上对齐、下对齐、居中和拉伸 align-content 适应于换行(多行)的情况下(单行情况下无效)，可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值 总结就是单行找 align-items 多行找 align-content flex-flow:flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性 1flex-flow: row wrap; flex布局子项常见属性:1️⃣ flex 属性:flex 属性定义子项目分配剩余空间，用flex来表示占多少份数 123.box &#123; flex: 1; /* 默认值0 */&#125; 2️⃣ align-self 控制子项自己在侧轴上的排列方式:align-self 属性允许单个项目与其他项目不一样的对齐方式，可覆盖 align-items 属性 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 123.box:nth-child(2) &#123; align-self: flex-end; /* 设置子项侧轴上的排列方式 */ &#125; 3️⃣ order 属性定义项目的排列顺序:数值越小，排列越靠前，默认为0，注意：和 z-index 不一样 123.box &#123; order: 1; /* 默认为0 */ &#125; 背景线性渐变:背景渐变必须添加浏览器私有前缀 起始方向可以是：方位名词或者度数，如果省略 默认就是top 123background: linear-gradient(起始方向, 颜色1, 颜色2, ...);background: -webkit-linear-gradient(left, red, blue);background: -webkit-linear-gradient(left top, red, blue); 本节单词： flex direction row row-reverse column column-reverse justify-content flex-start flex-end space-around space-between stretch wrap nowrap align-items align-content flex-flow align-self order linear-gradient","tags":["移动开发"],"categories":["移动开发"]},{"title":"移动开发-流式布局","path":"//","content":"移动开发-百分比布局 流失布局案例: 京东商城: 点击查看 通过盒子宽度设置百分比来根据屏幕宽度来进行伸缩，不受固定像素限制，内容向两侧填充 流式布局，就是百分比布局，也称非固定像素布局 max-width 最大宽度 – max-height 最大高度 min-width 最小宽度 – min-height 最小高度 CSS初始化 normalize.css: 移动端CSS初始化推荐使用normalize.css Normalize.css：保护了有价值的默认值、修复了浏览器的bug、是模块化的 、拥有详细的文档 Normalize.css官网地址： http://necolas.github.io/normalize.css/ meta视口标签:标准的 viewport 设置: 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 属性 解释说明 width 宽度设置的是viewport宽度，可以设置device-width特殊值 initial-scale 初始缩放比，大于0的数字 maximum-scale 最大缩放比，大于0的数字 minimum-scale 最小缩放比，大于0的数字 user-scalable 用户是否可以缩放，yes或no (1或0) 布局视口 layout viewport:视口是浏览器显示页面内容的屏幕区域, 视口可以分为布局视口、视觉视口和理想视口 视觉视口 visual viewport:它是用户正在看到的网站的区域，可通过缩放去操作视觉视口 理想视口 ideal viewport: 理想视口，对设备来讲，是最理想的视口尺寸，需要手动添写meta视口标签通知浏览器操作 meta视口标签目的：布局视口的宽度应该与理想视口的宽度一致，就是设备有多宽，布局视口就多宽 二倍图:一个px能显示的物理像素点的个数，称为物理像素比或屏幕像素比，1CSS像素&#x3D;1物理像素 多倍图: 在标准viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题 通常使用二倍图， 因为iPhone6\\7\\8影响，还存在3倍4倍图的情况，这个看实际开发需求 1background-size: 50px 50px; /*原始图片100*100px*/ 关于更多: background-size 属性 多倍图切图 cutterman: 移动端主流方案: 单独制作移动端页面 (主流)，通过判断设备，如果是移动设备打开，则跳到移动端页面 响应式兼容移动端 (其次)，通过判断屏幕宽度来改变样式，以适应不同终端, 制作麻烦，需要花很大精力去调兼容性问题 移动端浏览器: 移动端浏览器基本以**webkit 内核**为主，因此我们就考虑webkit兼容性问题 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 特殊样式:123456789/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除 设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a &#123; -webkit-touch-callout: none; &#125; 本节单词： max min viewport initial-scale maximum-scale minimum-scale user-scalable layout-viewport visual-viewport ideal-viewport webkit -webkit-tap-highlight-color: transparent -webkit-appearance: -webkit-touch-callout","tags":["移动开发"],"categories":["移动开发"]},{"title":"3D转换-转后不显示问题","path":"//","content":"记 CSS过程中遇到的一个小问题的小细节 学习CSS３的3D转换过程中，想做一个案例：两面翻转的盒子 首先来看，实现的最终效果, 如图所示：鼠标一碰到盒子，盒子就会翻转 实现步骤：首先写一个父盒子包含两个子盒子, box是翻转盒子,f1和f2是前和后的两个子盒子 1234&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;f1&quot;&gt;正面&lt;/div&gt; &lt;div class=&quot;f2&quot;&gt;反面&lt;/div&gt;&lt;/div&gt; box先指定大小, 后面给盒子添加上3D呈现属性(transform-style: preserve-3d) 两个小盒子要加定位, f1盒子加上z-index:1; f2 子盒子沿着Y轴旋转 180deg 最后鼠标hover: box 沿着Y轴旋转 180deg 你以为就完事了??? NO ! 重点来了，这样写会发现box父盒子转动后不显示后面的f2子盒子 解决方法: 在 f1 标签上加: backface-visibility: hidden; 才可以转动 具体… 我也不知道什么原因, 之前不加就可以的 关于backface-visibility: hidden的属性点击这里 还有俩个CSS3案例: 运用animation动画实现: CS3动画北极熊: 点击查看 这个运用到animation、rotate、translate、preserve-3d实现: 3D转换-旋转照片: 点击查看","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"CSS-2D-3D转换","path":"//","content":"2D 转换 transform:转换在CSS3中可以实现元素的移动(translate)、旋转(rotate)、缩放(scale)等效果 2D 转换 移动 translate: 2D移动可以改变元素在页面中的位置，类似定位 translate的优点：不会影响其他元素位置，对行内标签没有效果 1transform: translate(x,y); 或者分开写: translateX(50px); translateY(50px); 2D 转换 旋转 rotate:2D旋转可以让元素在2维平面内顺时针旋转或者逆时针旋转 rotate单位是 deg ,角度为: 顺时针、逆时针，默认是元素中心点 1transform:rotate(50deg) 2D 转换中心点 transform-origin： x 和 y 用空格隔开，x y 默认转换的中心点是元素的中心点 可以给x y 设置 像素 或者 方位名词 （top bottom left right center） 1transform-origin: left bottom; 2D 转换之缩放 scale:元素可以缩放，可以放大和缩小，x和y用逗号分隔scale优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子 1transform:scale(x,y); 只写一个参数，第二个数和第一个数一样，相当于 scale(2,2) 2D 转换综合写法:顺序会影转换效果，如果有位移和其他属性的时候，要将位移放到最前 1transform: translate() rotate() scale() 动画 animation :可通过设置多个节点来控制一个或一组动画，常用来实现复杂动画效果，相比较过渡，动画可以实现更多变化、控制、连续自动播放等效果 动画的基本使用:1. 用keyframes 定义动画（类似定义类选择器）12345678@keyframes 动画名称 &#123; 0% &#123; width:100px; &#125; 100% &#123; width:200px; &#125; &#125; 2. 动画序列 0% 是动画的开始，100% 是动画的完成，这样的规则就是动画序列 用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100% 3. 元素使用动画12/* 调用动画 */ animation-name: 动画名称;/* 持续时间 */ animation-duration: 持续时间; 4. 动画简写属性 animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或结束状态 简写属性里不包含 animation-play-state 想要动画走回来 ，而不是直接跳回来：animation-direction：alternate 盒子动画结束后，停在结束位置：animation-fill-mode：forwards 1animation: move 5s linear 2s infinite alternate; 5. 动画常用属性: 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了animation-play-state animation-name 规定@keyframes动画的名称（必须写） animation-duration 规定完成一个动画所花费的秒或毫秒，默认是0（必须写） animation-timing-function 规定速度曲线，默认是“ease” animation-delay 规定何时开始，默认是0 animation-iteration-count 规定被播放的次数，默认是1，还有infinite animation-direction 规定是否在下一动画逆向播放，默认是“normal“,alternate逆播放 animation-play-state 规定运行或暂停动画。默认是”running”,还有”paused” animation-fill-mode 规定动画结束后状态，保持forwards回到起始backwards 12345678910111213141516/* 动画名称(必须) */animation-name: move;/* 动画花费时间 */animation-duration: 2s;/* 动画速度曲线 */animation-timing-function: ease;/* 动画何时开始 */animation-delay: 0.3s;/* 动画播放次数 */animation-iteration-count: infinite;/* 动画逆向播放 */animation-direction: alternate;/* 动画运行和暂停 */animation-play-state: paused;/* 动画结束后的状态 */animation-fill-mode: forwards; 6. 速度曲线细节:animation-timing-function：规定动画的速度曲线，默认是“ease” 值 描述 linear 匀速，动画从头到尾的速度是相同的 ease 默认，动画以低速开始，然后加快，在结束前变慢 ease-in 动画以低速开始 ease-out 动画以低速结束 ease-in-out 动画以低速开始和结束 steps() 指定了时间函数中的间隔数量（步长，要走多少步） 1. 3D移动 translate3d:3D移动在2D移动基础上多加了个可以移动的方向，就是Z轴方向 因为Z轴是垂直屏幕，由里指向外，所以默认是看不到元素在轴的方向上移动 1234translform: translateX(10px)：在x轴上移动translform: translateY(10px)：在Y轴上移动translform: translateZ(10px)：在Z轴上移动（注意：translateZ一般用px单位）translform: translate3d(x,y,z)：x、y、z 分别指要移动的轴的方向的距离 2. 透视 perspective: 如果想要在网页写3D效果需要透视（理解成3D物体投影在2D平面内） 透视的单位是像素，近大远小,往外是正值,往里是负值 透视写在被观察元素的父盒子上面 3. 3D旋转 rotate3d: transform: rotateX(45deg)：沿X轴正方向旋转 45度 transform: rotateY(45deg) ：沿Y轴正方向旋转 45deg transform: rotateZ(45deg) ：沿Z轴正方向旋转 45deg transform: rotate3d(x,y,z,deg)：沿自定义轴旋转 deg为角度（了解即可) xyz表示旋转轴的矢量，是标示你是否希望沿着该轴旋转，最后一个标示旋转的角度 4. 3D呈现 transfrom-style: transform-style: flat 子元素不开启3d立体空间 默认的 transform-style: preserve-3d; 子元素开启立体空间 控制子元素是否开启三维立体环境 代码写给父级，但是影响的是子盒子，这个属性很重要，后面必用 浏览器私有前缀:浏览器私有前缀是为了兼容老版本写法，比较新版本的浏览器无须添加 -moz-：代表 firefox 浏览器私有属性 -ms-：代表 ie 浏览器私有属性 -webkit-：代表 safari、chrome 私有属性 -o-：代表 Opera 私有属性 1234-moz-border-radius: 10px;-webkit-border-radius: 10px;-o-border-radius: 10px;border-radius: 10px; 本节单词： rotate origin scale animation keyframes duration timing-function-ease-linear-out-steps delay iteration-count-infinite direction-alternate play-state-paused-running fill-mode-forwards perspective deg flat webkit","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"前端168个单词","path":"//","content":"width height strong target blank table border caption thead tbody tfoot rowspan colspan text password radio file submit reset button input placeholder checked checkbox multiple select option selected textarea label style stylesheet class size weight normal bold italic family font indent align left center right decoration underline overline none margin line-height wight hover repeat background position top bottom display block inline inline-block dotted dashed solid padding content sizing overflow hidden list-style float clear clearfix both visibility before after fix first child nth last of static relative absolute fixed z-index vertical vertical-align middle transform transition translate radius shadow blur outline opacity focus resize ellipsis email date time month week number tel search required autofocus autocomplete filter calc auto scroll visible nav article section aside footer description keywords shortcut favicon header meta charset title head body image alt audio controls autoplay loop source video muted href self rel line-through baseline spread inset contain cover collapse link visited active cursor pointer move default -webkit-box line-clamp box-orient uploads base common &amp;nbsp &amp;gt &gt; &amp;lt &lt; 新增单词 (1) : 移动开发-Flex布局 flex direction row row-reverse column column-reverse justify-content flex-start flex-end space-around space-between stretch wrap nowrap align-items align-content flex-flow align-self order linear-gradient 新增单词 (2) : CSS-2D-3D转换 rotate origin scale animation keyframes duration timing-function-ease-linear-out-steps delay iteration-count-infinite direction-alternate play-state-paused-running fill-mode-forwards perspective deg flat webkit 新增单词 (3) : 移动开发-流式布局 max min viewport initial-scale maximum-scale minimum-scale user-scalable layout-viewport visual-viewport ideal-viewport webkit -webkit-tap-highlight-color: transparent -webkit-appearance -webkit-touch-callout 新增单词 (4) : CSS高级技巧 ico favicon uploads base common outline resize ellipsis clamp orient email month week number tel search required autofocus complete on filter blur calc article section aside description keywords","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"CSS高级技巧","path":"//","content":"CSS高级技巧 CSS 属性书写顺序(重点): 布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow 自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background 文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-wor 其他属性CSS3：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient … 1234567891011display: block;position: relative;float: left;width: 10px;height: 10px;margin: 10px;padding: 10px;font-family: sans-serif;color: #fff;background: #fff;border-radius: 10px; 完成后的目录及文件结构: 精灵图（sprites）的使用: 精灵图主要针对于小的背景图片使用 主要借助于背景位置来实现—background-position 一般情况下精灵图都是负值。（ X轴右边走是正值，左边走是负值， Y轴同理） 轮廓线 outline:给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框 1input &#123;outline: none; &#125; 防止拖拽文本域 resize:实际开发中，我们文本域右下角是不可以拖拽的 1textarea&#123; resize: none;&#125; 多行文本溢出显示省略号:12345678overflow: hidden;text-overflow: ellipsis;/* 弹性伸缩盒子模型显示 */display: -webkit-box;/* 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 常见表单类型:类型很多，我们现阶段重点记忆三个： number tel search 1text password radio checkbox button file hidden submit reset image 新的输入类型 123456789101112131415&lt;!-- 我们验证的时候必须添加form表单域 --&gt; &lt;form action=&quot;&quot;&gt; 邮箱: &lt;input type=&quot;email&quot; autofocus&gt; &lt;br&gt; 网址: &lt;input type=&quot;url&quot; required&gt; &lt;br&gt; 日期: &lt;input type=&quot;date&quot;&gt; &lt;br&gt; 时间: &lt;input type=&quot;time&quot;&gt; &lt;br&gt; 月: &lt;input type=&quot;month&quot;&gt; &lt;br&gt; 年的第几周: &lt;input type=&quot;week&quot;&gt; &lt;br&gt; 数量: &lt;input type=&quot;number&quot;&gt; &lt;br&gt; 手机号: &lt;input type=&quot;tel&quot;&gt; &lt;br&gt; 搜索框: &lt;input type=&quot;search&quot;&gt; &lt;br&gt; 你喜欢的颜色: &lt;input type=&quot;color&quot;&gt; &lt;br&gt;&lt;!-- 当我们点击提交按钮就可以验证表单了 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; HTML5 新增的表单属性: 属性 值 说明 required required 表单拥有该属性表示其内容不能为空，必填 autofocus autofocus 自动聚焦属性，页面加载完成自动聚焦到指定表单 autocomplete off&#x2F;on autocomplete&#x3D;”on”，关闭autocomplete&#x3D;”off需要放在表单内，同时加上name属性，同时成功提交 multiple multiple 可以多选文件提交 属性选择器: 注意：类选择器、属性选择器、伪类选择器，权重为 10 属性选择器，按照字面意思，都是根据标签中的属性来选择元素 123456789101112/* 只选择 type =text 文本框的input 选取出来 */input[type=text] &#123; color: pink;&#125;/* 选择首先是div 然后 具有class属性 并且属性值 必须是 icon开头的这些元素 */div[class^=icon] &#123; color: red;&#125;/* 选择首先是section 然后 具有class属性 并且属性值 必须是 data结尾的这些元素 */section[class$=data] &#123; color: blue;&#125; 其他特性:图标变模糊 – CSS3滤镜filter:1语法:filter: 函数(); --&gt; 例如：filter: blur(5px); --&gt; blur模糊处理 数值越大越模糊 计算盒子宽度 – calc 函数:calc() 此CSS函数让你在声明CSS属性值时执行一些计算, 括号里面可以使用 + - * &#x2F; 来进行计算 1语法: width: calc(100% - 80px); HTML5新特性: &lt;header&gt; 头部标签 &lt;nav&gt; 导航标签 &lt;article&gt; 内容标签 &lt;section&gt; 定义文档某个区域 &lt;aside&gt; 侧边栏标签 &lt;footer&gt; 尾部标签 广义的 HTML5 是 HTML5 本身 + CSS3 + JavaScript 这个集合有时称为 HTML5 和朋友，通常缩写为 HTML5 HTML5 MDN 介绍：https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML SEO三大标签: title：网页标题标签 description：网页描述标签 keywords：网页关键词标签 ico图标设置:1&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/icon&quot;&gt; 本节单词： ico favicon uploads base common outline resize ellipsis clamp orient email month week number tel search required autofocus complete on filter blur calc article section aside description keywords","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"前端路线","path":"//","content":"前端路线免费且实用的 前端 刷题（面经大全）网站，👉点击跳转到网站。 建议先观看视频导读：https://www.bilibili.com/video/BV1nh411e7oG/ 可根据知识点前的符号按需选学，并获取知识点描述和学习资源。 ⭐️ 必学（追求速成） ✅ 建议学（重要知识） ❗ 面试重点 ❌ 一般没必要学习 💬 描述 📚 资源 🎯 目标 一、前端入门 💬 描述：学习前端基础三件套，建议从实战开始，边学边练，培养兴趣，快速入门。 📚 资源 freeCodecamp 在线编程：https://learn.freecodecamp.one/ 阿里云前端实战学习：https://edu.aliyun.com/roadmap/frontend W3Cschool 编程入门实战：https://www.w3cschool.cn/codecamp/ pink 老师前端入门教程：https://www.bilibili.com/video/BV14J4114768 🎯 目标：了解和实践各语言的基础语法，并能使用开发工具来独立开发一个留言板网站。 ⭐️ 开发工具 💬 描述：工欲善其事，必先利其器。 浏览器 ⭐️ Chrome ✅ Edge ✅ Firefox ❌ Opera Safari 编辑器 ⭐️ VSCode ✅ WebStorm Atom ⭐️ Sublime Text HBuilder X 记事本 在线 IDE 文档笔记 ✅ Markdown 语法 ✅ Typora 在线笔记 语雀 腾讯文档 石墨文档 印象笔记 Mdnice ⭐️ HTML 💬 描述：用于定义一个网页结构的基本技术。 📚 资源：https://developer.mozilla.org/zh-CN/docs/Learn/HTML ⭐️ 基本语法 ⭐️ 标签 分区 div 标题 h1 ~ h6 段落 p 图像 img 列表 ul &#x2F;ol 超链接 a 表单 form 表格 table 框架 iframe ⭐️ 属性 ✅ HTML5 特性 语义化标签 浏览器支持 多媒体标签 Canvas 画布 ❌ 内联 SVG 本地存储 localStorage sessionStorage ❌ Web SQL Web Workers 应用缓存（Cache Manifest） 无障碍 ⭐️ CSS 💬 描述：层叠样式表，用于设计风格和布局。 📚 资源：https://developer.mozilla.org/zh-CN/docs/Learn/CSS ⭐️ 基本语法 ⭐️ 引入方式 行内样式 内部样式表 外部样式表 ⭐️ 选择器 通用选择器 标签选择器 id 选择器 class 选择器 属性选择器 派生选择器 后代选择器 子元素选择器 相邻兄弟选择器 组合选择器 伪选择器 选择器优先级 ⭐️ 属性 单位 px em rem vw vh 背景 文本 字体 列表 表格 ⭐️ 文档流 标准流 浮动流 定位流 ⭐️ 内联元素 &#x2F; 块状元素 ⭐️ 盒子模型 content padding border margin ⭐️ 浮动 设置浮动 float 清除浮动 clear ⭐️ 定位 static absolute fixed relative sticky ⭐️ 层叠规则 ❗ BFC 和 IFC 机制 CSS3 ⭐️ 响应式布局 媒体查询 Flex 布局 Grid 布局 瀑布流 动画 过渡 渐变 背景 边框 圆角 字体 2D &#x2F; 3D 转换 ⭐️ JavaScript 💬 描述：具有函数优先的轻量级，解释型或即时编译型的编程语言。 📚 资源：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript ⭐️ 基本语法 ⭐️ 数据类型 值类型 字符串 String 数组 Number 布尔 Boolean 空值 Null 未定义 Undefined Symbol 引用类型 对象 Object 数组 Array 函数 Function ✅ 数据类型转换 ✅ 函数 ⭐️ 概念 ⭐️ 自定义函数 调用方式 ⭐️ 全局调用 构造函数调用 ⭐️ 函数方法调用 apply call ✅❗ 闭包 ✅ 对象 概念 this 原型链和继承 常用对象 数字 Number 字符串 String 对象 日期 Date 对象 数组 Array 布尔 Boolean 算数 Math 自定义对象 ✅❗ 作用域（作用域链） ✅ BOM API ⭐️ DOM API ⭐️ JSON ⭐️ Ajax ✅ JavaScript 执行机制 ✅ ES6+ 特性 💬 描述：新引入的 JavaScript 语法特性。 📚 资源：ES6 入门教程 https://es6.ruanyifeng.com/ let 和 const 变量解构赋值 对象扩展和新增方法 Symbol Set 和 Map 数据结构 ⭐️❗ Promise &amp; async &#x2F;await 异步编程 Generator 函数异步编程 二、巩固基础 💬 描述：学习前端、计算机、软件开发相关基础知识，并复习巩固上阶段学到的前端三件套。 📚 资源 《JavaScript 高级程序设计》：https://www.code-nav.cn/rd/?rid=28ee4e3e606b1e1a0e3cfd8952d172cf 《JavaScript 忍者秘籍》：https://www.code-nav.cn/rd/?rid=28ee4e3e606b16c00e3c5b18609e3dc2 🎯 目标：熟悉前端三件套语法，尤其是 JavaScript，并了解互联网、域名、浏览器、服务器等，扎实前端程序员的基本功，为下面进入实战开发做准备。 前端基础知识 ✅ 互联网 ⭐️ 域名 ⭐️ DNS ⭐️ 服务器 ✅ 浏览器 浏览器 DOM 事件流 &#x2F; 事件委托 ⭐️ 浏览器加载顺序 ⭐️ 浏览器渲染过程 浏览器事件循环 浏览器同源策略 ❗ 跨域解决方案 浏览器缓存 控制台调试技巧 ✅ HTTP ❗ HTTP 请求过程 常见 HTTP 协议 HTTP 1.0 ⭐️ HTTP 1.1 HTTP 2 HTTP 3 ⭐️ HTTP 请求类别 ⭐️ 常见状态码 1xx 信息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 WebSocket ⭐️ Cookie Session ⭐️ HTTPS 计算机基础✅ 算法和数据结构 ⭐️ 时间 &#x2F; 空间复杂度分析 数据结构 数组 字符串 队列 栈 链表 集合 哈希表 二叉树 算法 排序 双指针 查找 分治 动态规划 递归 回溯 贪心 位运算 DFS BFS 图 ✅ 计算机网络 HTTP 协议 网络模型 UDP &#x2F; TCP 协议 ✅ 操作系统 进程、线程 进程 &#x2F; 线程间通讯方式 进程调度算法 进程 &#x2F; 线程状态 死锁 内存管理 软件开发基础✅ 设计模式 单例模式 代理模式 工厂模式 装饰者模式 观察者模式 策略模式 门面模式 ⭐️ Git 版本控制 常用命令 ✅ Linux 服务器 常用命令 ✅ 正则表达式三、前端工程化 💬 描述：前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高开发过程中的开发效率，减少不必要的重复工作时间。 📚 资源 什么是前端工程化？https://www.zhihu.com/question/433854153/answer/1713597311 🎯 目标：至少学会一门主流的前端开发框架（Vue &#x2F; React），并配合脚手架、组件库、工具等从 0 开始独立搭建并开发一个完整的前端网站，可以试着仿一些知名站点。要求遵循企业开发规范，将项目代码提交到代码仓库中，并独立发布上线，供他人访问。此外，建议抓住机会参与一些团队项目，感受团队开发模式和前端工程化的优势。 ⭐️ 研发流程 技术选型 初始化 开发 本地测试 代码提交 编译、打包、构建 部署 集成测试 发布上线 监控运维 ⭐️ 代码托管 💬 描述：集中存储、备份你的代码，还能和团队成员协作开发。 ⭐️ GitHub Gitee GitLab ✅ Node.JS 💬 描述：一个开源与跨平台的 JavaScript 运行时环境。 它是一个可用于几乎任何项目的流行工具！ 📚 资源 Node.js 官方教程：http://nodejs.cn/learn Node.js 入门：https://cnodejs.org/getstart ⭐️ 包管理 💬 描述：用于安装 Node.js 的扩展、工具等。 ⭐️ npm ⭐️ yarn ❌ bower ✅ npx 开发框架 Express Koa Egg 开发框架 💬 描述：解决特定的问题，提高开发效率、简化我们的代码复杂度。 ⭐️ CSS 框架 ✅ BootStrap ⭐️ Tailwind CSS ⭐️ JavaScript 框架⭐️ Vue Vue Router Vuex ⭐️ React React DOM React Router Redux MobX React Hooks ❌ Angular RxJS NgRx ✅ Svelte✅ UmiJS封装库⭐️ 组件库 ✅ LayUI ⭐️ ElementUI（Vue） ✅ VantUI（Vue） ⭐️ Ant Design（React） Material UI 数据可视化 ✅ AntV Apache ECharts HighCharts D3.js 组件（插件） 富文本编辑器 弹窗 轮播图 工具库 ✅ jQuery ✅ Lodash ✅ Axios 时间处理 Moment.js 动效库 ✅ Animate.css Ant Motion 字体图标库 ⭐️ IconFont IconPark Font Awesome ⭐️ 脚手架 💬 描述：快速生成新项目的目录模板，提升开发效率和开发舒适性。 📚 资源：https://www.jianshu.com/p/25ce8cf2e6a7 Vue CLI create-react-app ✅ Yeoman ⭐️ 前端架构设计 💬 描述：一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效可持续的工作流。 模块化 组件化 ✅ MVVM 设计原则 ⭐️ SPA 单页应用 ⭐️ 多页应用 ✅ 前端路由 PWA 有损服务 ✅ 服务端渲染 💬 描述：在服务端渲染 HTML 页面的模式。 📚 资源：https://www.zhihu.com/question/379563505 Next.js（React） Nuxt.js（Vue） ❌ Universal（Angular） BFF 💬 描述：Backend For Frontend（服务于前端的后端），就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理。 📚 资源：https://www.jianshu.com/p/eb1875c62ad3 GraphQL ✅ 微前端 💬 描述：将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，从而解决庞大的一整块后端服务带来的变更与扩展方面的限制。 📚 资源：https://zhuanlan.zhihu.com/p/96464401 qiankun single-spa CSS in JS 💬 描述：用 JavaScript 来写 CSS。 📚 资源：http://www.ruanyifeng.com/blog/2017/04/css_in_js.html 内联样式 声明样式 引入样式 ⭐️ CSS 模块化 ⭐️ CSS Modules ✅ styled-components ✅ Styled JSX Emotion ✅ 开发调试 💬 描述：本地开发时热更新，提升开发效率。 webpack-dev-server serve 内网穿透 💬 描述：将内网外网通过 nat 隧道打通，让内网的网站、数据让外网可以访问。 Ngrok NATAPP ⭐️ CSS 预编译 💬 描述：使用新的扩展语言以增强 CSS 的能力，并通过预编译的方式将其转换为浏览器认识的 CSS 代码。 ⭐️ SASS ✅ PostCSS Stylus ❌ LESS 测试测试分类 ⭐️ UT 单元测试 SIT 系统集成测试 E2E 端到端测试 UAT 用户验收测试 ✅ Mock 💬 描述：通过随机数据，模拟各种场景，增加单元测试的真实性。 Mock.js ✅ 测试框架 ✅ Jest Enzyme ✅ Puppeteer（Headless Browser） Mocha Jasmine ✅ 代码质量开发规范 💬 描述：依照规范写出的代码会更加合理。 📚 资源：Airbnb 代码规范 https://github.com/BingKui/javascript-zh CSS Style Guide JavaScript Style Guide 类型校验 TypeScript 代码检查 ESLint StyleLint 代码风格 💬 描述：根据配置自动格式化代码，统一格式。 Prettier 提交规范 约定式提交 提交检查 💬 描述：在提交代码时触发一些操作，比如检查代码的风格等。 pre-commit husky 构建工具自动化构建 💬 描述：按照配置好的流程自动打包构建项目，提高团队的开发效率，降低项目的维护难度。 Gulp ✅ npm script Grunt 打包工具 💬 描述：将各种零散的📚 资源文件打包为可在浏览器等环境运行的代码。 ⭐️ Webpack ✅ Rollup ✅ Vite Parcel Snowpack CI &#x2F; CD 💬 描述：通过在应用开发阶段引入自动化来频繁向客户交付应用。 GitLab CI ✅ Jenkins 部署⭐️ Web 服务器⭐️ Nginx 💬 描述：高性能的 HTTP 和反向代理 web 服务器。 📚 资源：腾讯云动手实验室 https://cloud.tencent.com/developer/labs/gallery 反向代理 解决跨域 改写请求 ✅ Apache容器✅ Docker 💬 描述：容器是一个标准化的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境可靠快速地运行到另一个计算环境。Docker 容器镜像是一个轻量的独立的可执行的软件包。包含程序运行的时候所需的一切：代码，运行时间，系统工具，系统库和设置。 📚 资源：Docker 从入门到实践 https://vuepress.mirror.docker-practice.com/ Dockerfile Kubernetes部署策略 全量发布 蓝绿部署 滚动发布 灰度发布 监控告警 前端埋点 错误监控 性能监控 行为监控 四、前端优化 💬 描述：通过分析和优化手段，提高网站的性能和用户体验。 🎯 目标：实践前端优化方法，从多个方面优化自己做过的项目，最好能将优化后的网站与原网站进行对比，得到一些数据和体验上的明显提升。 ✅ 性能优化性能指标 💬 描述：用于衡量一个 Web 页面的性能。 📚 资源：https://juejin.cn/post/6844904153869713416 FP（First Paint） 💬 描述：从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。 FCP（First Contentful Paint） 💬 描述：浏览器首次绘制来自 DOM 的内容的时间。 FMP（First Meaningful Paint） 💬 描述：页面的主要内容绘制到屏幕上的时间。 FSP（First Screen Paint） 💬 描述：页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。 TTI（Time to Interactive） 💬 描述：表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。 优化手段 性能监控 Performance API 样式优化 JavaScript 优化 防抖 节流 代码分割 📚 资源压缩 打包优化 服务器优化 缓存优化 Service Worker 动画性能 dns-prefetch Lazy loading 优化启动性能 异步化 渲染优化 网络优化 移动端性能优化 ✅ CDN 💬 描述：内容分发网络，是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 📚 资源：BootCDN https://www.bootcdn.cn/ 用户体验 设计系统 骨架屏 ✅ 兼容性浏览器兼容性 normalize.css html5shiv.js respond.js Babel Polyfill 屏幕分辨率兼容性跨平台兼容性SEO 💬 描述：搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。 📚 资源：百度搜索📚 资源平台 https://ziyuan.baidu.com/cooperateresource/index robots.txt description keywords SiteMap HTML 标签优化 站内链接建设 友情链接 ✅ 安全 ⭐️ XSS CSRF 反爬虫 SQL 注入 DDoS 五、前端生态 💬 描述：如今，前端领域的范围越来越广，出现了更多前端工程师需要了解和关注的技术。 🎯 目标：能用学到的前端技术去做更多的事情，比如开发个人博客、文档网站、小程序、APP 等。 ⭐️ 静态站点构建开发 React Static 博客 ✅ Gatsby.js ✅ Docusaurus Hugo Hexo 文档 JekyII ⭐️ Docsify VuePress ✅ Dumi ✅ 大前端💬 描述：前端技术的融合更加紧密，应用的领域也更加广泛，前端领域的内容呈现多样化，除了网站外，还可以用前端技术跨平台开发 Android、iOS、小程序、虚拟现实、增强现实等。 移动应用 Hybrid WebView React Native Flutter 移动应用打包 Weex Cordova Phonegap Ionic 桌面应用 Electron NW.js Proton Native 小程序 原生 WebView 跨端开发框架 ✅ uni-app ✅ Taro Flutter Chameleon Wepy Rax 移动端调试 Chrome Dev Tools Android Simulator IOS Simulator ✅ Serverless 💬 描述：一种构建和管理基于微服务架构的完整流程，允许你在服务部署级别而不是服务器部署级别来管理你的应用部署，你甚至可以管理某个具体功能或端口的部署，这就能让开发者快速迭代，更快速地开发软件。 ✅ 云开发 💬 描述：云端一体化的后端云服务 ，采用 Serverless 架构，免去了移动应用构建中繁琐的服务器搭建和运维。同时云开发提供的静态托管、命令行工具（CLI）、Flutter SDK 等能力降低了应用开发的门槛。使用云开发可以构建完整的小程序 &#x2F; 小游戏、H5、Web、移动 App 等应用。 ✅ 腾讯云云开发 阿里云云开发 低代码 💬 描述：无需编码（零代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。 腾讯云低码 阿里宜搭 六、前端求职 💬 描述：求职是一个漫长的过程，建议拉长战线，尽早准备。 🎯 目标：找到理想的工作。 流程 2020 秋招面经汇总：https://www.nowcoder.com/discuss/205497 简历 超级简历 面试题库 牛客前端工程师面试宝典：https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2 前端面试每日 3+1：https://github.com/haizlin/fe-interview React 面试题目 &amp; 题解：https://github.com/sudheerj/reactjs-interview-questions 面经 前端面经汇总：https://www.nowcoder.com/discuss/experience?tagId=644 面试实战 AI 模拟面试：https://www.nowcoder.com/interview/ai/cover?jobTagId=644 七、前端未来 💬 描述：前端未来可能的发展趋势和热门技术。 🎯 目标：关注前沿，持续进步。 WebAssembly 智能 UI React Server Component CSS Houdini WebComponents HTML templates（HTML 模板） Custom elements（自定义元素） Shadow DOM（影子 DOM） 优秀前端人的特质 深厚的功底 良好的编码习惯 发现问题的洞察力 思维灵活，善于思考 追求技术，紧跟前沿 有创造力，有行动力 追求用户体验 时刻保持好奇 全栈意识 解决问题的能力强 懂得合作和高效沟通 重视工作，同样重视生活 责任心和全局观 个人的进步能带动团队的进步 学习资源 编程导航（包含以下所有资源，强烈推荐 👍）：https://www.code-nav.cn freeCodecamp 在线编程：https://learn.freecodecamp.one/ 阿里云前端实战学习：https://edu.aliyun.com/roadmap/frontend W3Cschool 编程入门实战：https://www.w3cschool.cn/codecamp/ 腾讯云动手实验室：https://cloud.tencent.com/developer/labs/gallery pink 老师前端入门教程：https://www.bilibili.com/video/BV14J4114768 MDN 前端文档：https://developer.mozilla.org/zh-CN Node.js 入门：https://cnodejs.org/getstart 前端清单：https://cheatsheets.devtool.tech/ 前端小课：https://lefex.github.io/ 被删的前端游乐场：http://www.godbasin.com/ 《ES6 入门教程》：https://es6.ruanyifeng.com/ 谷歌 Web 开发者：https://developers.google.com/web JavaScript 明星项目：https://risingstars.js.org/2020/zh Best of JS：https://bestofjs.org/ Codewars：https://www.codewars.com/?language=javascript Vue.js examples：https://vuejsexamples.com/ 前端资讯 掘金资讯：https://juejin.cn/news InfoQ：https://www.infoq.cn/topic/Front-end daily.dev：https://daily.dev/ 技术博客 掘金：https://juejin.cn/frontend 腾讯前端 IMWEB：http://imweb.io 腾讯 Web 前端团队 Alloy Team：http://www.alloyteam.com 淘宝前端团队：http://taobaofed.org 百度 Web 前端研发部：http://fex.baidu.com 京东凹凸实验室：https://aotu.io 360 奇舞团：https://75team.com 七牛团队技术博客：http://blog.qiniu.com 有赞技术团队：https://tech.youzan.com/tag/front-end/ 百度 EFE Tech：https://efe.baidu.com/ css-tricks：https://css-tricks.com/archives web.dev：https://web.dev/blog/ 学习要点 前期学习以培养兴趣为主，不要过于追求深层理解。 前端学习不能靠死记硬背，要多敲代码、多做项目实践。 不要急于求成，踏实积累才是硬道理。 本文章转自网络(原作者: 海拥)","tags":["前端技术栈"],"categories":["前端技术栈"]},{"title":"图床方案汇总","path":"//","content":"图床方案汇总目前 MarkDown 作为一种程序员必备的轻量级标记语言，避免了富文本编辑器换平台就要重新排版的繁琐，使我们可以专注于技术的输出，但使用 markdown 也有弊端，那就是图片的存储问题，markdown 文件要用到图片时必须是一个链接。各个平台都有自己的图片存储方法，在不使用图床的情况下，同一篇文章发布到不同的平台需要单独上传图片一次。如果都放本地这样实在是太麻烦了。 目前最好的解决办法就是使用图床来存储图片 常用免费图床盘点 图床 说明 sm.ms 无需注册，海外服务器【免费】 meotu 要注册，国内服务器【免费】 z4a 图床 要注册，国内服务器【免费】 imgtp 无需注册，国内服务器，最大支持 15MB【免费】 imgbed 无需注册，国内服务器，最大支持 20MB【免费】 聚合图床 要注册，国内服务器【免费】 牛图网 无需注册，日本服务器 【免费】 imgbb 无需注册，亚太服务器【免费】 upload 无需注册，海外服务器 【免费】 catbox 无需注册，海外服务器【免费】 路过图床 要注册，海外服务器【免费】 TG 图床 无需注册，国内外服务器【免费】 Postimages 无需注册，国外服务器速度快【免费】 imgloc 无需注册，国内服务器，最大支持 6MB【免费】 上传图片之前建议压缩一下，可以减少空间使用，并且可以有效加快图片载入速度。比较好的压缩工具如下 在线工具： TinyPNG 官网 Imagestool 两者区别是 TinyPNG 是无损压缩，Imagestool 是有损压缩，不过通过肉眼是区别不出两者的。 本地工具： 格式工厂 图床管理工具选择好图床后肯定就是上传并使用图片了，这时就会面对一个问题，那就是每次都要去图床上传，然后复制链接，然后回到使用图片的平台粘贴使用。特别麻烦。所以就出现了图床管理工具帮助我们快速上传图片并获取图片 URL 链接。这样就省去了自己操作的繁琐。 以下是一些优秀的图床管理工具 PicGo 官网、Github 地址(windows 系统、mac 系统) VScode-PicGo 插件 ShareX 官网、Github 地址(windows 系统) uPic 官网、Github 地址（mac 系统） PicUploader 官网、Github 地址(windows 系统、mac 系统) 强烈推荐 PicGo，PicGo 支持 smms、 又拍云 、七牛云 、 阿里云 OSS、 腾讯云 COS、微博、Github、 Gitee、 Amazon S3、自定义上传接口。（还支持其他储存）而且还可以选择上传前压缩图片。压缩工具都省了。如果你有更好的建议或推荐的图床，欢迎在下方评论区留言。 其他方案Github ＋ jsdelivr（不推荐）由于 jsdelivr 具有不稳定因素，非常不推荐使用这个方式当做图床。 NPM ＋ Github ＋ NPM CDN（不推荐）这种方式虽然比 Github ＋ jsdelivr 稳定些，但仍然不推荐，调取 npm 过多可能会被 npm 封号，Github 封库，到那时就真的得不偿失了。因此这两种教程就不在叙述了，也希望，正在如果正在使用这两者方案你的更换一下图床方案。 私有部署图床服务这类在 Github 上有很多开源项目，例如GitHub - lsky-org&#x2F;lsky-pro: ☁️ 兰空图床(Lsky Pro) - Your photo album on the cloud.GitHub - helloxz&#x2F;imgurl: ImgURL 是一个简单、纯粹的图床程序，让个人图床多一个选择。但因为部署成本过高不推荐 Hexo 博客备份与恢复(进阶)此插件有一个 bug！运行 hexo b 后会把主题文件夹里的.git 文件夹删除，导致无法通过 git pull 来升级主题 当我们要换电脑或者重装电脑系统时，博客的备份就显得很重要了，我们无须通过 U盘 来拷贝整个 blog 文件夹，这种方式太浪费时间，我们只需要使用 hexo-git-backup 这个插件，即可帮我们完美的备份好博客。 博客备份安装hexo 版本为 3.xx 以上 1npm install hexo-git-backup --save 配置 2020 年 10 月 1 日之后，新创建的仓库默认分支为 main，按个人实际情况填写 新建仓库，自定义仓库名（如：hexo-backup），权限设置为private。 在博客配置文件 D:\\blog\\_config.yml 中添加以下内容 （非主题配置文件） 1234backup: type: git repository: github: git@github.com:xxx/xxx.git,branchName 如下图： 使用运行 hexo backup 或缩写 hexo b 即可备份博客 1hexo b 博客恢复安装 Gitwindows：在Git 官网下载.exe 文件，安装选项全部默认，注意其中选择环境变量一步推荐选择 Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开Git了。 安装 Node.jshexo 是基于 node.js 编写的，所以需要安装一下 node.js 和里面的 npm 工具。 windows：推荐下载和博客之前运行环境同一版本的 Node.js，安装选项全部默认，一路点击Next。安装好之后，打开 Git Bash，输入 node -v 和 npm -v，如果出现版本号，那么就安装成功了。 生成 SSH 秘钥绑定 Github打开 Git Bash，输入 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 在 C:\\Users\\主用户里出现 .ssh 文件夹，里面有 id_rsa 和 id_rsa.pub 两个文件，复制 id_rsa.pub 的内容。 1cat ~/.ssh/id_rsa.pub 打开Github，在头像下面点击 Settings，再点击 SSH and GPG keys，新建一个 SSH key，名字随便取一个都可以，把刚刚复制 id_rsa.pub的内容粘贴进去。 在 Git Bash 中输入 ssh -T git@github.com，如果出现你的用户名，那就成功了，如下图所示： 下载博客备份文件克隆上面个人备份博客的仓库 hexo-backup 到本地 blog 文件夹 1git clone -o github git@github.com:xxx/xxx.git 安装 Hexo在 blog 文件夹下 GIt Bash Here 1npm install hexo-cli -g 安装依赖文件1npm install 最后运行 hexo cl &amp;&amp; hexo g &amp;&amp; hexo d，检查是否成功。 可能遇见的问题fatal: ‘github’ does not appear to be a git repositoryfatal: Could not read from remote repository 报错原因 如果运行 hexo b 的时候出现上述错误，可以按下述方法解决： 1234git remote -v # 查看远程仓库信息git remote rm origin # 如返回结果为 origin git@github.com:xxx/xxx.gitgit remote add github git@github.com:xxx/xxx.githexo b","tags":["Hexo"],"categories":["Hexo"]},{"title":"Windows软件推荐","path":"//","content":"Windows软件推荐 Windows上的软件数不胜数,同一类型的软件众多。到底哪一款才是适合你自己的，只有自己亲自试用过才知道。以下是我比较喜欢的软件，特别推荐给各位。 下载工具：qBittorrent和Internet Download Manager 聊天软件：tim(虽然已经被腾讯放弃了，但是比起QQ那么臃肿，这个好用点）和 微信(store转製版） 截图软件： snipaste 这个必须推荐 编辑器： vscode 浏览器： chrome 视频播放器： potplayer 和 哔哩哔哩UWP 词典： 欧陆词典 和 GoldenDict 笔记：onenote 和 evernote (用这个截取网页的内容，onenote的web clipper太差） 简单视频製作：Adobe Premiere Pro (编辑视频） 4K Video Downloader（下载视频） Aegisub (製作字幕） Megui(压制视频） 搜索： everything 图片查看： FastStone Image Viewer 压缩软件：winrar (7zip也不错，但是不能设置解压完自动打开解压的文件夹，只能放弃） 清理软件： Wise Care 365 和 CCleaner","tags":["Windows"],"categories":["Windows"]},{"title":"Hexo Butterfly主题配置","path":"//","content":"Hexo Butterfly主题相关配置关于部署Hexo的主题butterfly后，一些相关的配置 其实关于hexo主题的基础网上都挺详细，详情可见作者的教程 准备：将 butterfly&#x2F;_config.yml 文件复制，重命名为 _config.butterfly.yml 放在hexo根目录下，在这个文件里做修改。 首页导航栏在 _config.butterfly.yml 下找到 menu ： 12345678910menu: 首页: / || fas fa-home 归档: /archives/ || fas fa-archive 标签: /tags/ || fas fa-tags 分类: /categories/ || fas fa-folder-open #菜单||fas fa-list: #音乐: /music/ || fas fa-music #电影: /movies/ || fas fa-video 友链: /link/ || fas fa-link #关于: /about/ || fas fa-heart 可在自己不需要的项目前加 # 来使其不出现在导航栏中。 首页的副标题在 _config.butterfly.yml 下找到 subtitle ： 12345678910111213141516subtitle: enable: true # Typewriter Effect (打字效果) effect: false # loop (循环打字) loop: false # source 调用第三方服務 # source: false 关闭调用 # source: 1 调用一言网的一句話（简体） https://hitokoto.cn/ # source: 2 调用一句网（简体） http://yijuzhan.com/ # source: 3 调用今日詩詞（简体） https://www.jinrishici.com/ # subtitle 会先显示 source , 再显示 sub 的內容 source: false # 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字 sub: - 多看书，多看报；少玩电脑，多睡觉 我把打字效果和循环效果都关了，在sub后添加自己的副标题，注意要加 - 且 - 后面要有空格，否则只能显示一个字。当然也可添加多个内容，但好像要打开打字效果，效果见封面。 首页图片在 _config.butterfly.yml 下找到 index_img ： 12# The banner image of home pageindex_img: /img/img.jpg 在主题文件夹 &#x2F;source&#x2F;img 文件夹下添加 img.jpg 文件夹里还有头像、网页图标等文件，都可更改（网页图标更改部署后一直无法成功，具体原因也不是很清楚···） 图片最好不要太大，不然可能导致加载太慢，可以用以下网站进行压缩http://niaoapi.com/ 可在 _config.butterfly.yml 里打开 加载动画 ： 12# Loading Animation (加载动画)preloader: true 缓解载入时间太久的尴尬。 设置主页图片显示大小： 在 _config.butterfly.yml 下找到 index_top_img_height ： 1234# The position of site info, eg: 300px/300em/300rem/10% (主页标题距离顶部距离)index_site_info_top:# The height of top_img, eg: 300px/300em/300rem (主页top_img高度)index_top_img_height: 在 index_top_img_height ：后面加上300px、400px都可，不加就是默认全屏显示。 侧边栏在 _config.butterfly.yml 下找到 aside ： 1234567891011121314151617aside: enable: true hide: false button: true mobile: true # display on mobile position: left # left or right，决定侧边栏在右边还是在左边 card_author: enable: true description: button: enable: true icon: fab fa-github text: github link: https://github.com/username card_announcement: #公告 enable: false content: 问题不大 后面一堆代码我就不列了，不需要的按钮可以用 false 关闭，在card_author的link后面写上自己主页的链接 社交按钮在 _config.butterfly.yml 下找到 social ： 123456# social settings (社交图标设置)# formal:# icon: link || the descriptionsocial: #fab fa-github: https://github.com/xxx || Github fas fa-envelope: mailto:xxx@example.com || Email 想要更多图标可在font-awesome v6中查找找到后可查看其代码，如 QQ ：&lt;i class=&quot;fa-brands fa-qq&quot;&gt;&lt;/i&gt;可提取为 fab fa-qq 带入 socical 中： 1234social: #fab fa-github: https://github.com/xxx || Github fas fa-envelope: mailto:xxx@example.com || Email fab fa-qq: http://wpa.qq.com/msgrd?v=3&amp;uin=你自己的QQ号&amp;site=qq&amp;menu=yes || QQ 注意 ‘||’ 及后面的说明不能缺少。 背景纯色背景在 _config.butterfly.yml 下找到 theme_color ： 123456789101112131415theme_color: enable: true main: &quot;#49B1F5&quot; paginator: &quot;#00c4b6&quot; button_hover: &quot;#FF7242&quot; text_selection: &quot;#00c4b6&quot; link_color: &quot;#99a9bf&quot; meta_color: &quot;#858585&quot; hr_color: &quot;#A4D8FA&quot; code_foreground: &quot;#F47466&quot; code_background: &quot;rgba(27, 31, 35, .05)&quot; toc_color: &quot;#00c4b6&quot; blockquote_padding_color: &quot;#49b1f5&quot; blockquote_background_color: &quot;#49b1f5&quot; scrollbar_color: &quot;#49b1f5&quot; 可自行更换主题中上述元素的颜色。 彩带背景在 _config.butterfly.yml 下找到 canvas_ribbon ： 123456789# canvas_ribbon (静止彩带背景)# See: https://github.com/hustcc/ribbon.jscanvas_ribbon: enable: false size: 150 alpha: 0.6 zIndex: -1 click_to_change: true #点击鼠标更换彩带 mobile: false 后面还有动态彩带背景和canvas_nest（我也不知道是什么，有兴趣的可以试试看） 图片背景将自己喜欢的图片放入 theme&#x2F;butterfly&#x2F;source&#x2F;img 中 在 _config.butterfly.yml 下找到 background ： 1background: url(/blog/img/bg.jpg) 按上述代码写好即可 自定义渐变背景需要在 theme&#x2F;butterfly&#x2F;source&#x2F;css 中新建一个 css 文件，文件名自取 之后在 _config.butterfly.yml 下找到 inject ： 12345678# Inject# 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/mycss.css&quot;&gt; # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt; bottom: # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt; 在 head 中插入 - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/mycss.css&quot;&gt; 关闭 js 动态背景 原本 background 处改成： 1background: &quot;#efefef&quot; 打开css文件，复制代码： 1234567/* 背景渐变 */#web_bg&#123; /*紫粉渐变*/ /*background-image: linear-gradient(120deg, #e0c3fc 0%, #8ec5fc 100%);*/ /*粉白蓝*/ background-image: linear-gradient(-225deg, #dfbacd 0%, #B8DCFF 48%, #58abf3 100%);&#125; 可自行更改配置，不需要的代码用&#x2F;* *&#x2F;注释， css 代码可在这里得到，选择喜欢的渐变颜色，点击右下角 copy css 复制 css 代码即可。效果如下： 页脚默认页脚为主题色。可在 _config.butterfly.yml 下找到 footer ， 其中包含页脚设置： 12345678# Footer Settings# --------------------------------------footer: owner: enable: true since: 2022 custom_text: copyright: true # Copyright of theme and framework 可以配置页脚显示的内容； 还有页脚背景： 12# Footer Backgroundfooter_bg: false 打开后页脚图片将与主页图片（index_img）底部一致； 也可进行自定义渐变页脚： 在原本配置渐变背景的 css 文件下复制代码： 123456789/* 页脚footer */#footer &#123; /* 与背景渐变效果一致*/ background-image: linear-gradient(-225deg, #d6badf 0%, #B8DCFF 28%, #58abf3 100%);&#125;#footer:before &#123; background-color: rgba(0, 0, 0, 0);&#125; 效果如下： 同上，渐变效果可以自己配置。 css 、js 还能配置许多效果，网上许多博主也有发布魔改教程，感兴趣的可以自行查找，这里不过多赘述。 文章文章的封面每篇文章都可以设置自己的封面，或者统一使用一个封面，这些都可以在 _config.butterfly.yml 下找到； 1234567891011cover: # display the cover or not (是否显示文章封面) index_enable: false aside_enable: false archives_enable: false # the position of cover in home page (封面显示的位置) # left/right/both position: both # When cover is not set, the default cover is displayed (当没有设置cover时，默认的封面显示) default_cover: # - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg 建议没有文章封面时，将上述几个开关（ index_enable aside_enable archives_enable）都关掉，否则主页的格式会显得奇丑无比： 文章基本设置在 _config.butterfly.yml 下找到 post_meta : 12345678910111213post_meta: page: # Home Page date_type: created # created or updated or both 主页文章日期是创建日或者更新日或都显示 date_format: date # date/relative 显示日期还是相对日期 categories: true # true or false 主页是否显示分类 tags: false # true or false 主页是否显示标签 label: true # true or false 显示描述性文字 post: date_type: both # created or updated or both 文章页日期是创建日或者更新日或都显示 date_format: date # date/relative 显示日期还是相对日期 categories: true # true or false 文章页是否显示分类 tags: true # true or false 文章页是否显示标签 label: true # true or false 显示描述性文字 主页文章显示高度，显示篇数： 123index_post_content: method: 3 length: 500 # if you set method to 2 or 3, the length need to config 这里我多开了一个字数统计，也是在 _config.butterfly.yml 里的 123456# wordcount (字数统计)wordcount: enable: true post_wordcount: true min2read: true total_wordcount: true","tags":["Hexo"],"categories":["Hexo"]},{"title":"Qexo测试","path":"//","content":"Qexo是一个快速、强大、漂亮的在线Hexo编辑器,支持在线新建编辑文章 新建编辑单独页面 友情链接 还支持页面管理 自定义图床等功能。当然，最让我心动的就是可以在线编辑发布文章 本文章由Qexo发送！ 一篇测试文章！ 如果您看见此篇说明自动部署成功！ 💌本站镜像 PS:根据适合自己访问较快的镜像访问即可！ 主站 Vercel镜像 Netlify镜像 Cloudflare镜像 Netlify自带域 Render节点 Gitee XC-Blog状态监控 GitHub Qexo管理","tags":["Qexo"],"categories":["Qexo"]},{"title":"This指向与改变This指向","path":"//","content":"This指向与改变This指向This 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象。 例1： 12345678910var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window this 永远指向最后调用它的那个对象，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()； 注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property &#39;name&#39; of undefined。 例2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。 我们做一个小小的改动： 例 3： 12345678var name = &quot;windowsName&quot;; var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn(); 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。所以fn方法中的this指向a 例 4： 12345678var name = &quot;windowsName&quot;;var a = &#123; // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn(); 这里打印 undefined是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 还是这句话：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined 例 5： 1234567891011var name = &quot;windowsName&quot;;var a = &#123; name : null, // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f(); 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，还是这句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 箭头函数箭头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。 例 8 ： 123456789101112131415161718var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 在函数内部使用 _this = this如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。 例 9： 1234567891011121314151617181920var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind使用 apply、call、bind 函数也是可以改变 this 的指向的， 使用 apply例 10： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry 使用 call例 11： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry 使用 bind例 12： 12345678910111213141516var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下: apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为：1fun.call(thisArg[, arg1[, arg2[, ...]]]) 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3 例 14： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.call(a,1,2) // 3 bind bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 bind 是创建一个新的函数，我们必须要手动去调用： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() // 3 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName; // 返回 &quot;Cherry&quot; new 的过程，(ಥ_ಥ)这里就简单的来看一下 new 的过程吧：伪代码表示： 12345678var a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);new myFunction&#123; var obj = &#123;&#125;; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,&quot;Li&quot;,&quot;Cherry&quot;); return typeof result === &#x27;obj&#x27;? result : obj;&#125; 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"JS防抖与节流（类比游戏技能）","path":"//","content":"JS防抖与节流（类比游戏技能） 点击获取资料–2021最新前端面试题汇总 防抖生活中防抖的例子 酒店的自动开关门 感应到人自动开门，5s后自动关闭 如果5s的倒计时里有人来，那么这个5s重新开始计时 类比技能吟唱 知道释放一个法术(魔法)是需要吟唱时间的 比如死歌的R 比如波比的R 假设的技能没有CD 那么在技能还没有吟唱完的时候再一次使用技能会打断第一次施法，重新开始施法 在上次技能没释放的时候释放下一次技能，第一次施法被打断是很好理解的吧 重新施法，重新开始吟唱也是很好理解的吧 js中的防抖 如键盘输入等 就和上面两个例子中提到的一样。主要是用到了三点 addEventListener setTimeout clearTimeout 基础的html代码如下 12345678const button = document.querySelector(&#x27;#input&#x27;)function input () &#123;console.log(&#x27;input!&#x27;);&#125;function debounce (fn,delay) &#123;// Todo: 完成防抖&#125;button.addEventListener(&#x27;click&#x27;, debounce(input,1000)) 因为防抖需要知道延时时间和完成的事件，所以防抖有两个参数 1.使用高阶函数，避免添加响应的时候触发函数 一步一步来，如果没有使用高阶函数而是直接调用函数，如下图，会在添加响应的时候触发fn() 123function debounce (fn,delay) &#123; fn()&#125; 所以先改为高阶函数解决这个bug 12345function debounce (fn,delay) &#123; return function () &#123; fn() &#125;&#125; 2.使用setTimeout完成延时执行,clearTimeout来控制刷新延时2.1 为什么要把timer定义在函数外面？为了形成闭包，这样在函数内部才能保证clearTimeout掉timer 123456789function debounce (fn, delay) &#123; let timer return function () &#123; clearTimeout(timer) timer = setTimeout(function () &#123; fn() &#125;, delay) &#125;&#125; 3.并不是万事大吉，注意this指针的改变在函数里面log一下this指针 123456789101112131415const button = document.querySelector(&#x27;#input&#x27;)function input () &#123; console.log(&#x27;input!&#x27;); console.log(this);&#125;function debounce (fn, delay) &#123; let timer return function () &#123; clearTimeout(timer) timer = setTimeout(function () &#123; fn() &#125;, delay) &#125;&#125;button.addEventListener(&#x27;click&#x27;, debounce(input, 300)) 结果函数内部的this指针变成了window，这是肯定不行的 3.1 用context保存this指针,args保存添加的参数,用apply来改变this指针的指向1234567891011function debounce (fn, delay) &#123; let timer return function () &#123; let context = this let args=arguments clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context,args) &#125;, delay) &#125;&#125; 成功得到input的this指针 4.return的function不可以使用匿名函数其实是可以用匿名函数来简化上面的代码的，但是只能简化setTimeout里面的函数 需要拿到function里面的context上下文 因为匿名函数没有this指针，所以return的函数写成匿名函数会出错，代码如下 1234567891011function debounce (fn, delay) &#123; let timer return () =&gt; &#123; let context = this let args=arguments clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(context,args) &#125;, delay) &#125;&#125; 这种写法，this指针会指向window最终代码 1234567891011function debounce (fn, delay) &#123; let timer return function () &#123; let context = this let args = arguments clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; 节流生活中节流的例子 鲸鱼到水面换气 鲸鱼是哺乳动物，所以需要每隔一段时间到水面换气 不一直在水面，因为还需要下潜保持皮肤的水分，这就和节约资源类似 鲸鱼呷一口气，这口气能支撑1个小时，那鲸鱼就下潜了，1小时后再来换气 这就是节流 类比平A僵直打过王者荣耀的都知道吧，拆塔的时候疯狂按攻击键？这没多大用 你的攻击次数由你的攻击速度(攻击间隔时长)决定 就是在上一次攻击指令完成前，是没有办法进行下一次攻击指令的 平A的僵直就是节流 js中的节流 如滚动监听 在上面防抖基础上，节流的介绍就不再那么啰嗦，直接开始编写节流的代码 1.使用定时器的思想来完成1.1根据思路写出基础代码 同样是高阶函数 同样要操作timer，timer闭包 如果上一次还没延时没结束，就啥也不做(判断timer是否存在即可)。完成节流任务 12345678910function throttle (fn, delay) &#123; let timer return function () &#123; if (timer) return timer = setTimeout(() =&gt; &#123; fn() timer = null &#125;, delay) &#125;&#125; 1.2关键点还是改变this的指向 123456789101112function throttle (fn, delay) &#123; let timer return function () &#123; let context = this let args = arguments if (timer) return timer = setTimeout(() =&gt; &#123; fn.apply(context, args) timer = null &#125;, delay) &#125; &#125; 2.使用Date对象来实现2.1综合前面的问题，直接写出来 但是发现有一个问题，就是函数第一次会立即执行 123456789101112function throttle (fn, delay) &#123; let pre = 0 return function () &#123; let now = new Date() let context = this let args = arguments if (now - pre &gt; delay) &#123; fn.apply(context, args) pre = now &#125; &#125;&#125; 2.2可以第一次不立即执行吗？可以！ 判断，如果!pre就是第一次，第一次先拿到当前时间就可以了 12345678910111213function throttle (fn, delay) &#123; let pre = 0 return function () &#123; if (!pre) pre = new Date() let now = new Date() let context = this let args = arguments if (now - pre &gt; delay) &#123; fn.apply(context, args) pre = now &#125; &#125;&#125; 3.讨论一下前两种方案的弊端 假设有两次请求，第一次正常，第二次被节流了 最后只执行了一次，这是不愿意看到的！ 如何解决？请看第4点 4.Date结合定时器解决3.的弊端 在2中代码的基础上来添加 闭包的timer,如果在节流时间内，就定一个定时器来完成被吃掉的请求 定时为剩下的时间remainTime&#x3D;delay-(now-pre),定时前记得判断是否存在(存在就不用设置直接return就可以了)，完成后记得要更新pre和timer&#x3D;null 12345678910111213141516171819202122function throttle (fn, delay) &#123; let pre = 0 let timer return function () &#123; if (!pre) pre = new Date() let now = new Date() let context = this let args = arguments let remainTime = delay - (now - pre) if (now - pre &gt; delay) &#123; fn.apply(context, args) pre = now &#125; else &#123; if (timer) return timer = setTimeout(() =&gt; &#123; fn.apply(context, args) pre = now timer = null &#125;, remainTime) &#125; &#125;&#125;","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"如何在1分钟内完美解释什么是 JSONP 请求？","path":"//","content":"如何在1分钟内完美解释什么是 JSONP 请求？何为JSONPJSONP是JSON with Padding的略称，JSONP为民间提出的一种跨域解决方案，通过客户端的script标签发出的请求方式。 那请求何必做得如此麻烦，直接使用ajax做请求岂不美哉，这里便要涉及到一个同源和跨域的问题，往下。 同源请求和跨域请求1同源策略，它是由Netscape网景公司提出的一个著名的安全策略 现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。 而所有非同源的请求（即 域名，协议，端口 其中一种或多种不相同），都会被作为跨域请求，浏览器会将其非同源的响应数据丢弃。 这里可以理解为是浏览器在搞事情，服务端确确实实有返回数据，浏览器接收到返回的数据，发现我们请求的是一个非同源的数据，浏览器再将其响应报文丢弃掉。 而通过一些标签发出的请求则不会被进行同源检查，比如script标签，img标签等等，本文讲述JSONP便是通过script标签做的请求。 JSONP的实现流程图示： 流程： 在发请求先，准备一个全局的接收函数 123window.myCallback = (res)=&gt;&#123; //声明一个全局函数 &#x27;callback&#x27;，用于接收响应数据console.log(res)&#125; 在html创建script标签，发出请求 1234567891011121314&lt;html&gt;....&lt;script&gt; window.myCallback = (res)=&gt;&#123; //这里为上一步定义的全局函数 console.log(res) &#125;&lt;/script&gt;&lt;script url=&quot;xxx?callback=myCallback&quot;&gt; //script标签的请求必须在写在定义全局函数之后 //这里需将全局函数的函数名作为参数callback的value传递 //这里callback这个键名是前后端约定好的&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 服务端接收到请求，将如下数据相应回 1234myCallback(&#123; //一个函数的调用，将数据作为参数传递进去，再将整个函数的调用返回给客户端name:&#x27;ahreal&#x27;,age:18&#125;) 客户端接收到服务端的相应，相当于： 123456789101112131415&lt;html&gt;....&lt;script&gt; window.myCallback = (res)=&gt;&#123; //这里为上一步定义的全局函数 console.log(res) &#125;&lt;/script&gt;&lt;script&gt; //将接收到的数据作为script标签里面的内容展开执行 myCallback(&#123; name:&#x27;ahreal&#x27;, age:18 &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 控制台输出 JSONP和AJAX请求的异同相同点： 使用的目的一致，都是客户端向服务端请求数据，将数据拿回客户端进行处理。 不同点： ajax请求是一种官方推出的请求方式，通过xhr对象去实现，jsonp是民间发明，script标签实现的请求。 ajax是一个异步请求，jsonp是一个同步请求 ajax存在同源检查，jsonp不存在同源检查，后端无需做解决跨域的响应头。 ajax支持各种请求的方式，而jsonp只支持get请求 ajax的使用更加简便，而jsonp的使用较为麻烦。 面试到这里，JSONP的相关概念，已经阐述完毕，面试官问你JSONP请求的时候，两步走，1. JSONP是什么 2. JSONP怎么做。 123456面试官：说说JSONP请求吧。我：JSONP请求首先是为了解决跨域问题而存在的一种民间解决方案balabala... 浏览器存在同源安全机制balabala... 通过标签的形式发请求balabala... 需要和后端同学进行约束balabala... 只能使用get请求balabala... 答道这里JSONP这道题你已经回答了80分了，如果这时候你能够蹦出一句： 1emm...我曾经使用原生js封装过一个jsonp的插件，balabala... 那么你将会是100分的回答 1可是我没封装过JSONP的插件啊喂！","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"移动端最佳适配解决方案","path":"//","content":"移动端最佳适配解决方案移动端rem的适配已经淘汰了，目前大家使用的都是viewport。lib-flexible作者也在github明确地表示lib-flexible这个解决方案可以放弃使用了。 由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。 本文带大家一起来看看评论区所说的viewport适配解决方案。 什么是viewport1viewport翻译成中文的意思大致是视图、视窗。在移动端设备中,整块显示屏就相当于视图、视窗。但这种说法也并不完全正确。因为在移动端设备中,浏览器视图并不是整个屏幕。因此viewport又被分为了3种 layout viewport、visual viewport、ideal viewport 为了能够适配到pc端开发页面中,大部分浏览器把viewport的宽度设为了980px 这个浏览器默认设置的视图被称为 layout viewport。我们可以使用document.documentElement.clientWidth 来获取。 由于 layout viewport的宽度是远大于浏览器宽度的，因此我们需要一个新的viewport来代表浏览器的可视区域宽度，这个视图则被称为visual viewport我们可以使用window.innerWidth来获取。 现在我们已经有两个viewport了,layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的ideal viewport。 ideal viewport 并没有一个固定的尺寸，不同的设备拥有不同的 ideal viewport。比如iphone5的 ideal viewport是 320px 而 iphone6s的 ideal viewport却是 375px viewport的单位vw、vh1vw、vh将viewport分成了一百份。vw即 viewport width vh即viewport height 1vw等于视图单位的1%的宽度 1vh等于视图单位的1%的高度 如果设计稿的视图为375px 那么1vw 等于 3.75px 在配置开始之前 我们依然需要一个vue-cli项目 在项目的index.html 我们需要在head标签中添加如下代码 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt; viewport适配解决方案我们用到了阿里巴巴手淘团队出品的amfe-flexible这个库。目的是为了获取到不同移动端设备下的像素比。对于rem的适配该库是至关重要的。本篇文章使用viewport适配则不再需要。 要使用viewport适配 我们必须安装postcss-px-to-viewport这个包。这包名是不是有一种似曾相识的感觉。 没错,上篇文章中我们使用过postcss-pxtorem。这两个包不仅名字相似，功能也有相似的地方。postcss-pxtorem是将 px单位转换为rem单位。postcss-px-to-viewport则是将px单位转换为vw、vh 12//引入 postcss-px-to-viewport npm install postcss-px-to-viewport --save-dev 安装完成后 我们需要进行postcss插件相关的配置 在根目录新建一个名为postcss.config.js的文件,如果项目中已包含该文件则无需新建。在文件中写入如下代码: 1234567891011121314151617//postcss.config.jsmodule.exports = &#123; plugins: &#123; &#x27;postcss-px-to-viewport&#x27;: &#123; unitToConvert: &quot;px&quot;, // 要转化的单位 viewportWidth: 375, // UI设计稿的宽度 unitPrecision: 6, // 转换后的精度，即小数点位数 propList: [&quot;*&quot;], // 指定转换的css属性的单位，*代表全部css属性的单位都进行转换 viewportUnit: &quot;vw&quot;, // 指定需要转换成的视窗单位，默认vw fontViewportUnit: &quot;vw&quot;, // 指定字体需要转换成的视窗单位，默认vw selectorBlackList: [&quot;wrap&quot;], // 指定不转换为视窗单位的类名， minPixelValue: 1, // 默认值1，小于或等于1px则不进行转换 mediaQuery: true, // 是否在媒体查询的css代码中也进行转换，默认false replace: true, // 是否转换后直接更换属性值 exclude: [/node_modules/], // 设置忽略文件，用正则做目录名匹配 &#125; &#125;&#125; 在配置上这两个包也有相似的功能。大家可以去参考一下postcss-px-to-viewport作者的github[4] 值得注意的是:postcss-px-to-viewport 同样存在第三方组件库兼容性的问题。比如在设计稿为750px时使用vant组件库会将vant组件的样式缩小。 解决第三方组件库兼容问题vant组件库的设计稿是按照375px来开发的。因此在viewportWidth为750px时会出现转换问题。 1234567891011121314151617181920212223// postcss.config.jsconst path = require(&#x27;path&#x27;);module.exports = (&#123; webpack &#125;) =&gt; &#123; const viewWidth = webpack.resourcePath.includes(path.join(&#x27;node_modules&#x27;, &#x27;vant&#x27;)) ? 375 : 750; return &#123; plugins: &#123; autoprefixer: &#123;&#125;, &quot;postcss-px-to-viewport&quot;: &#123; unitToConvert: &quot;px&quot;, viewportWidth: viewWidth, unitPrecision: 6, propList: [&quot;*&quot;], viewportUnit: &quot;vw&quot;, fontViewportUnit: &quot;vw&quot;, selectorBlackList: [], minPixelValue: 1, mediaQuery: true, exclude: [], landscape: false &#125; &#125; &#125;&#125; 如果读取的node_modules中的文件是vant,那么就将设计稿变为375px。如果读取的文件不是vant的文件,那么就将设计稿变为750px。这样就可以避免vant组件在750px下出现样式缩小的问题了。 同理 这对于其他的移动端UI组件库同样有效果。我们只需要改动这行代码即可 1const viewWidth = webpack.resourcePath.includes(path.join(&#x27;node_modules&#x27;, &#x27;vant&#x27;)) ? 375 : 750; 至此，我们的viewport的适配就做好了，只需要按照设计稿的比例进行开发就可以了。","tags":["前端技术栈"],"categories":["前端技术栈"]},{"title":"Git常用命令","path":"//","content":"Git常用命令1、Hexo123456# 清除缓存$ hexo clean# 生成静态文件$ hexo generate# 预览$ hexo server 2、仓库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 3、配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 4、增加&#x2F;删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 5、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 6、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 7、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 8、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 9、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 10、撤销1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all","tags":["GitHub"],"categories":["GitHub"]},{"title":"来自2.5年前端小白的总结","path":"//","content":"来自2.5年前端小白的总结（本文转自网络）先来个自我介绍，我是前端_图图，没错，是图图。趁着周末的时间好好回想了一下自己出来社会这两年多里所走的路，下面废话不多说，进入正题。 我是一名大专生(大专怎么了？大专也有成为大佬级别的人物)，在学校的时候学的是电子商务，其实上课学的都是什么HTML、CSS、Js、还有MySql、PHP这些。在大学里并没有怎么学，整天都是和舍友打游戏，什么LOL，毒奶粉之类的，浪费了三年时光。然后去南宁实训了三个月，当时选的班级是前端，为什么选前端呢？因为在学校的时候学了一点，也有一丢丢的基础。 从学校到社会18年9月份从学校出来找工作，出来之后就没有玩过游戏了，被社会一顿毒打，经过很多挫折磨难，刚开始去面试的时候基本都是遇到一些培训机构，当时只要有面试邀请都非常的开心，但是上度娘一搜都是xxx培训机构什么的，只能吐槽深圳的培训机构是真的多。 第一份工作过了两个星期之后终于有了希望，收到一家外包公司的邀请，然后就去了。也是创业型公司，才几个人。两个后端一个小姐姐前端一个UI加上老板就五个人。然后我也被这家公司录取了，当时跟老板谈的是3k一月。在里面只是用jQuery和原生js写一个管理系统。我回想当时我的前端基础那叫一个差，后来我就买了一本HTML+Css+JavaScript网页设计从入门到精通和一本锋利的jQuery来学。放在现在这两本书对我来说并没有什么用了。 公司有个电商项目给另一个前端小姐姐做，当时她也是刚学完Vue，然后就用Vue做这个项目，我就产生了好奇。我就去网上找教程，找到了Vue仿美团的教程，感觉质量还行，然后就学了两个星期。只是入了个门。当时对ES6、webpack、Git都不知道是个啥东西，就照着视频教程里面敲。项目差不多完成之后，那位小姐姐就跑路了。就等于丢了个坑给我。而且我基础又差。后面加了个需求，需要调后端接口，我弄了两天，那时候的我对ajax一无所知。后来请了大学老师和技术胖群里的一位大佬帮我解决了。从此对前端产生了好感。我在这家公司待了一个月才发现自己是无薪的。另外一个前端也跑了，后来我也跑了。继续找下家。 第二份工作在家待了三四天吧。又收到了面试邀请。也是一家小公司，开的薪资是3.5k，去面试的时候就看到两个人，老板和一个UI。这家公司是做小程序的。还好我在出来找工作的时候，学了一丢丢的程序。我拿了我之前学的Vue仿美团的项目给他看。他觉得还可以。成功找到了第二份工作。 我只在这家公司做了一个星期就离职了。原因很简单。老板要求加班，我对加班并没有什么反感，但是距离公司有点远，当时住在龙岗，公司在华强北的赛格大厦。下班回到家已经很晚了。而且我住的地方离地铁站有点远。还要坐一趟公交出来才到，公交晚上八点半就没有了。而且后端还是一个兼职的后端。然后我故意表现得不好，然后老板就把我开了。得了七百多块钱薪水。然后我用这个钱去买了一本阮大佬的ES6，还有高级程序设计3来学。 第三份工作当时在家投简历看小程序的教程，当时并没有练，只是一直在看。收到了面试的邀请非常兴奋的就去。找了一家做家居和新媒体运营的小公司。也是几个人而已。开的薪资也是3.5k，做一个家居的小程序，也是没有后端，当时老板只是口头上说要招，其实我已经看出来他并不想招，原因很简单，成本高。小公司一般都是这样。想让我自己一个人搞定，我当时的基础并不好，别说后端了。当时我写的小程序除了写一些简单的样式，其余的什么购物车和登录都是复制粘贴网上的。然后过半个月我已经写好了。老板问我能不能上线，我直接懵了，连个后端都没有还谈上线。我很记得有一次，他找我谈话，问我会不会大数据，人工智能这些。我只能告诉他，用什么语言写。 唉，很悲哀，这些不懂的人都以为一个程序员什么大数据人工智能都会。我心里想，如果我会？我还在你这家破公司待？后面小程序项目取消，直接去第三方卖一个。后面又叫我负责做一个官网，其实是一个门户网。用织梦二次开发的。公司买了台服务器给我搞，还好我有一些同学搞SEO优化和二次开发的。我对二次开发并没有什么兴趣，然后我就没做，就托付他们帮我弄。上班的时候就叫他们远程来帮我搞。后来做出来老板不满意不是他们想要的效果，老板就把我开了。那时候刚好是元旦，刚好入职一个月。开心的拿到了3.5k薪资。回去继续找工作。 第四份工作第四份工作，也是做小程序的。也是一家创业型公司。做旅游行业的，据说创业失败，然后转型做软件了。三个人，老板+后端都是95后。在一个民房里面办公，也就是老板的家，老板是深圳本地人。福田和龙华都有房，一个富二代，办公就在龙华。当时心想，终于找到一个有后端的公司了。因为经过前面两家公司都没有后端已经怕了。面试完之后，回去等通知。晚上发消息告诉我，周一上班，给出的薪资试用期3k，转正4k。当时没想那么多。有工作就去了。 我记得当时我连获取input框的值和一个ifelse都不会，都是靠百度或者问群友才会。最最记得的写ifelse判断Tabbar跳转对应的页面都写不出来，更别说for循环了。后面问了一个群友加她好友远程帮我写出来的。注意我的用词她，是一位前端小姐姐。才发现我的技术那么烂。好在公司的两个后端，我不会的他们都会教我给我思路。教我用for循环和小程序的网络请求request。当时遇到不会的就百度，问群友帮忙解决。自己的技术很烂，并没有放弃，每天都肝到凌晨才睡。住也是住在公司，因为是民房，两房一厅。在客厅办公。有时间去看书充电。后面会讲到我的学习之路。 在这家公司干了一年，做了好几个项目，刚开始进去的时候是做公司的产品，后面老板就一直没有理会了，然后又接了几个外包项目做。今年一月份就离职回老家了。离职的原因很简单：老板是一个花父母的钱养员工的。而且很懒，不负责任，画饼专家，做了好几个项目都是烂项目。没一个能挣到钱的，而且弄完设计图就去睡觉。直接睡一天的那种，睡醒就起来吃，吃完就出去泡吧喝酒。不讲武德，来骗来忽悠我这个22岁的前端新同志。整天对我画饼，我也是离职之后才明白这些事情，还是我太年轻了太单纯了。这次教训之后我才懂得，有些话听听就好，不要当真。当然，在这家公司是我成长最快的，我学到的东西还挺多的。也把自己学Vue用到了项目当中，去年年底还趁有时间去学了技术胖出的React教程。也把React应用了到我在这家公司做的最后一个项目里面。 现在的工作我现在待的这家公司是做跨境电商的，创业型公司，福利基本的都有，十来个人，有3个后端，1个UI、1个测试、加我就是2个前端。所用到的技术栈：PC端是React，移动端是Taro开发H5、小程序。刚进去的时候主要是负责开发PC端的电商平台，我和另一个前端大哥。后面PC正式上线之后，就开发了小程序，不得不说Taro的坑有点多。把小程序做完之后，又接着开发H5，开发H5只是把小程序的代码复制一份把不兼容H5修修改改。到八月中旬团队规模已经有六十几个人，技术部占了一半。6个前端、9个后端、4个测试、2IOS、2安卓、产品、产品助理、UI、运维都是一个。非常开心第一次加入这种配置比较好的公司，我们前端主要负责公司的电商平台，还有一个分销系统。接触到的东西还是挺多的，公司的氛围和同事们都挺好的。 我换了这么多家公司的主要原因：一是自己太过盲目渴望工作，并没有好好得去选。二是从第二第三家公司都没有做编程或者技术主管和项目经理之类的职务。这些公司希望同学们就不要考虑了。去那些起码有个后端的公司。技术牛的人，可以直接选择大厂。不管自己什么学历，试试才知道自己能不能进。如果身边有些朋友公司招人的话，可以选择内推。 成长总结 要养成一个有时间就给自己充电的习惯，这里说说我是怎么从一个连for循环、ifelse都不会的渣渣到一个前端工程师的路程。当然，非常感谢第四家公司的老板和后端大哥给了我一次机会，主要是后端大哥在我遇到困难的时候总会给我思路。当然也少不了我的大招JavaScript高级程序设计3这个书。看过的都说好，当然现在也有了第四版。我没买。在第四家公司我基本上是有空我就去翻高级程序设计3这本书，看看是不会的，一定要动手照着书上敲，去理解。这是我大学老师跟我说的，也是我的恩师。不理解就百度找例子看看别人是怎么说这个知识点的。换种方式去理解。遇到难的实在不行就打断点开控制台，看执行看结果。你就能明白了。学了这本书之后我终于知道面试常问的闭包，原型，原型链，面向对象，事件冒泡，事件委托，函数防抖，函数节流等等这些概念。去理解这些知识点会发现非常有趣。我当时都是怀着一个期待的心去看这些知识点，想知道它到底是个什么东西。这本书我学了一年才学完(毕竟还要工作赶项目)。有空就看，甚至有时候看到凌晨。基本每天必看的书，也把里面的图和重要知识点画出来记下来。我的基础也是因为有了这本书才慢慢提升的。 今年八九月份的时候，我的老师打电话给我，叫我回去跟学弟学妹们做个演讲。阐述一遍自己从学校到社会的一个经历，是怎么从一个学渣到一个班级里优秀的学生过程。我回去跟我的老师聊了这些年出社会的各方面，也请他吃了顿饭。来报答这几年对我的教诲。当时我最记得他说的那句话：班里成绩最好的，并不代表出去混得最好。当然也少不了自己的坚持。我大学的室友(也是我的朋友)的一句名言:坚持你所坚持的。这两句话使我在前端这个职业没有轻易放弃，一直都在坚持下去的原因。发现自己缺哪方面的知识就买什么书来学。看不一定会，要动手多实践，这是一个实践的行业。实践才是检验真理的唯一。 还有不要怕犯错，知错就改。这次在这件事上做得不好，及时调整自己，记住这次的教训。下次不要再让类似的情况发生。我就是这么过来的。在职业生涯里肯定难免几次犯错。 不要沉迷于游戏，我出来之后的一两年里基本很少玩游戏，基本都是回家过年的时候才会玩。回深圳之后，就迅速调整自己。不碰游戏，专注于自己的技术。当你想玩游戏的之前，想想自己的处境，自己的技术是不是很牛了？这样才会放弃玩游戏的欲望。偶尔玩玩没事儿，适当放松放松。但是不要太过于放纵自己。 也要学会投资自己，打个比方说，买本跟自己技术相关的书、一个视频教程、一个能提高自己学习效率的工具(Mac)。付出了总会有回报的。 现阶段的我，在前端这个职业里，会把技术放在第一位，薪资第二位。技术提升了，薪资自然也会提升。所以一些刚步入社会的前端同学，有机会就去尝试，不要错过每次的面试机会。不要太纠结薪资的问题，能够养活自己就好。学到东西，提升自己的技术才是硬道理。 我个人觉得看书虽然效率慢，但能够知道很多知识点，而且讲得很细。而看视频教程呢，效率比较高，但是讲得并不深。所以我还是选择看书比较好。这就是我的成长总结，也算是一些建议。勿喷，每个人对每件事的观点看法都不一样，我只是说我自己的一些看法。我所学的，所努力，所做的这些都是为了给家人为自己争口气。 自己的不足 慢慢的发现自己对业务这一块了解的并不是很多，毕竟只是单方面对技术过多的去弥补，并没有考虑过业务的东西。产品提需求就做，并没有仔细的想过这个功能对这个项目的价值在哪？我遇到过很多次都是做出来了这个功能，结果完全没用上，到最后直接被砍掉的情况。 一个技术问题死磕到底。中间就没停过，就连通勤、吃饭、洗澡、睡觉前都会在反复的去想这个问题用什么比较好一点的方案去实现，或者这个功能用什么比较好的方法去优化呢？ 以上只是举了一两个我个人比较严重的不足之处，当然也有在学习相关的书籍和资料，补充自己不足。 未来的职业规划不求进大厂，只求通过自己不断努力提升自己的技术，对标大厂P级别，这就是我未来的目标。如果能进那就最好。我要打破一个大专学历的渣渣也能成为大佬级别的人。 年总结今年也给自己立了几个目标，一是学完ES6，二是买一台MacBookPro，都如期的完成了。感觉自己今年学到的东西挺多哒，很开心自己又成长啦🎉🎉🎉，也提前完成了今年的目标啦。另外还看了几本关于自己职业的相关书籍啦。知道如何从一个新手到大师的过程和所具备的思维方式。还有一些学习方式。这基本对于我们程序员来说最好不过了，推荐大家看。自己的收获满满哒。最惊喜的是自己还弄了一个服务器。虽然最后两三个月自己有点网瘾有点颓废。但是看看银行卡余额学习的动力就来啦。2020年马上就要过去了，虽然说是一个不好的年，但是我们都要一起努力加油！新的一年新目标。数据结构，设计模式，冲鸭！ 结尾：本文转自微信（JS每日一题），作为正在学习前端的朋友，也是一种对前端行业的认识吧！","tags":["前端技术栈"],"categories":["前端技术栈"]},{"title":"如何买到合适的域名","path":"//","content":"如何买到合适的域名所谓合适的域名，就是适合自己做站需求的域名，针对不同的需求我们可以选择不同的域名后缀。 1、域名的类型主要有通用顶级域（.com&#x2F;.net&#x2F;.org等）、国别域（.cn&#x2F;.us&#x2F;.hk&#x2F;.co.uk等）、新顶级域（.xyz&#x2F;.top&#x2F;.world&#x2F;.today等）、中文域名（.网址&#x2F;.中国）等。 2、适合长久使用的域名后缀.com众所周知，.com是最早也是知名度最高的域名后缀，搜索引擎对.com域名的站点的收录也很积极，如果想要长久做站的活，首选.com。不过根据ICANN的文件，未来价格还要再涨。目前腾讯云首年55元，续费60元，还没有涨价。如果不是很介意国内域名实名注册的要求的话，建议在腾讯云注册，续费价格相比比较便宜，而且大促时腾讯云有时会有很香的续费券 3、我国国别域名.cn.cn作为我国的国别域名，在国内使用频率还是蛮高的。不过使用.cn域名是要求实名注册的，而且.cn域名也曾有一段黑历史（CNNIC曾大量收回个人注册的.cn域名、罗永浩的bullog.cn被停止解析等等），我个人是不推荐新注册域名选择.cn的 4、免费域名.tk&#x2F;.cf.&#x2F;.ga&#x2F;.ml&#x2F;.gqFreenom提供了上述五个后缀的免费域名。不过搜索引擎对于这些免费域名的收录很不友好，所以最好只是拿来练手和放一些不太好用实名域名搞的东西。Freenom官网：https://www.freenom.com/需要说明的是，现在注册freenom的账号和免费域名都有点麻烦，之前注册的账号注册新域名都不太好搞… 5、续费便宜的域名除去freenom五大免费域名后缀外，最省钱的域名估计就是6-9数字.xyz域名,目前国内注册6-9数字的.xyz域名价格大概在6元&#x2F;年，续费价格也差不多。这样的域名除了品相不好，其他的还是挺香的(这么便宜买10年，还要什么自行车~)。之前有良心云家的优惠券，可以做到23元注册10年（参见： DNSPod仅需23元注册10年6-9数字.xyz后缀域名），然而企鹅貌似很快感觉到了一丝丝不对头，于是提价到8元&#x2F;年，10年下来就是80元。但是，企鹅家优惠券常有，现在依然可以做到70元购买10年，相比之下国内阿里云和西部数码的价格就比腾讯云要便宜一些了。腾讯云优惠券传送门（dnspod账号与腾讯云相通）https://www.dnspod.cn/act/DNSPodDomainsCarnivalhttps://www.dnspod.cn/promo/domainscarnival 6、对于新顶级域近年来随着ICANN对域名限制的放开，他们允许任何人以18.5万美元的价格注册任何网络地址后缀，因此出现了很多新顶级域，例如.xyz&#x2F;.work&#x2F;.fun，这些域名的出现使得我们能够注册到自己想要的前缀。比方说，我想要注册helloworld.com，可是这个域名早就被注册了，那么如果我还是想注册一个类似的域名，我就可以选择注册helloworld.club（当然是比不上.com的那个）。相对于传统顶级域，这些新顶级域首年注册费用可能较低（很多都是1元&#x2F;年，不过续费价格大多不算便宜），所以适合于买一个来玩上一年后丢掉… 对于新顶级域，搜索引擎的收录也不是很明朗，这点需要尤其注意。当然，也有很多使用新顶级域的知名网站，例如谷歌母公司的abc.xyz，卖身字节跳动的锤子科技的t.tt，至今还不清押金的ofo小黄车的ofo.so。 7、对于中文域名目前看来，不要注册，除非白送。正常注册的话，贵得很。例如 这是一个示例.网址 ，用户输入域名时需要先键入汉字，再输入英文的 . ，再键入汉字，其实是没有纯英文便捷的，可用性不高。说到白送，现在 .网址 域名真的在白送（首年免费），在阿里云等一些国内域名厂商可以注册到，需要的话可以百度下，找个注册商注册了玩玩。 总结1.推荐注册域名首选.com2.无论选择怎样的域名,都要根据自己的需求和预算来决定3.尽量不要使用免费域名4.新顶级域有待观察5.中文域名是智商税","tags":["网站资源"],"categories":["网站资源"]},{"title":"CentOS 一键安装 Docker和Docker-compose","path":"//","content":"CentOS 一键安装 Docker和Docker-compose1.安装docker这里用官方安装脚本安装安装命令如下： 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun docker CE如何卸载删除使用命令“yum remove docker-ce”后将docker的安装目录删除（rm -rf &#x2F;var&#x2F;lib&#x2F;docker）就可以了。 查看docker版本 1docker -v 启动、停止docker服务 12systemctl start docker #启动docker服务systemctl stop docker #关闭docker服务 2.安装docker-compose下载： 1curl -L https://get.daocloud.io/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 赋予权限1chmod a+x /usr/local/bin/docker-compose 查看docker-compose版本1docker-compose --version 如果报错docker-compose: command not found 设置软链接，设置快捷方式1sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose","tags":["其他技术栈"],"categories":["其他技术栈"]},{"title":"阿里云资源合集","path":"//","content":"阿里云资源合集·目录没有参加阿里达人活动的点这里参与享最高50TB容量、延期卡、福利等以下阿里云总链接（或者点击下方单个链接） 番剧动漫 实用软件 电影｜剧集 游戏合集 音乐 壁纸合集 小说 教程干货 学习相关","tags":["网站资源"],"categories":["网站资源"]},{"title":"15个前端必备学习网站","path":"//","content":"前端开发所需掌握知识点概要 HTML&amp;CSS： 对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、Hack、CSS预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 &amp; 存储、Histoy,多媒体、WebGL\\SVG\\Canvas）； JavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、 其他： 主流MVVM框架(React\\Vue\\Angular)、Hybrid App\\React Native\\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等； 视频介绍视频传送门 前端学习网站推荐 OSCHINA： https://www.oschina.net/（中文开源技术交流社区） 九章算法： https://www.jiuzhang.com/（硅谷顶尖IT人员教授面试技巧） LintCode： https://www.lintcode.com/（空前强大的在线刷题系统） CSDN ： https://chocolate.blog.csdn.net/（优秀的博客） 掘金： https://juejin.im/（帮助开发者成长的社区） 开源社区_深度开源：https://www.open-open.com/（一切开源） 慕课网： http://www.imooc.com/（程序员的梦工厂） div.io： http://div.io（高质量前端资源汇聚） 推酷： https://www.tuicool.com/ （IT人专属个性阅读社区） Hacker News： https://news.ycombinator.com/news（新闻） InfoQ： https://www.infoq.cn/（软件开发及领域知识传播-中文版） w3cplus： http://www.w3cplus.com/（国内前端行业的技术博客） Stack Overflow： http://stackoverflow.com/（为开发人员提供支持） w3school： http://www.w3school.com.cn/（领先的 Web 技术教程 - 全部免费） MDN： https://developer.mozilla.org/zh-CN/docs/Web/（Web 开发技术分享） 官方文档推荐 jQuery 基本原理 ECMAScript 6 入门 作者：阮一峰 JavaScript 秘密花园 web前端开发参考手册系列之CSS参考手册 JavaScript 教程 结尾笔记分享：传送门","tags":["其他技术栈"],"categories":["其他技术栈"]},{"title":"CSS3 圆角边框 阴影 浮动详解","path":"//","content":"CSS3 圆角边框、阴影、浮动详解 圆角边框：在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。border-radius 属性用于设置元素的外边框圆角。语法：border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50%如果不是正方形，这种设置会生成一个圆角矩形 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角。分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius. 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用 盒子阴影：CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。语法：box-shadow: h-shadow v-shadow blur spread color inset ; 123456div &#123; width: 200px; height: 200px; background-color: skyblue; box-shadow: 10px 10px 10px rgb(0, 0, 0, 0.3); &#125; 结果如下：可以通过在浏览器中的“检查”来查看更改选择器中的box-shadow的参数来观察各参数的意义。 文字阴影：语法：text-shadow: h-shadow v-shadow blur color ; 浮动1.1 传统网页布局的三种方式网页布局的本质——用 CSS 来摆放盒子。 把盒子摆放到相应位置。CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 1.2 标准流（普通流&#x2F;文档流）所谓的标准流: 就是标签按照规定好默认方式排列。 块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等标准流是最基本的布局方式。 1.3为什么需要浮动？所谓的标准流: 就是标签按照规定好默认方式排列。总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式。浮动最典型的应用：可以让多个块级元素一行内排列显示。网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 1.4什么是浮动？float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。语法： 选择器 &#123; float: 属性值; &#125; 1234567891011121314151617181920212223 &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .left &#123; width: 200px; height: 200px; float: left; background-color: skyblue; &#125; .right &#123; width: 200px; height: 200px; float: right; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt; 实现两个盒子的左右对齐。 1.5 浮动特性（重难点）加了浮动之后的元素,会具有很多特性,需要我们掌握的。 浮动元素会脱离标准流(脱标)。就像漂浮在标准流上面一样 设置了浮动（float）的元素最重要特性：脱离标准普通流的控制（浮） 移动到指定位置（动）, （俗称脱标）浮动的盒子不再保留原先的位置 浮动的元素会一行内显示并且元素顶部对齐如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列注意： 浮动的元素是互相贴靠在一起的（不会有缝隙)，如果父级宽度装不下这些浮动的盒子， 多出的盒子会另起一行对齐。 浮动的元素会具有行内块元素的特性.任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后都具有行内块元素相似的特性。也就是说如果行内元素有了浮动，则不需要转换块级&#x2F;行内块元素就可以直接给高度和宽度。 1234567891011121314151617181920212223 &lt;style&gt; /* 任何元素都可浮动,不管原先是什么模式元素，添加浮动之后具有行内块元素相似的特性。 */ span, div &#123; float: left; width: 200px; height: 100px; background-color: pink; &#125; /* 如果行内元素有了浮动,则不需要转换块级\\行内块元素就可以直接给高度和宽度 */ p &#123; float: right; height: 200px; background-color: purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;div&gt;div&lt;/div&gt; &lt;p&gt;ppppppp&lt;/p&gt;&lt;/body&gt; p没有给出宽度，浮动之后，他的宽度由内容的宽决定。 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定浮动的盒子中间是没有缝隙的，是紧挨着一起的 1.6 浮动元素经常和标准流父级搭配使用为了约束浮动元素位置，我们页面布局一般采取的策略是：先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧.","tags":["其他技术栈"],"categories":["其他技术栈"]},{"title":"浅谈 HTTP 和 HTTPS","path":"//","content":"浅谈 HTTP 和 HTTPS HTTP 和 HTTPS 的基本概念：HTTP: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。 HTTP 和 HTTPS 的区别？HTTP 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 HTTP 协议 传输的数据进行加密处理，简单来说 HTTPS 协议是由 HTTP 和 ssl 协议构建的可进行加密传 输和身份认证的网络协议，比 HTTP 协议的安全性更高。 主要的区别如下： HTTPS 协议需要 ca 证书，费用较高。 HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议。 使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443 HTTP 的连接很简单，是无状态的；HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传 输、身份认证的网络协议，比 HTTP 协议安全。 HTTPS 协议的工作原理： 客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。 客户使用 HTTPS url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信。 HTTPS 协议的优点：使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。 HTTPS 协议的缺点：HTTPS 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 HTTPS 缓存不如 HTTP 高效，会增加数据开销。 SSL 证书也需要钱，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。","tags":["网络协议"],"categories":["网络协议"]},{"title":"CSS属性大全","path":"//","content":"CSS属性大全文字属性： 字体：font: 10px; 文本字体：font-family: 宋体; 文本字号：font-size: 10px; 文本字体样式：font-style: normal; 文本字体粗细：font-weight: 700; 文本字体行高：line-height: 10px; 内容水平对齐：text-align: center; 文本缩进：text-indent: 10em; 文本大小写：text-transform: capitalize; 文本不换行：white-space: normal; 文本溢出裁切：text-overflow: clip; 文本下划线：text-decoration: none; 文本阴影：text-shadow: none; 颜色color: red; 边框属性： 边框：border; 上边框：border-top; 右边框：border-right; 下边框：border-bottom; 左边框：border-left; 圆角边框：border-radius; 阴影：box-shadow； 尺寸属性:固定宽度：width; 最小宽度：min-width; 最大宽度：max-width; 固定高度：height; 最小高度：min-height; 最大高度：max-height; 溢出方式：overflow; 横向溢出：overflow-x; 纵向溢出: overflow-y; 背景属性: 背景：background; 背景颜色：background-color; 背景图像：background-image; 铺排填充：background-repeat; 滚动固定：background-attachment; 背景图像位置：background-position; 背景尺寸大小：background-size； 盒子阴影: 外边距&#x2F;外间距&#x2F;外补白：margin; 外上边距：margin-top; 外右边距：margin-right; 外下边距：margin-bottom; 外左边距：margin-left; 内边距&#x2F;内填充&#x2F;内补白：padding; 内上边距：padding-top； 内右边距：padding-right; 内下边距：padding-bottom; 内左边距：padding-left; 浮动：float; 清除浮动：clear； 显示方式：display； 伪类属性： 默认链接状态：link(a:link), 访问过的链接：:visited(a:visited); 正在活动链接：:active(a:acvive)； 触发的状态：:hover(a:hover); 输入框焦点：:focus(input:focus); CSS3新增: 前插入内容：befote(p;before); 后插入内容：:after(prafter); 插入内容：content; 收个子元素：:first-child; 该类型首个子元素：:first-of-type; 父级第N个子元素：:nth-child; 该类型第N个子元素：:nth-of-type; 最后子元素：:last-child； 该类型最后子元素：:last-of-type; 定位属性： 定位方式： position; 顶边界向下偏移位置：top; 右边界向左偏移位置：right; 底边界向上偏移位置：bottom; 左边界向右偏移位置：left; 层叠顺序：z-index; 其他样式：列表样式：list-style; 表格： table； 鼠标手势： cursor; 不透明度：opacity; 轮廓：outline; 滚动条：scrollbar; 公典样式:重定义浏览器默认样式： css reset; 媒体查询:媒体查询：mediaCSS;","tags":["前端经验"],"categories":["前端经验"]},{"title":"CSS第五天-定位","path":"//","content":"CSS第五天-定位 静态定位：static 定位的默认值，写边偏移也不会有效果 相对定位：relative父元素搭配子绝父相使用 根据自身原来的位置，进行定位 没有脱标，在页面还占有位置 天生就是给绝对定位当爹用 绝对定位：absolute 根据最近带有定位(非静态)的祖先元素来定位 子绝父相 脱离标准流，在页面不占有位置 绝对定位，固定定位，浮动，可以直接设置宽度和高度，默认宽度是内容宽度 固定定位：fixed 永远根据浏览器可视区域定位，不会随着滚动条的滚动而滚动 可以直接加宽高，默认宽度是内容宽度 脱离标准流，在页面不占有位置 解决分辨率问题有两种方法… 定位层级：z-index 只有定位有这属性，绝对定位、固定定位、相对定位 默认值：auto，数字越大，层级越高 可以设置正值或负值，没单位 过渡: transition 让元素样式慢慢变化，常配合hover使用，增强网页交互体验 过度所有属性：transition: all 1s &#x3D;&#x3D;&#x3D; 给盒子添加阴影效果 transition: 过度属性 花费时间(s) 运动曲线 何时开始 可以简写：transition: width 1s, height 1s, background 1s 盒子阴影: box-shadow 给盒子添加阴影效果 h-shadow、v-shadow、blur、color… spread 语言扩大 &#x2F;&#x2F;&#x2F; inset 内部阴影 隐藏元素（重点）：开发中经常会通过 display属性完成元素的显示隐藏切换 display：none；（隐藏）、 display：block；（显示） visibility：hidden 隐藏元素本身，隐藏后的元素还占有位置 display：none 隐藏元素本身，隐藏后的元素不占有位置 垂直方向居中：123456第一种： 第二种：left: 50% 第三种：top: 50% margin-left: -75px top: 0left: 50% top: 50% left: 0transform: translate(-50%, -50%) margin-top: -40px right: 0 bottom: 0 margin: auto 水平方向居中： 文字、行内元素、行内块元素 &#x3D;&#x3D;&#x3D; 给其父元素添加text-align: center 块级元素 &#x3D;&#x3D;&#x3D; 给当前元素设置 宽度和margin: 0 auto 浮动元素 &#x3D;&#x3D;&#x3D; 给外面标准流的父元素设置 宽度和margin：0 auto 定位元素 &#x3D;&#x3D;&#x3D; left: 50% translateX(-50%) 溢出隐藏：overflow 默认值 overflow: visible 溢出部分溢出 overflow: hidden 无论是否溢出，都显示滚动条overflow: scroll 根据是否溢出，自动显示或隐藏滚动条 overflow: auto white-space: nowrap;（设置文字在一行显示，不能换行） text-overflow: ellipsis;（规定当文本溢出时，显示省略号来代表被修剪的文本） 边框圆角：border-radius 让盒子四个角变圆润 数字+px 、百分比 （从上、右、下、左) 垂直对齐方式：vertical-align baseline 默认 top 顶部对齐 middle 中部对齐 bottom 底部对齐 精灵图： 测量图片左上角坐标，分别取负值设置盒子的background-position：x y 合并成一张大图片，这张大图片称之为精灵图 减轻服务器的压力，提高页面加载速度 背景图片大小：background-size background-size：宽度 高度 &#x2F;百分比 contain 等比例缩放 cover 将背景图片等比缩放，填满盒子 刚好没空白 background: color image repeat position&#x2F;size &#x2F;&#x2F;连写同时设置时，需要注意覆盖问题 只做了解： 表格边框合并 border-collapse: collapse 焦点选择器 input:focus 链接伪类选择器 link、visited、hover、active（未访问过、访问过、鼠标悬停、鼠标按下） 属性选择器 input [ type &#x3D; text ] 元素整体透明 opacity: 0&#x2F;1 CSS画三角形 border - top - left - bottom - right &#x3D; 0 文字阴影: text-shadow 给文字添加阴影效果 h-shadow 水平偏移量，允许负值 v-shadow 垂直偏移量，允许负值 blur 模糊度 &#x2F;&#x2F;&#x2F; color 阴影颜色 垂直方向居中： 文字、行内元素 line-height 等于height 行内块、行高等于高 搭配vertical-align: middle 块级元素、浮动元素 需要去测量 定位元素 &#x3D;&#x3D;&#x3D; top：50% 50% translateY(-50%) 行内元素、行内块元素、并列关系的垂直居中对齐 设置vertical-align: middle 垂直的用法： 文本框和表单按钮无法对齐 input和img无法对齐 div中的文本框，文本框无法贴顶问题 div不设高度由img标签撑开，此时img标签下面会存在额外间隙问题 使用line-height和vertical-align: middle 让img标签垂直居中问题 鼠标样式：cursor cursor: default; 小箭头 cursor: pointer; 小手 (较常用) cursor: move; 移动 cursor: text; 文本 cursor: not-allowed; 禁止 本节单词： relative absolute fixed z-index vertical vertical-align middle transform transition translate radius static 默认值 baseline 默认值 box 盒子阴影 &amp; text 文字阴影 shadow blur spread inset 只了解：背景图片大小： contain cover 溢出隐藏： auto scroll visible 元素整体透明： opacity 焦点伪类选择器： focus 表格边框合并： collapse 链接伪类选择器： link visited active 鼠标样式： cursor pointer move default","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"CSS第四天-浮动","path":"//","content":"CSS第四天-浮动 浮动（float）： 属性名 效果 float：left 左浮动 float：right 右浮动 让垂直布局的盒子变成水平布局 浮动的元素不能通过text-align:center或者margin:0 auto，让浮动元素本身水平居中 伪元素： ::before 在父元素内容的最前添加一个伪元素 ::after 在父元素内容的最后添加一个伪元素 伪元素：一般页面中的非主体内容可以使用伪元素 before 在元素里面的最前面添加 after 在元素里面的最后面添加 content 必写属性 伪元素添加进来是一个类似行内元素 清除浮动：1、在标准流的情况下，子元素的高度是可以撑开父元素的 2、一旦子元素浮动了，那么父元素就检测不到子元素，从而导致父元素高度为0 3、那么此时我们就需要清除浮动，让子元素可以把父亲撑开 清除浮动的方法： 第一种：clear: both; 第二种：给父元素设置overflow：hidden 因为触发BFC 第三种：.clearfix::after —谁因为浮动没有高度了，就把这个类名给谁 第四种：双伪类元素 ::before—::after ie6&#x2F;7兼容问题—*zoom：1； 方法 优点 缺点 直接设置父元素高度 优点简单粗暴，方便 缺点：有些布局中不能固定父元素高度。如：新闻列表、京东推荐模块 额外标签法 在父元素内容的最后添加一个块级元素。给添加的块级元素设置 clear:both 会在页面中添加额外的标签，会让页面的HTML结构变得复杂 单伪元素清除法 项目中使用，直接给标签加类即可清除浮动 操作：用伪元素替代了额外标签 双伪元素清除法 项目中使用，直接给标签加类即可清除浮动 给父元素设置overflow : hidden 方便 操作：直接给父元素设置 overflow : hidden 1234567.box::after &#123; content: &#x27;.&#x27;; display: block; height: 0; clear: both; visibility: hidden; &#125; 结构伪类选择器： 选择器 说明 :first-child 找到父元素的第一个子元素 :last-child 找到父元素的最后一个子元素 :nth-child(n) 找到父元素第n个子元素 :nth-last-child(n) 找到父元素中倒数第n个子元素 :nth-of-type(n) 找到父元素的子元素固定死 减少对于HTML中类的依赖，有利于保持代码整洁 :nth-of-type → 先通过该 类型 找到符合的元素，然后在这元素中数个数 如果li之间还有别的元素，用of-type永远会找到li里面的第N项元素 li里面有A的话，选择器后面加上li里面所需设置的样式才会生效 功能 公式 偶数 2n、even 奇数 2n+1、2n-1、odd 找到前5个 -n+5 找到从第5个往后 n+5 标准流+浮动： 1、浮动的元素找相邻浮动的元素，顶部对齐，在同一行内显示 要浮动都浮动（加强版的行内块） 2、浮动的元素脱离标准流 在页面中不占有位置 3、浮动的元素只会影响到后面的元素 4、浮动元素不会超出父元素，在父元素内部进行浮动 5、浮动的元素只会压住下面的盒子，压不住盒子里的内容 6、浮动的元素可以直接加宽高，默认宽度是内容宽度 通栏：从左贯穿到右的一个盒子，这个盒子只给高度，不给宽度，让宽度默认给浏览器一样宽 版心：一个有宽度，且居中的盒子 BFC的介绍： 块格式化上下文（Block Formatting Context）：BFC 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 创建BFC方法： html标签是BFC盒子 浮动元素是BFC盒子 行内块元素是BFC盒子 overflow属性取值不为visible。如：auto、hidden… BFC盒子常见特点： BFC盒子会默认包裹住内部子元素（标准流、浮动）→ 应用：清除浮动 BFC盒子本身与子元素之间不存在margin的塌陷现象 → 应用：解决margin的塌陷 本节单词： float clear both visibility before after fix first child nth last of","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"CSS第二天","path":"//","content":"CSS第二天 选择器进阶： 选择器 作用 格式 示例 ⭕后代选择器 找后代 选择器之间通过 空格 分隔 .nav .mark { css } 子代选择器 找儿子 选择器之间通过 &gt; 分隔 .nav &gt; .mark { css } ⭕并集选择器 找到多类元素 选择器之间通过 ，分隔 div,p,span { css } 交集选择器 找同时满足多个选择器的元素 选择器之间紧挨着 p.mark { css } ⭕hover伪类选择器 选中鼠标悬停在元素上的状态 :hover a:hover { css } 选择器注意点：后代选择器中：选择器与选择器之前通过 空格 隔开 子代只包括：儿子 并集选择器：每组选择器可以是基础选择器或复合选择器，每组选择器通常一行写一个，提高代码的可读性 交集选择器：如果有标签选择器，标签选择器必须写在最前面 hover伪类：鼠标悬停在元素上的状态，设置样式 Emmet语法：通过简写语法，快速生成代码HTML篇： 快速生成标签带有类名的标签 p .one 快速生成多个类名 .one + .two 快速生成带有类名的div .one 快速生成类名里面包含类名的div .one &gt; .two 快速生成ol和li ul &gt; li\\ 3* 快速生成li里面带有a链接 ol &gt; li * 3&gt;a CSS篇： 生成宽 w200 生成高 h300 字体样式 font-style___fsn 字体大小 font-size___fz20px 字体类型 font-family___ff 字体粗细 font-weight___fw 行高 line-height___li200px–(后面这个px必须自己上上去) 文本居中 text-align___tac 文本缩进 text-indent___tl 文本修饰 text-decoration___tdn 背景颜色 background-color___bgc 网页端，后面我会添加，暂时放个空链接：点击进入 背景相关属性：1️⃣背景颜色：background-color（bgc）颜色默认值是透明，rgba(0,0,0,0) 、transparent 2️⃣背景图片：background-image（bgi）url中可以省略引号，图片默认水平和垂直方向平铺，类似于背景颜色，不能撑开盒子 3️⃣背景平铺：background-repeat（bgr） 取值 效果 repeat 默认值（水平和垂直方向都平铺） no-repeat 不平铺 repeat-x 沿水平x轴平铺 repeat-y 沿垂直y轴平铺 4️⃣背景位置：background-position（bgp）①方位名词： 1. 水平方向：left center right2. 垂直方向：top center bottom②数字+px(坐标)： x轴——水平向右 y轴——垂直向下 方位名词取值和坐标取值可以混使用，第一个取值表示水平，第二个取值表示垂直 5️⃣背景相关属性的连写形式：background（bg）推荐：background：color image repeat position 元素显示模式： ⭕块级元素 display：block ⭕行内元素 display：inline 行内块元素 display：inline-block 元素显示模式转换 改变元素默认的显示特点，让元素符合布局要求 ①块级元素：display：block 独占一行（一行只能显示一个） 可以设置宽度和高度 默认宽度是父元素的宽度，默认高度是内容高度 注意：p和h里不能放块元素 代表标签：div、p、h系列、ul、li、dl、dt、dd、form、header、nav、footer…… ②行内元素：display：inline 一行显示多个 默认宽度&#x2F;高度是内容的高度和宽度 不能设置高度和宽度 注意：a元素不能包含a元素，a链接可以放任何块级元素 代表标签：a、span 、b、u、i、s、strong、ins、em、del…… ③行内块元素：display：inline-block 一行显示多个 可以设置宽度&#x2F;高度，高度&#x2F;宽度是内容的宽度&#x2F;高度 代表标签：input、textarea、button、select…… 特殊情况：img标签有行内块元素特点，但是Chrome调试工具中显示结果是inline 默认有一个间隙，那个间隙是写代码换行的那个间隙，你把代码排成一排，就没有间隙了 注意点： p标签不要嵌套div、p、h等块级元素 a标签可嵌套任意元素，但a标签不能嵌套a CSS 三大特性：1️⃣继承性:子元素有默认继承父元素样式的特点（子承父业） 可通过调试工具判断样式是否可继承 可以继承的常见属性：color、font-style、font-weight、font-size、font-family、. text-indent、text-align、line-height… 2️⃣层叠性：给同一个标签设置不同的样式 → 此时样式会层叠叠加 → 会共同作用在标签上 给同一个标签设置相同的样式 → 此时样式会层叠覆盖 → 最终写在最后的样式会生效 当样式冲突时，只有当选择器优先级相同时，才能通过层叠性判断结果 3️⃣优先级：不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低选择器样式 优先级公式：继承 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important !important写在属性值的后面，分号的前面！!important不能提升继承的优先级，只要是继承优先级最低！实际开发中不建议使用 !important 。 4️⃣权重叠加计算：（行内样式的个数，id选择器的个数，类选择器的个数，标签选择器的个数）（0,0,0,0) 权重叠加计算公式：（每一级之间不存在进位） 本节单词有： hover repeat background position top bottom display block inline inline-block","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"CSS第三天","path":"//","content":"1️⃣盒子模型：盒子模型部分组成分别如下： 内容区域：content 边框区域：border 内边距区域：padding 外边距区域：margin 内容的宽度和高度：利用 width 和 height 属性设置盒子内容区域的大小 2️⃣边框（border）- 单个属性：给设置边框粗细、边框样式、边框颜色效果 作用 属性名 属性值 边框粗细 border-width 数字+px 边框样式 border-style 实线：solid 虚线：dashed 点线：dotted 边框颜色 border-color 颜色取值 边框（border）- 连写形式： 属性名 属性值 border border : 10px solid red; （快捷键：bd + tab） 边框（border）- 单方向设置： 适用于只给盒子的某个方向单独设置边框 属性名 属性值 border - 方位名词 连写的取值：border：20px solid blue 盒子实际大小初级计算公式： 盒子宽度 &#x3D; 左边框 + 内容宽度 + 右边框 盒子高度 &#x3D; 上边框 + 内容高度 + 下边框 如果盒子被撑大后，可以自己计算，减去多余大小 3️⃣内边距（padding）- 取值：边框与内容之间的距离—-记忆规则：从上、右、下、左取值 取值 示例 含义 一个值 padding：10px 上右下左都设置10px 两个值 padding：10px 20px 上下设置10px 左右设置20px 三个值 padding：10px 20px 30px 上设置10px 左右设置20px 下设置30px 四个值 padding：10px 20px 30px 40px 上设置10px 右设置20px 下设置30px 左设置40px 内边距（padding）- 单方向设置： 用于只给盒子的某个方向单独设置内边距 属性名 属性值 padding - 方位名词 数字 + px：padding-left : 50px 盒子实际大小终极计算公式： 盒子宽度 &#x3D; 左边框 + 左padding + 内容宽度 + 右padding + 右边框 盒子高度 &#x3D; 上边框 + 上padding + 内容宽度 + 下padding + 下边框 如果盒子被撑大后，可以自己计算，减去多余大小 不会撑大盒子的特殊情况： 如果子盒子没有设置宽度，此时宽度默认是父盒子的宽度 此时给子盒子设置左右的padding或者左右的border，此时不会撑大子盒子 ⭕CSS3盒模型（自动内减）： 手动内减：是我们自己去掉多余大小，但是很麻烦 自动内减：给盒子设置属性 box-sizing : border-box ; 即可 浏览器会自动计算多余大小，自动在内容中减去 4️⃣外边距（margin）- 取值：设置边框以外，盒子与盒子之间的距离：取值方向跟padding一样的 取值 示例 含义 一个值 margin：10px 上右下左都设置10px 两个值 margin：10px 20px 上下设置10px 左右设置20px 三个值 margin：10px 20px 30px 上设置10px 左右设置20px 下设置30px 四个值 margin：10px 20px 30px 40px 上设置10px 右设置20px 下设置30px 左设置40px 外边距（margin） - 单方向设置： 属性名 属性值 margin - 方位名词 数字 + px：margin-left : 5px margin单方向设置的应用： 方向 属性 效果 水平方向 margin-left 让盒子往右移动 水平方向 margin-right 让右边盒子往右移动 垂直方向 margin-top 往当前盒子往下移动 垂直方向 margin-bottom 让下面盒子往下移动 5️⃣清除默认内外边距： margin：0 padding：0 浏览器默认给部分标签设置默认margin和padding，在项目前需清除标签默认margin和padding ⭕margin水平居中： 必须是块级元素，必须有宽度才可以设置水平居中 第一种 margin-right&#x2F;left：auto 给左右外边距设置居中 第二种 margin：0 auto 其实就是第一种的简写 第三种 margin：auto 是第二种的简写 外边距正常情况：水平布局的盒子，左右margin正常，互不影响。最终两者距离为左右margin的和 ⭕外边距折叠现象 – ① 合并现象 垂直方向上的两个盒子 一个设置margin-top 一个设置margin-bottom 会取较大的值 总之就是，1. 横着的盒子外边距相加 2.竖着的盒子外边距取最大的数值作为外边距的数值 ⭕外边距折叠现象 – ② 塌陷现象： 给父元素设置overflow: hidden，解决塌陷问题 两个嵌套的块级元素，子元素设置margin-top 会把父元素一起带下来，那么就是塌陷问题 行内元素的margin和padding无效情况： 水平方向的margin和padding布局中有效！ 垂直方向的margin和padding布局中无效！ 也就是说：块级元素和行内块元素，四周margin和padding都可以设置 但行内元素只能设置水平，不能设置垂直，垂直是无效的！ PxCook的基本使用： ① 打开软件 ② 拖拽入设计图 ③ 新建项目 放大设计图：ctrl + + 缩小设计图：ctrl + - 移动设计图：空格按住不放，鼠标拖动 常用工具：量尺寸、吸颜色 从psd文件直接获取数据：切换到开发界面，直接点击获取数据 本节单词有： dotted dashed solid padding content sizing overflow hidden list-style","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"CSS第一天","path":"//","content":"CSS第一天 前言：CSS介绍： CSS：层叠样式表（Cascading style sheets） 作用：给页面中的HTML标签设置样式 结构：HTML（决定了身体） 表现：CSS（决定了样式美观） 行为：JavaScript（决定了交互的动态效果） css写在style标签中，style标签一般写在head标签里面，title标签下面 CSS 标点符号都是英文状态下的 每一个样式键值对写完之后，最后需要写分号 CSS常见属性： CSS常见属性 作用 color 文字颜色 font-size: 文字大小 background-color 背景颜色 width 宽度 height 高度 CSS引入方式： 引入方式 书写位置 作用范围 使用场景 内嵌式 CSS 写在style标签中 当前页面 小案例 外联式 CSS 写在一个单独的.css文件中 多个页面 项目中 行内式 CSS 写在标签的style属性中 当前标签 配合js使用 标签选择器：通过标签名，找到页面中所有这类标签，设置样式 123div &#123; color: red; &#125; 标签选择器选择的是一类标签，而不是单独某一个 标签选择器无论嵌套关系有多深，都能找到对应的标签 类选择器：通过类名，找到页面中所有带有这个类名的标签，设置样式 123.nav &#123; color: red; &#125; 所有标签上都有class属性，class属性的属性值称为类名 类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头 一个标签可以同时有多个类名，类名之间以空格隔开 类名可以重复，一个类选择器可以同时选中多个标签 id选择器：通过id属性值，找到页面中带有这个id属性值的标签，设置样式 123#nav &#123; color: red; &#125; id属性值类似于身份证号码，在一个页面中是唯一的，不可重复的！ 一个标签上只能有一个id属性值，一个id选择器只能选中一个标签 通配符选择器：找到页面中所有的标签，设置样式 123* &#123; color: red; &#125; 开发中使用极少，只会在极特殊情况下才会用到 在小页面中可能会用于去除标签默认的margin和padding 字体和文本样式：1️⃣字体大小：font-size（数字 + px） 谷歌浏览器默认文字大小是16px，单位需要设置，否则无效 2️⃣字体粗细：font-weight 正常：normal（400） 加粗：bold（700） 不是所有字体都提供了九种粗细，因此部分取值页面中无变化 实际开发中以：正常、加粗两种取值使用最多4️⃣ 3️⃣字体样式（是否倾斜）：font-style 正常：normal（默认值） 倾斜：italic 样式的层叠问题：如果给同一个标签设置了相同的属性，此时样式会层叠（覆盖），写在最下面的会生效，所谓的层叠即叠加的意思，表示样式可以一层一层的层叠覆盖 字体font相关属性的连写：写法：font : style weight size family（swsf 时五十分） 只能省略前两个，如果省略了相当于设置了默认值 文本缩进：文本缩进：text-indent（1em） 推荐：1em &#x3D; 当前标签的font-size的大小 文本水平对齐方式:text-align属性给文本所在标签（文本的父元素）设置 属性值 效果 left 左对齐 center 居中对齐 right 右对齐 文本修饰：开发中会使用 text-decoration : none ; 清除a标签默认的下划线 属性值 效果 underline 下划线（常用） line-through 删除线（不常用） overline 上划线（几乎不用） none 无装饰线（常用） 水平居中方法margin : 0 auto：div–p–h：水平居中（margin : 0 auto ; 实现） 行高:行高：line-height（px） 让单行文本垂直居中可以设置 line-height : 文字父元素高度 网页精准布局时，会设置 line-height : 1 可以取消上下间距 Chrome调试工具操作:打开方式：① 右击 → 检查 ② 看哪里 控制样式：① 修改属性值 ② 添加属性 ③ 控制样式生效 特殊情况：① 出现删除线 ② 出现小三角形 本节单词有： style rel stylesheet class size weight normal bold italic family font indent align left center right decoration underline line-through overline none margin line-height wight 常见字体系列（了解）：","tags":["学习笔记-CSS"],"categories":["学习笔记-CSS"]},{"title":"HTML第二天","path":"//","content":"HTML第二天 1️⃣列表标签无序列表–ul （常用） ul：表示无序列表的整体，用于包囊 li 标签 ul 标签中只允许包含 li 标签，默认显示圆点 有序列表–ol （偶尔用） ol：表示有序列表的整体，列表的每一项前默认显示序号标识 ol：标签中只允许包含 li 标签 自定义列表–dl-dt-dd （底部导航用） dl 标签：表示自定义列表的整体 dl 标签中只允许包含dt&#x2F;dd标签 dt 标签：表示自定义列表的主题 dt&#x2F;dd标签可以包含任意内容 dd 标签：表示对于主题的每一项内容，dd 前会默认显示缩进效果 li 标签 li 标签：表示列表标签的每一项，用于包含每一行的内容 li 标签可以包含任意内容 1234&lt;dl&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;内容&lt;/dd&gt;&lt;/dl&gt; 2️⃣表格标签表格的基本标签 标签的嵌套关系：table &gt; tr &gt; td table— 表格整体，可用于包囊多个 tr tr— 表格每行，可用于包囊 td td— 表格单元格，可用于包囊内容 123456标签的嵌套关系：table &gt; tr &gt; td&lt;table&gt; &lt;tr&gt; &lt;td&gt;我是表格基本标签&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格的属性 border— 边框宽度 width— 表格宽度 height— 表格高度 （实际开发推荐用CSS设置） 1&lt;table border=&quot;1&quot; width=&quot;10&quot; height=&quot;10&quot;&gt; 表格标题和表头单元格标签 caption— 表格大标题–默认在表格整体顶部居中位置显示 th— 表头单元格–用于表格第一行，默认内部文字加粗并居中显示 th 标签书写在 tr 标签内部（用于替换 td 标签） 1&lt;caption&gt;标题&lt;/caption&gt; 结构标签（了解） thead：表格头部 tbody：表格主体 tfoot：表格底部 合并单元格 rowspan–跨行合并上下合并→只保留最上的，删除其他 colspan–跨列合并左右合并→只保留最左的，删除其他 12&lt;td rowspan=&quot;3&quot;&gt;你&lt;/td&gt;&lt;td colspan=&quot;3&quot;&gt;好&lt;/td&gt; 3️⃣表单标签 input系列标签value 属性和 name 属性value 属性：用户输入的内容，提交之后会发送给后端服务器 name 属性：当前控件的含义，提交之后可以告诉后端发送过去的数据是什么含义 文本框：**&lt;type&#x3D;”text”&gt;** placeholder–占位符，提示用户输入内容的文本 密码框：**&lt;type&#x3D;”password”&gt;** type不要拼错或者多加空格，否则相当于设置了默认值状态：text→文本框 单选框：**&lt;type&#x3D;”radio” name&#x3D;”sex” value&#x3D;”nan” checked&gt;** 有相同 name 属性值的单选框为一组，一组中同时只能有一个被选中checked–默认选中 复选框: &lt;type&#x3D;”checkbox”&gt; type&#x3D;”checkbox” –在网页中是多选按钮 checked 是默认选中，不要跟 checkbox 弄混了 上传文件按钮：**&lt;type&#x3D;”file” multiple&gt;** multiple–多文件选择 按钮：**&lt;type&#x3D;”submit”&gt;** 提交按钮，提交数据给后端服务器 &lt;type&#x3D;”reset”&gt; 重置按钮，恢复表单默认值 &lt;type&#x3D;”button”&gt; 普通按钮，默认无功能，配合 JavaScript 添加功能 如果需要实现以上按钮功能，需要配合 form 标签使，用 form 标签把表单标签一起包裹即可 button 按钮标签：**&lt;type&#x3D;”button”&gt;** type&#x3D;”button” – 可以设置 type 属性值 submit–提交按钮 reset–重置按钮 button–普通按钮 谷歌浏览器中 button 默认是提交按钮 button 标签是双标签，更便于包裹其他内容：文字、图片等 select 下拉菜单标签 select 标签：下拉菜单的整体 option 标签：下拉菜单的每一项 select 标签语法selected：下拉菜单的默认选中 textarea 文本域标签 textarea— 提供可输入多行文本的表单控件 textarea 语法cols：规定了文本域内可见宽度 rows：规定了文本域内可见行数 label 标签label–常用于绑定内容与表单标签的关系 label 语法：label for&#x3D;”id名字”&gt;&lt;&#x2F;label id 属性在 input 里面写 1️⃣使用方法： 1、使用 label 标签把内容（如：文本）包裹起来 2、在表单标签上添加 id 属性 3、在 label 标签的 for 属性中设置对应的 id 属性值 没有语义的布局标签 - div 和 span实际开发网页时会大量频繁的使用到 div 和 span 这两个没语义的布局标签 div 标签–独占一行 span 标签–一行显示多个 有语义的布局标签（了解）在 HTML5 新版本中，推出了一些有语义的布局标签供开发者使用 header：网页头部 nav：网页导航 footer：网页底部 aside：网页侧边栏 section：网页区块 article：网页文章 字符实体：在 HTML 代码中空格、换行、缩进只会解析一个 常用的字符实体： 空格：&amp;nbsp: &lt;小于号：&amp;lt: &gt;大于号：&amp;gt: type属性值： 说明 type属性值 常用属性 文本框 text placeholder 单选框 password placeholder 单选框 radio name&#x2F;checked 多选框 checkbox checked 文件选择&#x2F;文件上传 file multiple 提交按钮 submit 配合form 重置按钮 reset 配合form 普通按钮 button 配合form 本节单词有： table border caption thead tbody tfoot rowspan colspan text password radio file submit reset button input placeholder checked checkbox multiple select option selected textarea label","tags":["学习笔记-HTML"],"categories":["学习笔记-HTML"]},{"title":"HTML第一天","path":"//","content":"HTML第一天Web标准： 结构HTML 样式CSS 行为JavaScript 注释： 快捷键ctrl+&#x2F; 为代码添加的具有解释性、描述性的信息，主要用来帮助开发人员理解代码 标签的分类： 双标签：例如：p h strong 单标签：例如：img br hr 标签的关系： 1、嵌套关系（父子） 2、并列关系（兄弟） 1、标题标签 h1~h6 独占一行，并且从h1~h6文字逐渐减小 2、段落标签 p （独占一行，段落之间存在间隙） 3、换行标签 br （单标签，让文字强制换行） 4、水平线标签 hr 文本格式化标签 加粗：strong b 下划线：ins u 倾斜：em i 经常用来做一些小图标 删除线：del s 推荐前者写法，有利于机器解析（对搜索引擎SEO）有帮助（强调语义更强烈） img图片标签： src图片路径 alt图片加载不出来时，替换的文本 title 当鼠标悬停时，显示的文本 width 宽度 height 高度 1&lt;img src=&quot;路径&quot; alt=&quot;加载不出来&quot; title=&quot;这是一张图片&quot; width=&quot;1&quot; height=&quot;1&quot;&gt; 路径： 绝对路径（盘符路径或者网络地址） 【常用】相对路径 （从当前文件开始出发找目标文件的过程） &gt; .&#x2F; 同一级路径 &gt; .&#x2F; 下一级路径 &gt; ..&#x2F; 上一级路径 audio音频标签： 音频目前支持三种格式：MP3、Wav、Ogg src：音频路径 controls：音频控件 autoplay：自动播放 谷歌里用不了 loop：循环播放 1&lt;audio src=&quot;路径&quot; controls autoplay loop&gt;&lt;/audio&gt; 为了照顾兼容性 可以这样写 123456&lt;audio controls&gt; &lt;source src=&quot;music.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;music.mp3&quot; type=&quot;audio/mpeg&quot;&gt; （您的浏览器不支持，赶紧换一个吧!）&lt;/audio&gt; ***可以适应不同浏览器用 source 然后把格式都写一遍（MP3、Wav、Ogg）*** video视频标签： 视频标签目前支持三种格式：MP4 、WebM 、Ogg src：视频路径 controls：视频控件 autoplay：自动播放 谷歌浏览器配合muted属性实现自动静音播放 loop：循环播放 1&lt;video src=&quot;video.mp4&quot; controls autoplay loop width=&quot;1&quot;&gt;&lt;/video&gt; a链接标签：点击之后，从一个页面跳转到另一个页面（a标签、超链接、锚链接） 1、外部链接： 1&lt;a href=&quot;https://www.baidu.com/&quot;&gt;百度&lt;/a&gt; 2、内部链接 1&lt;a href=&quot;路径&quot;&gt;内部链接&lt;/a&gt; 3、空链接 1&lt;a href=&quot;#&quot;&gt;会回到页面顶部&lt;/a&gt; 4、死链接 1&lt;a href=&quot;JavaScript:;&quot;&gt;点击以后不会回到页面顶部&lt;/a&gt; 5、图片链接 1&lt;a href=&quot;地址&quot;&gt;&lt;img src=&quot;路径&quot;&gt;&lt;/a&gt; 6、下载链接 1&lt;a href=&quot;xx.exe&quot;&gt;下载xx&lt;/a&gt; 在新窗口打开 _self：在当前窗口中跳转（默认值） _blank：在新窗口中跳转 1&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;新窗口打开&lt;/a&gt; 在head里添加base 标签 可以设置所有链接的打开方式 本节单词有： meta charset title head body strong image alt width height audio controls autoplay loop source video muted href target blank self","tags":["学习笔记-HTML"],"categories":["学习笔记-HTML"]},{"title":"JavaScript基础","path":"//","content":"「学习笔记」JavaScript基础编程基础「计算机语言」分为机器语言，汇编语言，高级语言。计算机内部最终执行的都是机器语言，由0和1这样的二进制数构成。 「数据存储单位」8bit(比特) &#x3D; 1B(Byte)字节 千字节1KB &#x3D; 1024B 「翻译器」高级语言编写的程序不能被计算机识别，需要经过转换，将源代码程序翻译成机器语言才能运行。浏览器里面的js解释器就是这样的一个翻译器。 「程序运行」 打开某个程序时，先从硬盘中把程序的代码加载到内存中 CPU执行内存中的代码 注意：之所以要内存的一个重要原因，是因为 cpu运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械） 初识JavaScript「创始人」布兰登·艾奇(Brendan Eich),起初命名为LiveScript后来与Sun公司合作改名为JavaScript。 「JavaScript」运行在客户端的脚本语言，不需要编译，由js解释器(js引擎)逐行解释执行。Node.js也可以用于服务器端编程。 「JavaScript组成」ECMAScript(JavaScript语法)、DOM(文档对象模型)、BOM(浏览器对象模型) 1JavaScript的作用 表单动态校验(密码强度检测) 网页特效 服务端开发(Node.js) 桌面程序(Electron)、App(Cordova)、控制硬件-物联网(Ruff)、游戏开发(cocos2d-js) 「JavaScript书写位置」 JS有3种书写位置，分别为行内、内嵌和外部。 行内式 12&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#x27;Hello World&#x27;)&quot; /&gt; 内嵌式 123&lt;script&gt; alert(&#x27;Hello World~!&#x27;);&lt;/script&gt; 外部式 12引用外部js文件&lt;script src = &quot;my.js&quot;&gt;&lt;/script&gt; 「注释」 单行注释 1// 我是单行注释 (快捷键 ctrl + / ) 多行注释 123456/* 获取用户年龄和姓名 并通过提示框显示出来 点击vscode左下角管理-键盘快捷方式-切换块注释 (默认快捷键 alt + shift + a) 修改为 (ctrl + shift + /)*/ 变量变量的概念「变量」是程序在内存中申请的一块用于存放数据的空间。变量是用于存放数据的容器，可以通过变量名获取数据，甚至修改数据。 变量的使用「1. 声明变量」 12// 1.声明变量var num; // 声明一个 名称为 num 的变量 var是一个JS关键字，用来声明变量(variable变量的意思)。num是我们定义的变量名，可以通过变量名来访问内存中分配的空间。 「2. 赋值」 1num = 10;//给 num 这个变量赋值为 10 「3. 变量的初始化」 声明一个变量并赋值， 我们称之为变量的初始化。 1var num = 10;//声明变量并赋值为10 「4. 变量语法扩展」 12345// 1.一个变量被重新赋值后，它原有的值会被覆盖掉，变量值以最后一次赋的值为准。var num = 10;num = 11;// 2.同时声明多个变量(只需要写一个var,多个变量名之间用英文逗号隔开)var num = 10, age = 15, name = &#x27;fan&#x27;; 声明变量特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age &#x3D; 10; console.log (age); 不声明 只赋值 10 「5. 变量命名规范」 数据类型分为两类：简单数据类型(Number,String,Boolean,Undefined,Null)和复杂数据类型(object)。 简单数据类型 说明 默认值 Number 数字型,包含整型值和浮点型值 0 String 字符串型 “” Boolean 布尔值型 false Undefined var a;声明了变量a但是没有赋值，此时a &#x3D; undefined undefined Null var a &#x3D; null;声明了变量a为空值 null Number数字型「数字型进制」 1234// 1.在JS中八进制前面加0，十六进制前面加 0xvar num1 = 07; // 对应十进制的7// 2.十六进制数字序列范围：0~9以及A~F var num = 0xA; 「数字型范围」JavaScript中的数值有最大值和最小值 最大值:Number.MAX_VALUE，值为：1.7976931348623157e+308 最小值:Number.MIN_VALUE，值为：5e-32 特殊值：Infinity 无穷大 -Infinity 无穷小 NaN 代表一个非数字 isNaN():用来判断一个变量是否为非数字的类型。非数字型为true,数字型为false。 String字符串型123// 1.字符串型可以是引号中的任意文本，语法为 单引号 和 双引号var msg = &#x27;我的名字叫&#x27;;var name = &quot;fan&quot;; 「1. 字符串转义符」都是以 \\ 开头，详细如下👇👇 转义符 说明 换行符，n是 newline 的意思 \\ 斜杆 \\ &#39; 单引号 ‘ &quot; 双引号 “ \\t tab 缩进 \\b 空格,b是 blank 的意思 「2. 字符串长度」 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。 123// 1.字符串型可以是引号中的任意文本，语法为 单引号 和 双引号var msg = &#x27;我是帅气的饭老板&#x27;;console.log(msg.length); // 显示 8 「3. 字符串拼接」 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 &#x3D; 拼接之后的新字符串。 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 123456789//1.1 字符串 &quot;相加&quot;alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world//1.2 数值字符串 &quot;相加&quot;alert(&#x27;100&#x27; + &#x27;100&#x27;); // 100100//1.3 数值字符串 + 数值alert(&#x27;11&#x27; + 12); // 1112 +号口诀：数值相加，字符相连// 1.4 字符串拼接加强var age = 18;alert(&quot;饭老板今年&quot; + age +&quot;岁了&quot;); 布尔型Boolean 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12console.log(true + 1) // 2console.log(false + 1) // 1 Undefined 和 Null 一个变量声明后没有赋值会有一个默认值undefined(如果相连或者相加时，注意结果😊) 12345var variable;console.log(variable); // undefinedconsole.log(&quot;你好&quot; + variable); // 你好undefinedconsole.log(11 + variable); // NaNconsole.log(true + variable);// NaN 一个变量声明并赋值null,里面存的值为空 12345var var2 = null;console.log(var2); // nullconsole.log(&quot;你好&quot; + var2); // 你好nullconsole.log(11 + var2); // 11console.log(true + var2);// 1 获取变量类型及转换 检测变量的数据类型 typeof 12var num = 10;console.log(typeof num)//结果为 number 字面量:是源代码中一个固定值的表示法，就是字面量如何去表达这个值。通过数据的格式特征可以判断数据的类型 有数字字面量:8,9,10 字符串字面量:’饭老板’，”前端开发” 布尔字面量:true,false 「数据类型转换」 转换为字符串 方式 说明 案例 toString() 转成字符串 var num&#x3D;1; alert(num.toString()) String() 强制转换 var num&#x3D;1; alert(String(num)) 加号拼接字符串 和字符串拼接的结果都是字符串 var num&#x3D;1; alert(num+’我是字符串’) 转换为数字型 方式 说明 案例 parseInt(String)函数 将string类型转成整数型 parseInt(‘11’) parseFloat(String)函数 将string类型转成浮点型 parseFloat(‘11.2’) Number() 强制转换函数 将string类型强制转换为数值型 Number(‘12’) js隐式转换 ( - * &#x2F;) 利用算数运算隐式转换为数值型 ‘12’ - 0 转换为布尔型代表空、否定的值会被转换为false，如’’、0、NaN、null、undefined 其余值都会被转换为true 方式 说明 案例 Boolean() 其他类型转换为布尔值 Boolean(‘true’) 关键字和保留字「标识符」指开发人员为变量、属性、函数、参数取得名字。标识符不能是关键字或保留字。 「关键字」指 JS本身已经使用了的字，不能再用它们充当变量名、方法名 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。 「保留字」实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。 boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。 注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。 运算符与流程控制运算符(操作符)「运算符」是用于实现赋值、比较和执行算数运算等功能的符号。常用运算符分类如下👇 算数运算符 递增和递减运算符 比较运算符 逻辑运算符 赋值运算符 「算数运算符」 运算符 描述 案例 + 加 10+20&#x3D;30 - 减 10-20&#x3D;-10 * 乘 10*20&#x3D;200 &#x2F; 除 10&#x2F;20&#x3D;0.5 % 取余(取模) 返回除法的余数9%2&#x3D;1 浮点数的精度问题 12var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004console.log(0.07 * 100); // 结果不是 7， 而是：7.000000000000001 浮点数值的最高精度是17位小数，但是在进行算数运算时其精确度远远不如整数,所以不要直接判断两个浮点数是否相等! 表达式与返回值 表达式：由数字、运算符和变量组成的式子。 返回值：每一个表达式经过相应的运算之后，会有一个最终结果，称为表达式的返回值 「递增和递减运算符」 递增和递减运算符必须配合变量使用。 递增运算符 123456789101112131415161718var num = 10;alert(++num + 10); // 21 使用口诀：先自加，后返回值var num1 = 10;alert(10 + num1++); // 20 使用口诀：先返回原值，后自加 var num = 1;var num2 = ++num + num++; //num = 2console.log(num2);//4var num = 1;var num1 = 1;var num2 = num++ + num1++; // 1 + 1console.log(num2);//2var num = 1;var num2 = num++ + num++;// 1 + 2 console.log(num2); // 3 「比较运算符」 运算符 描述 案例 结果 &lt; 小于号 1&lt;2 true &gt; 大于号 1&gt;2 false &gt;&#x3D; 大于等于号(大于或者等于) 2 &gt;&#x3D; 2 true &lt;&#x3D; 小于等于号(小于或者等于) 3 &lt;&#x3D; 2 false &#x3D;&#x3D; 判等号(会转型) 15 &#x3D;&#x3D; ‘15’ true !&#x3D; 不等号 37 !&#x3D; 37 false &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;&#x3D; 全等 全不等(要求值和数据类型都一致) 37 &#x3D;&#x3D;&#x3D; ‘37’ false 「逻辑运算符」 逻辑运算符是用来进行布尔值运算的运算符 短路运算:当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值; 运算符 描述 案例 特点 &amp;&amp; “逻辑与”,简称”与” and true &amp;&amp; false 两边都是 true才返回 true || “逻辑或”,简称”或” or true 有真为真 ! “逻辑非”,简称”非” not !true 取反 「赋值运算符」 运算符 描述 案例 &#x3D; 直接赋值 var userName &#x3D; ‘fan’ +&#x3D; -&#x3D; 加减一个数后再赋值 var age&#x3D;5; age+&#x3D;5 *&#x3D; &#x2F;&#x3D; %&#x3D; 乘、除、取模后再赋值 var age&#x3D;5; age*&#x3D;5 「运算符优先级」 优先级 运算符 顺序 1 小括号 () 2 一元运算符 ! ++ – 3 算数运算符 先* &#x2F; % 后+ - 4 关系运算符 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 5 相等运算符 &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D; 6 逻辑运算符 先&amp;&amp; 后|| 7 赋值运算符 &#x3D; 8 逗号运算符 , 流程控制「流程控制」在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，代表三种代码执行的顺序。 「分支流程控制」 1234567891011121314151617181920212223 // 1. 条件成立执行的代码语句 if (条件表达式) &#123; &#125; // 2.if else 语句 if (条件表达式) &#123; // [如果] 条件成立执行的代码 &#125; else &#123; // [否则] 执行的代码 &#125; // 3. if else if 语句(多分支语句) // 适合于检查多重条件。 if (条件表达式1) &#123; 语句1； &#125; else if (条件表达式2) &#123; 语句2； &#125; else if (条件表达式3) &#123; 语句3； .... &#125; else &#123; // 上述条件都不成立执行此处代码&#125; 「三元表达式」 12//如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值表达式1 ? 表达式2 : 表达式3; 「switch分支流程控制」它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。 12345678910switch( 表达式 )&#123; case value1: // 表达式 等于 value1 时要执行的代码 break; case value2: // 表达式 等于 value2 时要执行的代码 break; default: // 表达式 不等于任何一个 value 时要执行的代码&#125; 循环与代码规范循环 运算符 描述 初始化变量 通常被用于初始化一个计数器,该表达式可以使用var关键字声明新的变量，这个变量帮我们来记录次数。 条件表达式 用于确定每一次循环是否能被执行，如果结果是true就继续循环，否则退出循环 操作表达式 每次循环的最后都要执行的表达式。通常用于更新计数器变量的值 123 for(初始化变量; 条件表达式; 操作表达式 )&#123; //循环体&#125; 「执行流程」 初始化变量，初始化操作在整个 for 循环只会执行一次。 执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。 执行操作表达式,此时第一轮结束。 第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。 继续执行操作表达式，第二轮结束。…… 「双重for循环」循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。 1234567891011121314 for (外循环的初始; 外循环的条件; 外循环的操作表达式) &#123; for (内循环的初始; 内循环的条件; 内循环的操作表达式) &#123; 需执行的代码; &#125;&#125;//for循环打印九九乘法表 var str = &quot;&quot;; for (var i = 1; i &lt;= 9; i++) &#123; for (var j = 1; j &lt;= i; j++) &#123; str += j + &quot;x&quot; + i + &quot;=&quot; + j * i + &quot;\\t&quot;; &#125; str += &quot; &quot;; &#125; console.log(str); 「while循环」 123456789101112131415while (条件表达式) &#123; // 循环体代码 &#125;// 1. 先执行条件表达式，如果结果为 true，则执行循环体代码；// 如果为 false，则退出循环，执行后面代码// 2. 执行循环体代码// 3. 循环体代码执行完毕后，程序会继续判断执行条件表达式，//计算1-100的累加和 var i = 1; var sum = 0; while (i &lt;= 100) &#123; sum += i; i++; &#125; console.log(sum); 「do-while循环」 1234567891011121314do &#123; // 循环体代码 - 条件表达式为 true 时重复执行循环体代码&#125; while(条件表达式); // 先执行一次循环体代码，再执行条件表达式 //计算100以内的偶数累加和 var i = 1; var sum = 0; do &#123; if (i % 2 == 0) &#123; sum += i; &#125; i++; &#125; while (i &lt;= 100); console.log(sum); 「continue、break」 continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。 break 关键字用于立即跳出整个循环（循环结束）。 代码规范11. 标识符命名规范 变量、函数的命名必须要有意义 变量的名称一般用名词 函数的名称一般用动词 123456789101112131415161718192. 操作符规范// 操作符的左右两侧各保留一个空格for (var i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; break; // 直接退出整个 for 循环，跳到整个for循环下面的语句 &#125; console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125;3. 单行注释规范 for (var i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; break; // 单行注释前面注意有个空格 &#125; console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125;4. 其他规范//关键词 操作符空格if (true) &#123;&#125;for (var i = 0; i&lt;=10; i++) &#123;&#125; 数组与函数数组「1. 数组的概念」 一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。 「2. 创建数组」 利用new关键字创建数组； 12var 数组名 = new Array([n]);//[]代表可选 若写n，则代表数组的长度var arr = new Array();//创建了一个名为 arr 的空数组 利用数组字面量创建数组 1234567// 1. 使用数组字面量方式创建空的数组var 数组名 = [];//若写n，则代表数组的长度//2. 使用数组字面量方式创建带初始值的数组//3. 声明数组并赋值称为数组的初始化var arr =[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;];var arr2 = [&#x27;fan&#x27;,true,17.5];//数组中可以存放任意类型的数据 「3. 访问数组元素」索引(下标):用来访问数组元素的序号。索引从 0 开始 123456// 定义数组var arrStus = [1,2,3];// 获取数组中的第2个元素 alert(arrStus[1]); // 如果访问数组时没有和索引值对应的元素(数组越界)，// 返回值为undefined 「4. 遍历数组」把数组中的元素从头到尾都访问一次。 1234567891011// 数组的长度,默认情况下等于元素的个数// 当我们数组里面的元素发生了变化，length属性跟着一起变// 如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；// 如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除 var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]); &#125; arr.length = 2; console.log(arr);// red blue 「4. 数组中新增元素」数组中可以通过以下方式在数组的末尾插入新元素; 123456// 1. 数组[数组.length] = 新数据;arr = [] //arr.length = 0;for (var i = 0; i &lt; 10; i++) &#123; arr[arr.length] = &#x27;0&#x27;;&#125;console.log(arr); 「5. 案例」 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1. 筛选数组 大于10的元素选出来放到新数组中var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];var newArr = [];var j = 0;for (var i = 0;i &lt; arr.length; i++)&#123; if (arr[i] &gt;= 10) &#123; newArr[j] = arr[i]; j++; &#125;&#125;console.log(newArr);//第二种方法 利用数组长度的可变性for (var i = 0;i &lt; arr.length; i++)&#123; if (arr[i] &gt;= 10) &#123; newArr[j] = arr[i]; j++; &#125;&#125;// 2. 翻转数组 // 把旧数组索引号第4个取过来（arr.length - 1)，给新数组索引号第0个元素 (newArr.length)// 我们采取 递减的方式 i--var arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;purple&#x27;];var newArr = [];for(var i = arr.length - 1; i &gt;= 0;i--) &#123; newArr[newArr.length] = arr[i]&#125;console.log(newArr);// 3. 数组转换为字符串 用&quot;|&quot; 或其他符号分割// 需要一个新变量用于存放转换完的字符串str//遍历取出数据加到str后面然后加上分隔符var arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;purple&#x27;];var str = &#x27;&#x27;;for(var i = 0; i &lt; arr.length; i++) &#123; str += arr[i] + &#x27;|&#x27;;&#125;console.log(str);// 4. 数组转换为字符串 用&quot;|&quot; 或其他符号分割// 需要一个新变量用于存放转换完的字符串str//遍历取出数据加到str后面然后加上分隔符var arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;, &#x27;purple&#x27;];var str = &#x27;&#x27;;for(var i = 0; i &lt; arr.length; i++) &#123; str += arr[i] + &#x27;|&#x27;;&#125;console.log(str); 冒泡排序![图片](https://cdn1.tianli0.top/gh/web-xc/iMG/posts/xuexijs (9).png) 1234567891011121314function sort(arr) &#123; for(var i = 0; i &lt; arr.length - 1; i++) &#123; for(var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; return arr;&#125;var arr1 = sort([1,4,2,9]); console.log(arr1);//1 2 4 9 函数「1. 函数的概念」封装了一段可被重复调用执行的代码块，通过函数可以实现大量代码的重复使用。函数是一种数据类型。 「2. 函数的使用」 声明函数 12345678910111213141516171. 通过function关键字定义函数 -- 命名函数function 函数名() &#123; //函数体代码&#125;// 1.1 function 是声明函数的关键字，必须小写// 1.2 函数名 命名为动词形式 例: getSum 2. 通过函数表达式定义函数 ---匿名函数var fn = function() &#123;&#125;;// 2.1 fn是变量名，不是函数名// 2.2 fn是变量，只不过变量存储的是函数// 2.3 函数表达式创建的函数可以通过 变量名(); 来调用// 2.4 函数表达式也可以定义形参和调用传入实参。匿名函数使用的第2种方式--匿名函数自调用(function()&#123; alert(123);&#125;)(); 调用函数 1函数名();// 函数声明后调用才会执行函数体代码 函数的封装 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口。 123456789101112/* 例用封装函数计算1-100累加和*/function getSum() &#123;var sumNum = 0; // 准备一个变量，保存累加和for (var i = 1; i &lt;= 100; i++) &#123; sumNum += i; // 把每个数值 都累加 到变量中&#125; alert(sumNum);&#125;// 调用函数getSum(); 「3. 函数的参数」 形参：函数定义时候，传递的参数(实参值传递给形参,不用声明的变量) 实参：函数调用时候，传递的参数 123456//带参数的函数声明function 函数名(形参1,形参2,形参3...) &#123; //函数体&#125;// 带参数的函数调用函数名(实参1,实参2,实参3...); 「函数形参和实参数量不匹配时」 参数个数 说明 实参个数等于形参个数 输出正确结果 实参个数多于形参个数 只取到形参的个数 实参个数小于形参 多的形参定义为undefined,结果为NaN 1234567function getSum(a, b, c) &#123; return a + b + c;&#125;// js中形参的默认值是undefined。// 调用函数var n = getSum(1, 2);// n = NaNvar n = getSum(1, 2, 3, 4); //1 + 2 +3 = 6 「4. 函数的返回值」 返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。 12345678910 // 声明函数 function 函数名() &#123; ... return 需要返回的值; // 1. 函数遇到return会停止执行，并返回指定的值 // 1. 如果函数没有return 返回的值是undefined &#125; // 调用函数 函数名(); //此时调用函数就可以得到函数体内return的值break,continue,return的区别 break: 结束当前的循环体 (如for、while) continue: 跳出本次循环，继续执行下次循环 return: 不仅可以退出(函数体内)循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码 123456789101112131415//避免踩坑 return只能结束函数体内的代码 function breakDown() &#123; for (var i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; return 1; &#125; console.log(i); &#125; &#125; breakDown(); //避免踩坑2 函数如果有return 则返回的是 return 后面的值； // return d,a,b; 返回的是b的值 //如果函数没有 return语句，则返回undefined 「5. arguments的使用」 当不确定有多少个参数传递的时候，可以用 arguments 来获取。JS中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。 伪数组具有以下特点： 具有length属性 按索引方式存储数据 不具有数组的push，pop等方法 123456789101112131415161718192021 function fn() &#123; //arguments 里面存储了所有传递过来的实参 console.log(arguments);// [1,2,3...] console.log(arguments[1]); // 2 console.log(arguments.length); // 3 //我们可以按照数组的方式 遍历argument &#125; fn(1, 2, 3);// 用伪数组 实现求最大值function getMax() &#123; var max = arguments[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; arguments[0]) &#123; max = arguments[i]; &#125; &#125; return max; &#125; var result = getMax(1,3,77,5,85) colsole.log(result); 作用域作用域「作用域」一段程序代码中所用到的名字并不总是有效和可靠的，而限定这个名字的可用性代码范围就是这个名字的作用域。 作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 ES6之前作用域有两种 全局作用域和局部作用域(函数作用域) 「全局作用域」作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的js文件。 「局部作用域」作用于函数内部的代码环境，就是局部作用域。因为跟函数有关系，所以也被称为函数作用域。 「JS没有块级作用域」 块作用域由 {} 包括 在其他编程语言，if语句中，循环语句创建的变量，仅仅只能在本if语句，本循环语句中使用，如下👇👇 12345if(true)&#123; int num = 123; System.out.print(num); //123&#125;System.out.print(num);//报错 以上java代码会报错，因为代码中 {}是一块作用域，其中声明的变量num，在{}之外不能使用，而JavaScript代码则不会报错 Js中没有块级作用域 (在ES6之前) 12345if(true)&#123; var num = 123; console.log(num); // 123&#125;console.log(num);// 123 变量的作用域 在JavaScript中，根据作用域的不同，变量可以分为两种:👇 全局变量 局部变量 「全局变量」在全局作用域下声明的变量(在函数外部定义的变量) 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用var声明的变量也是全局变量(不建议使用)。 「局部变量」在局部作用域下声明的变量(在函数内部定义的变量) 局部变量只能在函数内部使用 在函数内部 var声明的变量是局部变量 函数的形参实际上就是局部变量 「全局变量和局部变量的区别」 全局变量:在任何一个地方都可以使用，只有在浏览器关闭时才会销毁，因此比较占内存 局部变量:旨在函数内部使用，当其所在的代码块被执行时，才会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间。 作用域链「作用域链」只要是代码都在一个作用域中，写在函数内部的局部作用域，未卸载仍和行数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据[内部函数可以访问外部函数变量] 的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。 123456789function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 作用域链采取就近原则的方式来查找变量最终的值 12345678910111213141516var a = 1;function fn1() &#123; var a = 2; var b = &#x27;22&#x27;; fn2(); function fn2() &#123; var a = 3; fn3(); function fn3() &#123; var a = 4; console.log(a); //a的值 4 console.log(b); //b的值 &#x27;22&#x27; &#125; &#125;&#125;fn1(); ![图片](https://cdn1.tianli0.top/gh/web-xc/iMG/posts/xuexijs (8).png) 预解析「预解析相关概念」JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步:预解析和代码执行。 「预解析」在当前作用域下，JS代码执行之前，浏览器会默认把带有 var 和 function声明的变量在内存中进行提前声明或定义。 「代码执行」从上往下执行JS语句 预解析会把变量和函数的声明在代码执行之前完成，预解析也叫做变量、函数提升。 「变量预解析(变量提升)」 变量的声明会被提升到当前作用域的最上面，变量的赋值不提升。 123456789console.log(num); // 结果是多少？var num = 10; // ？相当于var num;console.log(num);// 结果是 undefinednum = 10;结果: undefined注意: 变量提升只提升声明，不提升赋值。 「函数预解析(函数提升)」 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 123456fn();function fn() &#123; console.log(&#x27;打印&#x27;);&#125;结果: 控制台打印字符串 --- &quot;打印&quot;注意: 函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！ 「函数表达式声明函数问题」 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用fn();var fn = function()&#123; console.log(&quot;想不到吧&quot;);&#125;结果:报错提示 &quot;fn is not a function&quot;解释: 该段代码执行之前，会做变量声明提升，fn在提升之后的值 是undefined;而fn调用是在fn被赋值为函数体之前， 此时fn的值是undefined，所以无法被调用。预解析案例1var num = 10;fun();function fun()&#123; console.log(num); var num = 20;&#125;相当于执行了以下操作 结果打印 undefinedvar num;function fun()&#123; var num; console.log(num); num = 20;&#125;num = 10;fun(); 预解析案例2var a = 18;f1();function f1()&#123; var b = 9; console.log(a); console.log(b); var a = &#x27;123&#x27;;&#125;相当于执行了以下操作 结果为 undefined 9var a;function f1()&#123; var b; var a; b = 9; console.log(a); console.log(b); a = &#x27;123&#x27;; &#125;a = 18;f1(); 预解析案例3f1();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125;相当于执行了以下操作 结果为 9 9 9 9 9 &quot;报错--a is not defined&quot;function f1() &#123; var a; a = b = c = 9; //相当于 var a = 9; b=9; c=9; b和c 直接赋值，没有var声明，当全局变量看。 // 差异：集体声明 var a = 9,b = 9, c = 9; console.log(a); console.log(b); console.log(c);&#125;f1();console.log(c);console.log(b);console.log(a); 对象对象的概念「对象」在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中常用方法来表示（常用动词） 「为什么需要对象」 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组，如果保存一个的完整信息呢？ 为了更好地存储一组数据，对象应用而生；对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。 123456var obj = &#123; &quot;name&quot;:&quot;fan&quot;, &quot;sex&quot;:&quot;male&quot;, &quot;age&quot;:18, &quot;height&quot;:155&#125; 创建对象的三种方式「1. 利用字面量创建对象」使用对象字面量创建对象： 就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示-键：相当于属性名-值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 123456789// star 就是创建的对象var star = &#123; name : &#x27;pink&#x27;, age : 18, sex : &#x27;男&#x27;, sayHi : function() &#123; alert(&#x27;大家好啊&#x27;); &#125;&#125;; 对象的使用 对象的属性：对象中存储具体数据的“键值对”中的键称为对象的属性，即对象中存储具体数据的项。 对象的方法：对象中存储函数的“键值对”中的“键”称为对象的方法，即对象中存储函数的项。 访问对象的属性：对象里面的属性调用：对象.属性名；对象里面属性的另一种调用方式：对象[‘属性名’],注意方括号里面的属性必须加上引号。 调用对象的方法:对象.方法名(); 变量、属性、函数、方法总结：①变量：单独声明赋值，单独存在②属性:对象里面的变量称为属性，不需要声明，用来描述该对象的特征。③方法：方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器。对象里面的函数称为方法，方法不需要声明，使用”对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。④函数:单独存在的，通过”函数名()”的方式就可以调用。 1234console.log(star.name) // 调用名字属性console.log(star[&#x27;name&#x27;]) // 调用名字属性star.sayHi(); 「2. 利用new Object创建对象」 创建空对象 12通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象var andy = new Object(); 给空对象添加属性和方法 1234567891011通过对象操作属性和方法的方式，来为对象增加属性和方法andy.name = &#x27;pink&#x27;;andy.age = 18; // andy.age = 19修改对象属性andy.sex = &#x27;男；// andy.phoneNum = 110 添加属性andy.sayHi = function() &#123; alert(&#x27;大家好&#x27;);&#125;obj.sayHi();调用对象的方法 //第二种写法 obj[&#x27;sayHi&#x27;]();// Object()第一个字母大写；//new Object() 需要new关键字，使用的格式:对象.属性 = 值 「3. 利用构造函数创建对象」 构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值,它总与new运算符一起使用，我们可以把对象中一些公共的属性和方法抽出来，然后封装到这个函数里面。 构造函数的封装格式： 123456function 构造函数名(形参1，形参2，形参3...) &#123; this.属性名1 = 参数1; this.属性名2 = 参数2; this.属性名3 = 参数3; this.方法名 = 函数体;&#125; 构造函数的调用格式 12345678910111213var obj = new 构造函数名(实参1，实参2，实参3);// 以上代码中，obj即接收到构造函数创建出来的对象。注意事项： 1.构造函数约定首字母大写 2.函数内的属性和方法前面需要添加this，表示当前对象的属性和方法 3.构造函数中不需要retrun返回结果 4.但我们创建对象的时候，必须用new 来调用构造函数 1.其他：构造函数如Stars(),抽取了对象的公共部分，封装到了函数里面，它 泛指某一大类(class) 2.创建对象，如new Stars();特指某一个，利用new关键字创建对象的过程 我们也称为对象实例化 new关键字的作用(面试题) 1.在构造函数代码开始执行之前，创建一个空对象； 2.修改this的指向，把this指向创建出来的空对象； 3.执行构造函数内的代码，给这个新对象添加属性和方法 4.在函数完成之后，返回这个创建出来的新对象(所以构造函数里面不需要return) 123456789101112// 工厂函数创建对象 这个把创建好的对象返回给函数调用处function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log(&#x27;Hello,everyBody&#x27;); &#125; return person; &#125;var p1 = createPerson(&#x27;张三&#x27;, 22, &#x27;actor&#x27;); 遍历对象123456789101112 for...in 语句用于对数组或者对象的属性进行循环操作。 其语法如下： for (变量 in 对象名字) &#123; // 在此执行代码 &#125; 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 for (var k in obj) &#123; console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值&#125; 内置对象「内置对象」JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象前面两种对象是JS基础内容，属于ECMAScript;第三个浏览器对象属于JS独有的，JS API讲解内置对象就是指js语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而非必要的功能(属性和方法),内置对象最大的优点就是帮助我们快速开发。 「查文档」学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习。MDN:https://developer.mozilla.org/zh-CN/ Math对象「Math对象」不是构造函数，它具有数学常数和函数的属性和方法，跟数学相关。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()&#x2F;Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 1234- 获取指定范围的随机整数 function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min; &#125; 日期对象 Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 使用Date实例化日期对象 获取当前时间必须实例化 获取指定时间的日期对象 123var now = new Date();var future = new Date(&#x27;2020/10/1&#x27;)// 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 续上 使用Date实例的方法和属性 getMonth()方法获取到的月份 + 1 &#x3D; 当月 1234567891011121314151617181920212223242526272829303132333435363738//参数常用写法 数字型或者字符串型 &#x27;2019-10-1 8:8:8&#x27;var date1 = new Date(2019,10,1);//日期格式化 // 格式化日期 年 月 日 var date = new Date(); console.log(date.getFullYear()); //返回当前日期的年 2020 console.log(date.getMonth() + 1); //月份 返回的月份小1个月，记得月份加1呦 console.log(date.getDate()); //返回的是 几号 console.log(date.getDay); //周一返回的是1 周六返回的是6 周日返回的是0 //我们写一个 2020年 9月 6日 星期日 var year = date.getFullYear(); var month = date.getMonth() + 1; var dates = date.getDate(); var day = date.getDay(); if (day == 0) &#123; day = &quot;星期日&quot;; &#125; console.log(&quot;今天是&quot; + year + &quot;年&quot; + month + &quot;月&quot; + dates + &quot;日&quot; + day); //格式化日期 时分秒 var date = new Date(); console.log(date.getHours()); //时 console.log(date.getMinutes()); //分 console.log(date.getSeconds()); // 秒 //封装一个函数返回当前的 时 分 秒 格式 08:08:08 function getTimer() &#123; var time = new Date(); var h = time.getHours(); var h = h &lt; 10 ? &quot;0&quot; + h : h; var m = time.getMinutes(); var m = m &lt; 10 ? &quot;0&quot; + m : m; var s = time.getSeconds(); var s = s &lt; 10 ? &quot;0&quot; + s : s; return h + &quot;:&quot; + h + &quot;:&quot; + s; &#125; console.log(getTimer()); 获取Date日期总的毫秒数(时间戳)基于1970年1月1日(世界标准世界)起的毫秒数 12345678910111213141516171819202122232425262728293031323334353637// 实例化Date对象var now = new Date();// 1. 用于获取对象的原始值console.log(now.valueOf()) console.log(now.getTime()) // 2. 简单写可以这么做 (最常用的)var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题var now = Date.now();倒计时案例 ：1. 输入的时间减去现在的时间就是剩余的时间，即倒计时。2.用时间戳来做，用户输入时间总的毫秒数减去现在时间的总的毫秒数， 得到的就是剩余时间的毫秒数3.把剩余时间总的毫秒数转换为天、时、分、秒 (时间戳转换时分秒) 转换公式如下： d = parseInt(总秒数/60/60/24) // 计算天数 h = parseInt(总秒数/60/60%24) // 计算小时 m = parseInt(总秒数/60%60); // 计算分钟 s = parseInt(总秒数%60); // 计算当前秒数 // 倒计时案例 封装函数实现 function countDown(time) &#123; var nowTime = +new Date(); // 返回的是当前时间总的毫秒数 var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数 var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 var d = parseInt(times / 60 / 60 / 24); // 天 d = d &lt; 10 ? &quot;0&quot; + d : d; var h = parseInt((times / 60 / 60) % 24); //时 h = h &lt; 10 ? &quot;0&quot; + h : h; var m = parseInt((times / 60) % 60); // 分 m = m &lt; 10 ? &quot;0&quot; + m : m; var s = parseInt(times % 60); // 当前的秒 s = s &lt; 10 ? &quot;0&quot; + s : s; return d + &quot;天&quot; + h + &quot;时&quot; + m + &quot;分&quot; + s + &quot;秒&quot;; &#125; console.log(countDown(&quot;2020-10-1 18:00:00&quot;)); var date = new Date(); console.log(date); 数组对象「创建数组的两种方式」 1. 字面量方式var arr = [1,&quot;test&quot;,true]; 2. 实例化数组对象 new Array()var arr = new Array(); 注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数 如果只传入一个参数(数字)，则参数规定了数组的长度。 如果传入了多个参数，则参数称为数组的元素。 「检测是否为数组」 1. instanceof 运算符 instanceof 可以判断一个对象是否是某个构造函数的实例 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // false 2. Array.isArray() Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 3. 注意 typeof用法 typeof 用于判断变量的类型 12var arr = [1, 23];console.log(typeof arr) // object 对象arr是构造函数的实例因此是对象数据类型 「添加删除数组元素的方法」 数组中有进行增加、删除元素的方法，部分方法如下表👇 12345678var arr = [1, 2, 3];console.log(arr.push(4, 5)); // 5 向数组末尾添加元素arr.pop(); //删除数组最后一个值并返回console.log(arr); // [1,2,3,4]// 向数组的开头添加元素并返回数组长度 console.log(arr.unshift(5, 6)); // 6 数组变为[5,6,1,2,3,4]console.log(arr.shift()); // 5 删除数组开头的元素并返回该值 「数组排序」 数组中有对数组本身排序的方法，部分方法如下表 方法名 说明 是否修改原数组 reverse() 颠倒数组中元素的顺序，无参数 该方法会改变原来的数组 返回新数组 sort() 对数组的元素进行排序 该方法会改变原来的数组 返回新数组 注意：sort方法需要传入参数(函数)来设置升序、降序排序 如果传入“function(a,b){ return a-b;}”，则为升序 如果传入“function(a,b){ return b-a;}”，则为降序 1234567// 踩坑 数组sort()排序(冒泡排序) return a - b 则升序// 写法固定 参考如下var arr1 = [13,4,77,1,7];arr1.sort(function(a,b)&#123; return a-b;&#125;);console.log(arr1); 「数组索引方法」 数组中有获取数组指定元素索引值的方法，部分方法如下表 12345var arr = [1, 2, 3, 4, 5, 4, 1, 2];// 查找元素2的索引console.log(arr.indexOf(2)); // 1// 查找元素1在数组中的最后一个索引console.log(arr.lastIndexOf(1)); // 6 「数组转换为字符串」 数组中有把数组转化为字符串的方法，部分方法如下表 注意：join方法如果不传入参数，则按照 “ , ”拼接元素 1234567var arr = [1, 2, 3, 4];var arr2 = arr;var str = arr.toString(); // 将数组转换为字符串console.log(str); // 1,2,3,4 var str2 = arr2.join(&quot;|&quot;);//按照键入字符将数组转换为字符串console.log(str2); 「其他方法」 12345678910111213var arr = [1, 2, 3, 4];var arr2 = [5, 6, 7, 8];var arr3 = arr.concat(arr2);console.log(arr3); // [1,2,3,4,5,6,7,8]// slice(begin,end) 是一种左闭右开区间 [1,3)// 从索引1出开始截取，到索引3之前var arr4 = arr.slice(1, 3);console.log(arr4); // [2,3]var arr5 = arr2.splice(0, 3);console.log(arr5); // [5,6,7]console.log(arr2); // [8] splice()会影响原数组 字符串对象「基本包装类型」为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 123// 下面代码有什么问题？var str = &#x27;andy&#x27;;console.log(str.length); // 4 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1. 生成临时变量，把简单类型包装为复杂数据类型var temp = new String(&#x27;andy&#x27;);// 2. 赋值给我们声明的字符变量str = temp;// 3. 销毁临时变量temp = null; 「字符串的不可变」 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。 由于字符串的不可变，在「大量拼接字符串」的时候会有效率问题 「根据字符返回位置」 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法： 123456var str = &quot;anndy&quot;;console.log(str.indexOf(&quot;d&quot;)); // 3//指定从索引号为4的地方开始查找字符&quot;d&quot;console.log(str.indexOf(&quot;d&quot;, 4)); // -1console.log(str.lastIndexOf(&quot;n&quot;)); // 2 案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数 先查找第一个o出现的位置 然后 只要indexOf 返回的结果不是 -1 就继续往后查找 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 12345678var str = &quot;oabcoefoxyozzopp&quot;;var index = str.indexOf(&quot;o&quot;);var num = 0;while (index !== -1) &#123; console.log(index); num++; index = str.indexOf(&quot;o&quot;, index + 1);&#125; 「根据位置返回字符」 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符： 1234567891011121314// 根据位置返回字符// 1. charAt(index) 根据位置返回字符var str = &#x27;andy&#x27;;console.log(str.charAt(3)); // y// 遍历所有的字符for (var i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i));&#125; // a n d y// 2. charCodeAt(index) //返回相应索引号的字符ASCII值 目的： 判断用户按下了那个键 console.log(str.charCodeAt(0)); // 97// 3. str[index] H5 新增的console.log(str[0]); // a 案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象中，对应的属性值是该字符出现的次数 12345678910111213141516171819202122232425var str = &quot;abcoefoxyozzopp&quot;;var o = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; var chars = str.charAt(i); // chars 是 字符串的每一个字符 if (o[chars]) &#123; // o[chars] 得到的是属性值 o[chars]++; &#125; else &#123; o[chars] = 1; &#125;&#125;console.log(o);// 2. 遍历对象var max = 0;var ch = &quot;&quot;;for (var k in o) &#123; // k 得到是 属性名 // o[k] 得到的是属性值 if (o[k] &gt; max) &#123; max = o[k]; ch = k; &#125;&#125;console.log(max);console.log(&quot;最多的字符是&quot; + ch); 「字符串操作方法」 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法： 123456789// 字符串操作方法// 1. concat(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;....)var str = &#x27;andy&#x27;;console.log(str.concat(&#x27;red&#x27;)); // andyred// 2. substr(&#x27;截取的起始位置&#x27;, &#x27;截取几个字符&#x27;);var str1 = &#x27;改革春风吹满地&#x27;;// 第一个2 是索引号的2 从第几个开始 第二个2 是取几个字符console.log(str1.substr(2, 2)); // 春风 replace()方法 replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下： 1字符串.replace(被替换的字符串， 要替换为的字符串)； split()方法 split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 其使用格式如下： 1234567891011121314151617字符串.split(&quot;分割字符&quot;) // 1. 替换字符 replace(&#x27;被替换的字符&#x27;, &#x27;替换为的字符&#x27;) 它只会替换第一个字符 var str = &quot;andyandy&quot;; console.log(str.replace(&quot;a&quot;, &quot;b&quot;)); // bndyandy // 有一个字符串 &#x27;abcoefoxyozzopp&#x27; 要求把里面所有的 o 替换为 * var str1 = &quot;abcoefoxyozzopp&quot;; while (str1.indexOf(&quot;o&quot;) !== -1) &#123; str1 = str1.replace(&quot;o&quot;, &quot;*&quot;); &#125; console.log(str1); // abc*ef*xy*zz*pp // 2. 字符转换为数组 split(&#x27;分隔符&#x27;) // 前面我们学过 join 把数组转换为字符串 var str2 = &quot;red, pink, blue&quot;; console.log(str2.split(&quot;,&quot;)); //[red,pink,blue] var str3 = &quot;red&amp;pink&amp;blue&quot;; console.log(str3.split(&quot;&amp;&quot;)); // [red,pink,blue] 简单数据类型和复杂数据类型「简单类型（基本数据类型、值类型）」：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null 「复杂数据类型（引用类型）」：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 「堆栈」 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 「简单类型传参」 函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 1234567function fn(a) &#123; a++; console.log(a); &#125;var x = 10;fn(x);console.log(x)； 运行结果如下 「复杂数据类型传参」 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 123456789101112function Person(name) &#123; this.name = name;&#125;function f1(x) &#123; // x = p console.log(x.name); // 2. 这个输出什么 ? x.name = &quot;张学友&quot;; console.log(x.name); // 3. 这个输出什么 ? &#125;var p = new Person(&quot;刘德华&quot;);console.log(p.name); // 1. 这个输出什么 ? f1(p);console.log(p.name); // 4. 这个输出什么 ? 运行结果如下：","tags":["前端笔记"],"categories":["前端笔记"]},{"title":"HTML与CSS进阶","path":"//","content":"HTML与CSS进阶本文主要介绍H5新增内容以及CSS3中的新特性。在H5方面主要介绍拓展了哪些内容，CSS3方面介绍动画及转换。 H5新增内容「1. 什么是HTML5」 定义：HTML5定义了HTML标准的最新版本，是对HTML的第五次重大修改，号称下一代的HTML。 两个概念： 是一个新版本的HTML语言，定义了新的标签、特性和属性 拥有一个强大的技术集，这些技术集是指：HTML5、CSS3、JavaScript,这也是广义上的HTML5。 「2. HTML5拓展了哪些内容」 语义化标签 本地存储 兼容特性 2D、3D 动画、过渡 CSS3特性 性能与集成 「3. HTML5的现状」 绝大多数新的属性，都已经被浏览器所支持，最新版本的浏览器已经开始陆续支持最新的特性，总的来说：HTML5已经是大势所趋。 HTML5新增标签「1. 什么是语义化」 语义化是指用HTML写出符合内容的结构化（内容语义化），选择合适的标签（代码语义化），能够便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 「2. 新增了哪些语义化标签」 header — 头部标签 nav — 导航标签 article — 内容标签 section — 块级标签 aside — 侧边栏标签 footer — 尾部标签 「3. 新增多媒体音频标签」 多媒体标签有两个，分别是音频 audio和视频video。 audio 标签说明 可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放， 但是：播放的格式是有限的。 audio支持的音频格式 audio 的参数 12345678910&lt;audio controls&gt; &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt; &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt; &lt;!-- 因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件 --&gt; &lt;source src=&quot;myAudio.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;myAudio.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;p&gt;Your browser doesn&#x27;t support HTML5 audio. Here is a &lt;a href=&quot;myAudio.mp4&quot;&gt;link to the audio&lt;/a&gt; instead.&lt;/p&gt;&lt;/audio&gt; 「4. 新增多媒体视频标签」 video视频标签目前支持三种格式 语法格式 1&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; video的参数 video代码演示 123456789&lt;body&gt; &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt; &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt; &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt; &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt;&lt;/body&gt; 多媒体标签总结 音频标签和视频标签使用基本一致 多媒体标签在不同浏览器下情况不同，存在兼容性问题 谷歌浏览器把音频和视频标签的自动播放都禁止了 谷歌浏览器中视频添加muted属性就可以自己播放了 注意：重点记住使用方法及自动播放即可，其他属性在使用时查找对应的手册 「5. 新增input标签」 「6. 新增表单属性」 CSS3新增「1. CSS3属性选择器」 123456789101112131415161718192021button &#123; cursor: pointer;&#125;button[disabled] &#123; cursor: default;&#125;input[type=search] &#123; color: skyblue;&#125;span[class^=black] &#123; color: lightgreen;&#125;span[class$=black] &#123; color: lightsalmon;&#125;span[class*=black] &#123; color: lightseagreen;&#125; 「2. 结构伪类选择器」 1234567891011ul li:first-child &#123; background-color: lightseagreen;&#125;ul li:last-child &#123; background-color: lightcoral;&#125;ul li:nth-child(3) &#123; background-color: aqua;&#125; **nth-child(n)**参数n详解 注意：本质上就是选中第几个子元素 n 可以是数字、关键字、公式 n 如果是数字，就是选中第几个 常见的关键字有 even 偶数、odd 奇数 常见的公式如下(如果 n 是公式，则从 0 开始计算) 但是第 0 个元素或者超出了元素的个数会被忽略 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; /* 偶数 */ ul li:nth-child(even) &#123; background-color: aquamarine; &#125; /* 奇数 */ ul li:nth-child(odd) &#123; background-color: blueviolet; &#125; /*n 是公式，从 0 开始计算 */ ul li:nth-child(n) &#123; background-color: lightcoral; &#125; /* 偶数 */ ul li:nth-child(2n) &#123; background-color: lightskyblue; &#125; /* 奇数 */ ul li:nth-child(2n + 1) &#123; background-color: lightsalmon; &#125; /* 选择第 0 5 10 15, 应该怎么选 */ ul li:nth-child(5n) &#123; background-color: orangered; &#125; /* n + 5 就是从第5个开始往后选择 */ ul li:nth-child(n + 5) &#123; background-color: peru; &#125; /* -n + 5 前五个 */ ul li:nth-child(-n + 5) &#123; background-color: tan; &#125;&lt;/style&gt; nth-child与nth-of-type区别 nth-child 选择父元素里面的第几个子元素，不管是第几个类型 nth-of-type 选择指定类型的元素 1234567891011121314151617&lt;style&gt; div :nth-child(1) &#123; background-color: lightblue; &#125; div :nth-child(2) &#123; background-color: lightpink; &#125; div span:nth-of-type(2) &#123; background-color: lightseagreen; &#125; div span:nth-of-type(3) &#123; background-color: #fff; &#125;&lt;/style&gt; 「3. 伪元素选择器」 伪元素选择器注意事项 before 和 after 必须有 content 属性 before 在内容前面，after 在内容后面 before 和 after 创建的是一个元素，但是属于行内元素 创建出来的元素在 Dom 中查找不到，所以称为伪元素 伪元素和标签选择器一样，权重为 1 123456789101112131415161718192021222324&lt;style&gt; div &#123; width: 100px; height: 100px; border: 1px solid lightcoral; &#125; div::after, div::before &#123; width: 20px; height: 50px; text-align: center; display: inline-block; &#125; div::after &#123; content: &#x27;德&#x27;; background-color: lightskyblue; &#125; div::before &#123; content: &#x27;道&#x27;; background-color: mediumaquamarine; &#125; &lt;/style&gt; 伪元素字体图标123456789101112131415p &#123; position: relative; width: 220px; height: 22px; border: 1px solid lightseagreen; margin: 60px;&#125;p::after &#123; content: &#x27;\\ea50&#x27;; font-family: &#x27;icomoon&#x27;; position: absolute; top: -1px; right: 10px;&#125; 「4. 2D 转换之translate」 2D转换 2D转换是改变标签在二维平面上的位置和形状 移动：translate 旋转：rotate 缩放：scale translate语法 x就是X轴上水平移动 y就是y轴上水平移动 123transform: translate(x, y)transform: translateX(n)transfrom: translateY(n) 重点知识点 2D的移动主要是指水平、垂直方向上的移动 translate最大的优点就是不影响其他元素的位置 translate中的100%单位，是相对于本身的宽度和高度来进行计算的 行内标签没有效果 12345678910111213141516171819202122div &#123; background-color: lightseagreen; width: 200px; height: 100px; /* 平移 */ /* 水平垂直移动 100px */ /* transform: translate(100px, 100px); */ /* 水平移动 100px */ /* transform: translate(100px, 0) */ /* 垂直移动 100px */ /* transform: translate(0, 100px) */ /* 水平移动 100px */ /* transform: translateX(100px); */ /* 垂直移动 100px */ transform: translateY(100px); /*百分比用法*/ transform: translateY(100%); &#125; 让一个盒子水平垂直居中123456789101112131415161718192021222324252627282930div &#123; position: relative; width: 500px; height: 500px; background-color: pink; /* 1. 我们tranlate里面的参数是可以用 % */ /* 2. 如果里面的参数是 % 移动的距离是 盒子自身的宽度或者高度来对比的 */ /* 这里的 50% 就是 50px 因为盒子的宽度是 100px */ /* transform: translateX(50%); */ &#125; p &#123; position: absolute; top: 50%; left: 50%; width: 200px; height: 200px; background-color: purple; /1.* margin-top: -100px; margin-left: -100px; */ /2.* translate(-50%, -50%) 盒子往上走自己高度的一半 */ transform: translate(-50%, -50%); &#125; span &#123; /* translate 对于行内元素是无效的 */ transform: translate(300px, 300px); &#125; 「5. 2D 转换之rotate」 rotate旋转 2D旋转指的是让元素在二维平面内顺时针或者逆时针旋转 1234/* 单位是：deg */img:hover &#123; transform: rotate(360deg)&#125; rotate语法 rotate 里面跟度数，单位是 deg 角度为正时，顺时针，角度为负时，逆时针 默认旋转的中心点是元素的中心点 设置元素旋转的中心的(transform-origin) 1transform-origin: x y; 注意 后面的参数 x 和 y 用空格隔开 x y 默认旋转的中心点是元素的中心(50% 50%),等价于center center 还可以给x y 设置像素或者方位名词(top、bottom、left、right、center) 「6. 2D 转换之scale」 scale的作用：用来控制元素的放大与缩小 1transform: scale(x, y) 知识要点： 注意，x与y之间用逗号进行分隔 transform: scale(1, 1): 宽高都放大一倍，相当于没有放大 transform: scale(2, 2): 宽和高都放大了二倍 transform: scale(2): 如果只写了一个参数，第二个参数就和第一个参数一致 transform:scale(0.5, 0.5): 缩小 scale 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子 12345678910div:hover &#123; /* 注意，数字是倍数的含义，所以不需要加单位 */ /* transform: scale(2, 2) */ /* 实现等比缩放，同时修改宽与高 */ /* transform: scale(2) */ /* 小于 1 就等于缩放*/ transform: scale(0.5, 0.5)&#125; 「7. 2D 转换综合写法以及顺序问题」 知识要点 同时使用多个转换，其格式为 transform: translate() rotate() scale() 顺序会影响到转换的效果(先旋转会改变坐标轴方向) 当我们同时有位置或者其他属性的时候，要将位移放到最前面 123div:hover &#123; transform: translate(200px, 0) rotate(360deg) scale(1.2)&#125; 动画(animation)「动画」是CSS3中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果。 「动画的使用」 先定义动画 再调用定义好的动画 123456789101112131415/*1. 定义动画*/@keyframes 动画名称 &#123; 0% &#123; width: 100px; &#125; 100% &#123; width: 200px &#125;&#125;div &#123; /* 调用动画 */ animation-name: 动画名称; /* 持续时间 */ animation-duration: 持续时间；&#125; 「动画序列」 0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列 在 @keyframs中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果 动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数 用百分比来规定变化发生的时间，或用 from 和 to，等同于 0% 和 100% 123456789101112131415161718&lt;style&gt; div &#123; width: 100px; height: 100px; background-color: aquamarine; animation-name: move; animation-duration: 0.5s; &#125; @keyframes move&#123; 0% &#123; transform: translate(0px) &#125; 100% &#123; transform: translate(500px, 0) &#125; &#125; &lt;/style&gt; 「动画常见属性」 123456789101112131415161718192021222324div &#123; width: 100px; height: 100px; background-color: aquamarine; /* 动画名称 */ animation-name: move; /* 动画花费时长 */ animation-duration: 2s; /* 动画速度曲线 */ animation-timing-function: ease-in-out; /* 动画等待多长时间执行 */ animation-delay: 2s; /* 规定动画播放次数 infinite: 无限循环 */ animation-iteration-count: infinite; /* 是否逆行播放 */ animation-direction: alternate; /* 动画结束之后的状态 */ animation-fill-mode: forwards;&#125;div:hover &#123; /* 规定动画是否暂停或者播放 */ animation-play-state: paused;&#125; 「动画简写方式」 12/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */animation: name duration timing-function delay iteration-count direction fill-mode 知识要点 简写属性里面不包含 animation-paly-state 暂停动画 animation-paly-state: paused; 经常和鼠标经过等其他配合使用 要想动画走回来，而不是直接调回来：animation-direction: alternate 盒子动画结束后，停在结束位置：animation-fill-mode: forwards 1animation: move 2s linear 1s infinite alternate forwards; 「速度曲线细节」 animation-timing-function: 规定动画的速度曲线，默认是ease 1234567891011121314151617181920/*打字机效果*/div &#123; width: 0px; height: 50px; line-height: 50px; white-space: nowrap; overflow: hidden; background-color: aquamarine; animation: move 4s steps(24) forwards;&#125;@keyframes move &#123; 0% &#123; width: 0px; &#125; 100% &#123; width: 480px; &#125;&#125; CSS 过渡transition通过过渡transition，可以让web前端开发人员不需要javascript就可以实现简单的动画交互效果。 深入理解CSS过渡transitionhttps://www.cnblogs.com/xiaohuochai/p/5347930.html 「定义」过渡transition是一个复合属性，包括transition-property、transition-duration、transition-timing-function、transition-delay这四个子属性。通过这四个子属性的配合来完成一个完整的过渡效果。 12345678910111213141516171819transition-property: 过渡属性(默认值为all)transition-duration: 过渡持续时间(默认值为0s)transiton-timing-function: 过渡函数(默认值为ease函数)transition-delay: 过渡延迟时间(默认值为0s).test&#123; height: 100px; width: 100px; background-color: pink; transition-duration: 3s;/* 以下三值为默认值，稍后会详细介绍 */ transition-property: all; transition-timing-function: ease; transition-delay: 0s;&#125; .test:hover&#123; width: 500px;&#125;~~~html&lt;div class=&quot;test&quot;&gt;&lt;/div&gt; 「复合属性」过渡transition的这四个子属性只有是必需且不能为0。其中，和都是时间。当两个时间同时出现时，第一个是，第二个是；当只有一个时间时，它是，而为默认值0s 注意: transition的这四个子属性之间不能用逗号隔开，只能用空格隔开。因为逗号隔开的代表不同的属性(transition属性支持多值，多值部分稍后介绍)；而空格隔开的代表不同属性的四个关于过渡的子属性。 1234567891011.test&#123; height: 100px; width: 100px; background-color: pink;/*代表持续时间为2s，延迟时间为默认值0s*/ transition；2s;&#125; .test:hover&#123; width: 500px;&#125;&lt;div class=&quot;test&quot;&gt;&lt;/div&gt; 延迟时间delay 案例 1234567891011.test&#123; height: 100px; width: 100px; background-color: pink; /*代表持续时间为1s，延迟时间为2s*/ transition: 1s 2s;&#125; .test:hover&#123; width: 500px;&#125;&lt;div class=&quot;test&quot;&gt;&lt;/div&gt; 「过渡属性」 值: none | all | [,] 初始值: all 应用于: 所有元素 继承性: 无 123none: 没有指定任何样式all: 默认值，表示指定元素所有支持transition-property属性的样式&lt;transition-property&gt;: 可过渡的样式，可用逗号分开写多个样式 「过渡持续时间」 值: [,]* 初始值: 0s 应用于: 所有元素 继承性: 无 [注意]该属性不能为负值 [注意]若该属性为0s则为默认值，若为0则为无效值。所以必须带单位 [注意]该值为单值时，即所有过渡属性都对应同样时间；该值为多值时，过渡属性按照顺序对应持续时间 12/*DEMO中的过渡属性值*/transition-property: width,background; 「过渡时间函数」 过渡时间函数用于定义元素过渡属性随时间变化的过渡速度变化效果 值: [,]* 初始值: ease 应用于: 所有元素 继承性: 无 「取值」 过渡时间函数共三种取值，分别是关键字、steps函数和bezier函数 「关键字」其实是bezier函数或steps函数的特殊值 12345ease: 开始和结束慢，中间快。linear: 匀速。ease-in: 开始慢。ease-out: 结束慢。ease-in-out: 和ease类似，但比ease幅度大。 3D转换认识3D转换「3D的特点」近大远小，物体和面遮挡不可见 「三维坐标系」 x 轴：水平向右 – 注意：x 轴右边是正值，左边是负值 y 轴：垂直向下 – 注意：y 轴下面是正值，上面是负值 z 轴：垂直屏幕 – 注意：往外边的是正值，往里面的是负值 3D转换1. 3D 转换知识要点 3D 位移：translate3d(x, y, z) 3D 旋转：rotate3d(x, y, z) 透视 ：perspctive 3D呈现 transfrom-style 2. 3D 移动translate3d 3D 移动就是在 2D 移动的基础上多加了一个可以移动的方向，就是 z 轴方向 transform: translateX(100px)：仅仅是在 x 轴上移动 transform: translateY(100px)：仅仅是在 y 轴上移动 transform: translateZ(100px)：仅仅是在 z 轴上移动 transform: translate3d(x, y, z)：其中x、y、z 分别指要移动的轴的方向的距离 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 123transform: translate3d(100px, 100px, 100px)/* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */transform: translate3d(100px, 100px, 0) 透视perspective 知识点讲解 如果想要网页产生 3D 效果需要透视(理解成 3D 物体投影的 2D 平面上) 实际上模仿人类的视觉位置，可视为安排一只眼睛去看 透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是像素 知识要点 透视需要写在被视察元素的父盒子上面 注意下方图片 d：就是视距，视距就是指人的眼睛到屏幕的距离 z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大 代码演示 12345body &#123; /*透视需要写在被视察元素的父盒子上面 */ perspective: 1000px;&#125;translateZ与perspective的区别 perspecitve 给父级进行设置视距的，translateZ 给 子元素进行设置不同的大小 3D 旋转rotateX3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转 语法： transform: rotateX(45deg) – 沿着 x 轴正方向旋转 45 度 transform: rotateY(45deg) – 沿着 y 轴正方向旋转 45 度 transform: rotateZ(45deg) – 沿着 z 轴正方向旋转 45 度 transform: rotate3d(x, y, z, 45deg) – 沿着自定义轴旋转 45 deg 为角度 左手法则： 左手的手拇指指向 x 轴的正方向 其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向 1234567891011121314div &#123; /*透视写在被视察元素的父盒子上面 */ perspective: 300px;&#125;/*被观察元素*/img &#123; display: block; margin: 100px auto; transition: all 1s;&#125;img:hover &#123; transform: rotateX(-45deg)&#125; 3D 旋转rotateY 左手法则： 左手的拇指指向 y 轴的正方向 其余的手指弯曲方向就是该元素沿着 y 轴旋转的方向(正值) 12345678910111213div &#123; perspective: 500px;&#125;img &#123; display: block; margin: 100px auto; transition: all 1s;&#125;img:hover &#123; transform: rotateY(180deg)&#125; 3D 旋转rotateZ12345678910111213div &#123; perspective: 500px;&#125;img &#123; display: block; margin: 100px auto; transition: all 1s;&#125;img:hover &#123; transform: rotateZ(180deg)&#125; 「rotate3d」 transform: rotate3d(x, y, z, deg) – 沿着自定义轴旋转 deg 为角度 x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度 transform: rotate3d(1, 1, 0, 180deg) – 沿着对角线旋转 45deg transform: rotate3d(1, 0, 0, 180deg) – 沿着 x 轴旋转 45deg 12345678910111213div &#123; perspective: 500px;&#125;img &#123; display: block; margin: 100px auto; transition: all 1s;&#125;img:hover &#123; transform: rotate3d(1, 1, 0, 180deg)&#125; 3D呈现transform-style 控制子元素是否开启三维立体环境 transform-style: flat 代表子元素不开启 3D 立体空间，默认的 transform-style: preserve-3d 子元素开启立体空间 代码写给父级，但是影响的是子盒子 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body &#123; perspective: 500px; &#125; .box &#123; position: relative; width: 200px; height: 200px; margin: 100px auto; transition: all 2s; /* 让子元素保持3d立体空间环境 */ transform-style: preserve-3d; &#125; .box:hover &#123; transform: rotateY(60deg); &#125; .box div &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: pink; &#125; .box div:last-child &#123; background-color: purple; transform: rotateX(60deg); &#125;&lt;/style&gt;","tags":["前端经验"],"categories":["前端经验"]},{"title":"VueX-数组对象的双向数据绑定","path":"//","content":"VueX-数组对象的双向数据绑定Vuex不允许在组件内部直接修改共享数据，需要在mutations中修改数据，所以涉及到双向绑定不能使用v-model 💡 需求需要增加，删除数据，并且可以修改每一项的done 步骤 在state中提供一个对象数组 123456789101112131415161718state: &#123; list: [&#123; id: 1, name: &#x27;吃吃&#x27;, done: false &#125;, &#123; id: 2, name: &#x27;喝喝&#x27;, done: false &#125;, &#123; id: 3, name: &#x27;学vue⭐&#x27;, done: true &#125; ] &#125;, 使用辅助函数mapState , 将数据展示在页面上，在App.vue中 12345678910111213141516171819202122&lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &lt;span&gt; id: &#123;&#123; item.id &#125;&#125; &lt;/span&gt; &lt;span&gt; name: &#123;&#123; item.name &#125;&#125; &lt;/span&gt; &lt;span&gt; done: &#123;&#123; item.done &#125;&#125; &lt;/span&gt; 修改done: &lt;input type=&quot;text&quot; :value=&quot;item.done&quot; /&gt; &lt;hr /&gt;&lt;/div&gt;......import &#123; mapState &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapState(&#x27;data&#x27;, [&#x27;list&#x27;]) &#125;,&#125;123456789101112131415161718192021 在data.js中的 mutations中添加 增加 删除 的函数 12345678mutations: &#123; add(state) &#123; state.list.push(&#123; id: 4, name: &#x27;睡觉&#x27;, done: true &#125;) &#125;, remove(state) &#123; state.list.pop() &#125; &#125;, 使用辅助函数mapMutations ， 将两个方法展示到页面上 123456789101112131415&lt;button @click=&quot;add&quot;&gt;增加数据&lt;/button&gt;&lt;button @click=&quot;remove&quot;&gt;删除数据&lt;/button&gt;......import &#123; mapState, mapMutations &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapState(&#x27;data&#x27;, [&#x27;list&#x27;]) &#125;, methods: &#123; ...mapMutations(&#x27;data&#x27;, [&#x27;add&#x27;]), ...mapMutations(&#x27;data&#x27;, [&#x27;remove&#x27;]),&#125; 5.修改done属性 添加输入事件 给input框添加一个输入事件changeDone,并传入index实参。 给input添加一个id，（注意需要动态设置，每一项的id都不相同，以便根据不同的id获取到不同的value值） 1234567修改done: &lt;input type=&quot;text&quot; :value=&quot;item.done&quot; @input=&quot;changeDone(index)&quot; :id=&quot;index&quot; /&gt; 在methods里面添加changeDone()函数 根据输入框的不同id获取到数组不同项的value 触发mutations，注意模块化需要添加模块名 data 传递多个参数（注意只能传递一个参数，如果需要传递多个 需要以数组或者对象的形式传递） &#123;index，val&#125; 1234changeDone(index) &#123; let val = document.getElementById(index).value this.$store.commit(&#x27;data/changeDone&#x27;, &#123; index, val &#125;) &#125; 在data.js的mutations中添加修改输入框值（done）的方法 根据下标修改don的值 12345mutations: &#123;\tchangeDone(state, &#123; index, val &#125;) &#123; state.list[index].done = val &#125;&#125; 效果展示","tags":["Vue框架"],"categories":["Vue框架"]},{"title":"「学习笔记」CSS基础","path":"//","content":"「学习笔记」CSS基础CSS构造块「1. HTML的局限性」 HTML满足不了设计者的需求，可以将网页结构与样式相分离，这样就可以在不更改网页结构的前提下，更换网站的样式。 操作html属性不方便 HTML里面添加样式带来的是无尽的臃肿和繁琐 「2. CSS网页的美容师」 让我们的网页更加丰富多彩，布局更加灵活自如。 CSS最大的贡献：让HTML从样式中脱离，实现了HTML专注去做结构呈现，样式交给CSS 「3. CSS」CSS(Cascading Style Sheets)通常称为CSS样式表或层叠样式表(级联样式表)。 作用 主要用于设置HTML页面中的文本内容(字体、大小、对齐方式等)\\图片的外形(宽高、边框样式、边距等)以及版面的布局和外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、样式、背景的控制及整体排版等，而且可以针对不同的浏览器设置不同的样式。 「4. CSS注释」 1/* 这是注释 */ 引入CSS样式表「1.行内式(内联样式)」 通过标签的style属性来设置元素的样式 style其实就是标签的属性 样式属性和值中间是: 多组属性值直接用;隔开 只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余。 **缺点:**没有实现样式和结构相分离。 123&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;例如：&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; 「2.内部样式表(内嵌样式表)」 也称为内嵌式，将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。 style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。 type&#x3D;”text&#x2F;css” 在html5中可以省略。 只能控制当前的页面 **缺点:**没有彻底分离结构与样式 123456789&lt;head&gt;&lt;style type=&quot;text/CSS&quot;&gt; 选择器（选择的标签） &#123; 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; &#125;&lt;/style&gt;&lt;/head&gt; 「3.外部样式表(外链式)」 也称链入式，是将所有的样式放在一个或多个以.css为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中。 rel:定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 href:定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 1&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 「4.团队约定-代码风格」 12345678910111213141516171819/*1.紧凑格式 (Compact)*/h3 &#123; color: deeppink;font-size: 20px;&#125;// 2.一种是展开格式（推荐）h3 &#123; color: deeppink; font-size: 20px; &#125;/* 团队约定-代码大小写*//* 样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。*//* 推荐 */h3&#123; color: pink;&#125; /* 不推荐 */H3&#123; COLOR: PINK;&#125; CSS基础选择器CSS选择器作用找到指定的HTML页面元素，选择标签。 CSS基础选择器「1. 标签选择器」 标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。 作用：可以把某一类标签全部选择出来。 优点：快速为网页中同类型的标签统一样式 缺点：不能设计差异化样式。 1标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 「2. 类选择器」 类选择器使用”.”(英文点号)进行标识，后面紧跟类名。 语法：类名选择器 123456.类名 &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;&lt;p class=&#x27;类名&#x27;&gt;&lt;/p&gt; 优点：可以为元素对象定义单独或相同的样式。可以选择一个或者多个标签。 注意：类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的) 长名称或词组可以使用中横线来为选择器命名。 不要纯数字、中文等命名， 尽量使用英文字母来表示。 多类名选择器：各个类名中间用空格隔开。 「3. id选择器」id选择器使用#进行标识，后面紧跟id名 元素的id值是唯一的，只能对应于文档中某一个具体的元素。 12#id名 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;&lt;p id=&quot;id名&quot;&gt;&lt;/p&gt; 「4. 通配符选择器」 通配符选择器用*号表示，* 就是选择所有的标签。它是所有选择器中作用范围最广的，能匹配页面中所有的元素。 注意：会匹配页面所有的元素，降低页面响应速度，不建议随便使用 1* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 「5. 基础选择器总结」 选择器 作用 缺点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如p 不能差异化选择 较多 p { color：red;} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav { color: red; } id选择器 一次只能选择器1个标签 只能使用一次 不推荐使用 #nav {color: red;} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 不推荐使用 * {color: red;} 「6. 团队约定-选择器」 尽量少用通配符选择器 *。 尽量少用ID选择器 不使用无具体语义定义的标签选择器。 123456789/* 推荐 */.jdc &#123;&#125;li &#123;&#125;p&#123;&#125;/* 不推荐 */*&#123;&#125;#jdc &#123;&#125;div&#123;&#125; 因为div 没有语义，我们尽量少用 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的 「1. 后代选择器」又称为包含选择器 用来选择元素或元素组的子孙后代 其写法就是把外层标签写在前面，内层标签写在后面，中间用「空格」分隔，先写父亲爷爷，再写儿子孙子。 子孙后代都可以这么选择。或者说，它能选择任何包含在内 的标签。 123父级 子级&#123;属性:属性值;属性:属性值;&#125;.class h3 &#123;color:red;font-size:16px;&#125; 当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。或者说，它能选择任何包含在内的标签。 「2. 子元素选择器」 子元素选择器只能选择作为某元素子元素(亲儿子)的元素。 其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接 这里的子,指的是亲儿子。不包含孙子 重孙子之类。 1.class&gt;h3 &#123;color:red;font-size:14px;&#125; 「3. 交集选择器」 其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 123交集选择器是并且的意思,即...又...的意思比如： p.one 选择的是： 类名为 .one 的段落标签。 /*用的相对来说比较少，不建议使用。*/ 「4. 并集选择器」如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。并集选择器（CSS选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。 任何形式的选择器（包括标签选择器、class类选择器 id选择器等），都可以作为并集选择器的一部分。 并集选择器通常用于集体声明 ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为和的意思。 123456比如 .one, p , #test &#123;color: #F00;&#125; 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 「5. 链接伪类选择器」 用于向某些选择器添加特殊的效果。写的时候，他们的顺序尽量不要颠倒,按照lvha的顺序。否则可能引起错误。 链接伪类，是利用交集选择器. a:link 未访问的链接 a:visited 已访问的链接 a:hover 鼠标移动到链接上 a:active 选定的链接 实际工作中，很少写全四个状态，一般写法如下：123456789a &#123; /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; text-decoration: none; /* 清除链接默认的下划线*/&#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; 「6. 复合选择器总结」 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择元素后代 是选择所有的子孙后代 较多 符号是空格 .nav a 子代选择器 选择 最近一级元素 只选亲儿子 较少 符号是&gt; .nav&gt;p 交集选择器 选择两个标签交集的部分 既是 又是 较少 没有符号 p.one 并集选择器 选择某些相同样式的选择器 可以用于集体声明 较多 符号是逗号 .nav, .header 链接伪类选择器 给链接更改状态 较多 重点记住 a{} 和 a:hover 实际开发的写法 CSS字体样式font字体「1. font-size」 font-size属性用于设置字号(字体大小) 谷歌浏览器默认的文字大小为16px 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小。 1p &#123; font-size:20px; &#125; 单位 相对长度单位、绝对长度单位 「2. font-family」 font-family属性用于设置哪一种字体。 1p &#123; font-family:&quot;微软雅黑&quot;;&#125; 指定多个字体，如果浏览器不支持第一个字体就会尝试下一个直到找到合适的字体，如果都没有，以电脑默认字体为准。 1p &#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125; CSS Unicode字体 在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。 xp 系统不支持 类似微软雅黑的中文。 解决方案：英文来替代。比如font-family:&quot;Microsoft Yahei&quot;。在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。 1font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;; 表示设置字体为“微软雅黑”。 「3. font-weight」 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold (数字表示粗细用的多) 「4. font-weight」 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式。 「5. font:综合设置字体样式」 1选择器 &#123; font: font-style font-weight font-size/line-height font-family;&#125; 注意：使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开 其中不需要设置的属性可以省略(取默认值),但必须保留font-size和font-family属性，否则font属性将不起作用。 「6. font总结」 属性 表示 注意点 font-size 字号 我们通常用的单位是px 像素，一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font-weight 字体粗细 记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位 font-style 字体样式 记住倾斜是 italic 不倾斜 是 normal 工作中我们最常用 normal font 字体连写 1. 字体连写是有顺序的 不能随意换位置 2. 其中字号 和 字体 必须同时出现 CSS外观属性「1. color」 color属性用于定义文本的颜色其取值方式有以下3种： 实际工作中，用16进制的写法是最多的，且我们更喜欢简写方式比如#f0代表红色。 表示表示 属性值 预定义的颜色值 red，green，blue，pink 十六进制 #FF0000，#FF6600，#29D794 RGB代码 rgb(255,0,0)或rgb(100%,0%,0%) 「2.text-align」 text-align属性用于设置文本内容的水平对齐方式，相当于html中的align对齐属性。 注意：是让盒子里面的文本内容水平居中， 而不是让盒子居中对齐 其可用属性值如下： 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 「3. line-height」line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。 line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 12一般情况下，行距比字号大7--8像素左右就可以了。line-height: 24px; 行高测量行高测量方法： 行高测量方法行高我们利用最多的一个地方是：可以让单行文本在盒子中垂直居中对齐。 文字的行高等于盒子的高度。行高 &#x3D; 上距离 + 内容高度 + 下距离上距离和下距离总是相等的，因此文字看上去是垂直居中的。 行高与高度的三种关系 如果 行高 等 高度 文字会 垂直居中 如果行高 大于 高度 文字会 偏下 如果行高小于高度 文字会 偏上 12345/*line-height 要设置在font属性下面，否则无效，例如：*/height: 80px;text-align: center;font: normal bold 30px &quot;宋体&quot;;line-height: 80px; 可以使用display:flex;布局方式让文字水平垂直居中 123display: flex;align-items: center; /* 侧轴对齐方式*/justify-content: center; /* 主轴对齐方式 */ 「4. text-indent」 text-indent属性用于设置首行文本的缩进 其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值。 建议使用em作为设置单位。 1em 就是一个字的宽度。如果是汉字的段落，1em 就是一个汉字的宽度 123456p &#123; /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em; &#125; 「5. text-decoration」文本的装饰 text-decoration,通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本下的一条线。（不常用） 「6. CSS外观属性总结」 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进2个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none 标签显示模式(display)标签显示模式是标签以什么方式进行显示。HTML标签一般分为块标签和行内标签两种类型，它们也称为块元素和行内元素。 标签显示模式转换 display 块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块：display: inline-block; 「1. 块级元素(block-level)」 常见的块元素有~、、、、、等，其中标签是最典型的块元素。 块级元素的特点 独占一行 高度，宽度，外边距以及内边距都可以控制。 宽度默认是容器(父级宽度)的100% 是一个容器及盒子，里面可以放行内或者块级元素 注意：只有文字才能组成段落，因此p标签里面不能放块级元素，特别是p不能放div。同理，还有h1~h6，dt,它们都是文字类块级标签，里面不能放其他块级元素。 「2. 行内元素(inline-level)」 有的地方也称为内联元素 常见的行内元素有、、、、、、、、、等，其中标签最典型的行内元素。 行内元素的特点 相邻行内元素在一行上，一行可以显示多个。 高度、宽度直接设置是无效的。 默认高度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意 链接里面不能再放链接 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。 「3. 行内块元素(inline-block)」 在行内元素中有几个特殊的标签——、、，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。 行内块元素的特点 和相邻行内元素(行内块)在一行上，但是之间会有空白风险。一行可以显示多个 默认宽度就是它本身内容的宽度。 高度，行高，外边距以及内边距都可以控制。 三种模式总结 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度和高度 它本身内容的宽度 CSS背景(background)「1. 背景颜色」 1background-color: 颜色值; 默认的值是 transparent 透明的 「2. 背景图片(image)」 1234语法：background-image : none | url (url) ;例如:background-image: url(images/1.png); 「3. 背景平铺（repeat）」 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数 作用 repeat 背景图像在纵向和横向上平铺（默认的） no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 「4. 背景位置(position)」 12background-position : length || lengthbackground-position : position || position 参数 值 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center | bottom | left | center | right 方位名词 注意： 必须先指定background-image属性 position 后面是x坐标和y坐标。可以使用方位名词或者 精确单位。 如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。 如果position 后面是精确坐标， 那么第一个，肯定是 x 第二个一定是y 如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中 如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标 背景简写： background：属性的值的书写顺序官方没有强制的标准。为了可读性，建议如下写： background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 12/* 有背景图片背景颜色可以不用写*/background: transparent url(image.jpg) repeat-y scroll center top ; 「5. 背景半透明(CSS3)」 12background: rgba(0, 0, 0, 0.3);background: rgba(0, 0, 0, .3); 等同于background-color: rgba(0, 0, 0, .3) 最后一个参数是alpha 透明度 取值范围 0~1之间 我们习惯把0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3); 注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响 低于IE 9的版本不支持 盒子半透明 opacity 设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度 1opacity: .2; 「6. 背景总结」 属性 作用 值 background-color 背景颜色 预定义的颜色值&#x2F;十六进制&#x2F;RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y background-position 背景位置 length&#x2F;position 分别是x 和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法 background-attachment 背景固定还是滚动 scroll&#x2F;fixed 背景简写 更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 他们没有顺序 背景透明 让盒子半透明 background: rgba(0,0,0,0.3); 后面必须是 4个值 CSS三大特性「1. CSS 层叠性」 -概念： 所谓层叠性是指多种CSS样式的叠加 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 -原则： 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠。 「2. CSS 继承性」 -概念： 子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。 -注意： 恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。 子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性） 「3. CSS 优先级(CSS特殊性)」 -概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时， 选择器相同，则执行层叠性 选择器不同，就会出现优先级的问题。 -权重计算公式： 标签选择器 计算权重公式 继承或者 * 0,0,0,0 每个元素（标签选择器） 0,0,0,1 每个类，伪类 0,0,1,0 每个ID 0,1,0,0 每个行内样式 style&#x3D;”” 1,0,0,0 每个!important 最重要的 ∞ 无穷大 值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） div { color: pink !important; } -权重叠加： 1234div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 -继承的权重是0： 我们修改样式，一定要看该标签有没有被选中 如果选中了，那么以上面的公式来计权重。谁大听谁的。 如果没有选中，那么权重是0，因为继承的权重为0. 盒子模型css学习三大重点： css 盒子模型 、 浮动 、 定位 网页布局的本质 首先利用CSS设置好盒子的大小，然后摆放盒子的位置。 最后把网页元素比如文字图片等等，放入盒子里面。 1. 盒子模型(Box Model) 盒子模型就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 盒子模型由元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。 盒子里面的文字和图片等元素是 内容区域 盒子的厚度 我们称为为盒子的边框 盒子内容与边框的距离是内边距 盒子与盒子之间的距离是外边距 W3c标准盒子模型 标准 w3c 盒子模型的范围包括 margin、border、padding、content 当设置为box-sizing: content-box;时，将采用标准模式解析计算，也是默认模式； 1内盒尺寸计算(元素实际大小) 宽度：Element Height &#x3D; content height + padding + border （Height为内容高度） 高度：Element Width &#x3D; content width + padding + border （Width为内容宽度） 盒子的实际大小：内容的宽度和高度 + 内边距 + 边框 IE盒子模型 IE 盒子模型的 content 部分包含了 border 和 pading 当设置为box-sizing: border-box时，将采用怪异模式解析计算； 2. 盒子边框(border) 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 边框的样式： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 1234边框综合设置border : border-width || border-style || border-color border: 1px solid red; 没有顺序要求 盒子边框写法总结表： 很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 表格的细线边框： 通过表格的cellspacing=&quot;0&quot;,将单元格与单元格之间的距离设置为0， 但是两个单元格之间的边框会出现重叠，从而使边框变粗 通过css属性：table{ border-collapse:collapse; } collapse 单词是合并的意思,border-collapse: collapse;表示相邻边框合并在一起。 1234567891011121314&lt;style&gt; table &#123; width: 500px; height: 300px; border: 1px solid red; &#125; td &#123; border: 1px solid red; text-align: center; &#125; table, td &#123; border-collapse: collapse; /*合并相邻边框*/ &#125;&lt;/style&gt; 2. 内边距(padding)padding属性用于设置内边距。是指边框与内容之间的距离。 设置 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 padding简写 值的个数 表达意思 1个值 padding：上下左右内边距; 2个值 padding: 上下内边距 左右内边距 ； 3个值 padding：上内边距 左右内边距 下内边距； 4个值 padding: 上内边距 右内边距 下内边距 左内边距 ； 当我们给盒子指定padding值之后， 发生了2件事情： 内容和边框 有了距离，添加了内边距。 盒子会变大 解决措施：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小。 padding不影响盒子大小情况：👉如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。 3. 外边距（margin）margin属性用于设置外边距。margin就是控制盒子和盒子之间的距离 设置 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin值的简写 （复合写法）代表意思 跟 padding 完全相同。 块级盒子水平居中 盒子必须指定宽度（width） 然后就给左右的外边距都设置为auto 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header &#123; width: 960px; margin: 0 auto;&#125; 常见的写法，以下下三种都可以👇👇。 margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 文字居中和盒子居中区别👇👇 盒子内的文字水平居中是 text-align: center; 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右margin 改为 auto 插入图片和背景图片区别👇👇 插入图片我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin 背景图片我们一般用于小图标背景或者超大背景图片、背景图片，移动位置只能通过 background-position 清除元素的默认内外边距👇👇 行内元素为了照顾兼容性,尽量只设置左右内外边距，不要设置上下内外边距。 1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125; 4.外边距合并使用margin定义块元素的「垂直外边距」时，可能会出现外边距的合并。 (1). 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom 下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和 「取两个值中的较大者」这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 「解决方案：尽量给只给一个盒子添加margin值」。 (2). 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框 父元素的上外边距会与子元素的上外边距发生合并 合并后的外边距为两者中的较大者 「解决方案：」 可以为父元素定义上边框。 可以为父元素定义上内边距 可以为父元素添加overflow: hidden。 还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。 盒子模型布局稳定性优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin） 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 5. CSS3 新增1234567圆角边框：border-radius:length;border-top-left-radius 定义了左上角的弧度border-top-right-radius 定义了右上角的弧度border-bottom-right-radius 定义了右下角的弧度border-bottom-left-radius 定义了左下角的弧度 其中每一个值可以为 数值或百分比的形式。 技巧：让一个正方形 变成圆圈 1border-radius: 50%; 如果要在四个角上一一指定，可以使用以下规则👇👇： 1border-radius: 左上角 右上角 右下角 左下角; 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 一个值：四个圆角值相同 12盒子阴影(box-shadow)：box-shadow: offset-x offset-y [blur [spread]] [color] [inset] 值 描述 offset-x 阴影的水平偏移量。正数向右偏移，负数向左偏移。 offset-y 阴影的垂直偏移量。正数向下偏移，负数向上偏移。 blur 可选。阴影模糊距离，不能取负数。 spread 可选。阴影大小 color 可选。阴影的颜色 inset 可选。表示添加内阴影，默认为外阴影 12345678div &#123; width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4); &#125; 浮动浮动「1. CSS布局的三种机制」 网页布局的核心——就是用CSS来摆放盒子。 CSS 提供了3种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中： A. 普通流（标准流） 块级元素会独占一行，从上向下顺序排列； 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行； 常用元素：span、a、i、em等 B. 浮动 让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。 C. 定位 将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。 「2. 什么是浮动」元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制,不占位置，脱标 移动到指定位置。 作用 让多个盒子(div)水平排列成一行，使得浮动称为布局的重要手段。 可以实现盒子的左右对齐等等。 浮动最早是用来控制图片，实现文字环绕图片效果。 float属性会改变元素的display属性，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。生成的块级框和我们前面的行内块极其相似。 语法1选择器 &#123; float: 属性值; &#125; 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。**建议:**如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题 浮动(float)小结 特点 说明 浮 加了浮动的盒子「是浮起来」的，漂浮在其他标准流盒子的上面。 漏 加了浮动的盒子「是不占位置的」，它原来的位置「漏给了标准流的盒子」。 特 「特别注意」：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙 清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。总结： 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 准确地说，并不是清除浮动，而是清除浮动后造成的影响 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 清除浮动的方法1选择器 &#123; clear: 属性值; &#125; clear 清除 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 实际工作中,几乎只用clear: both 1).额外标签法(隔墙法) 是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 ，或则其他标签br等亦可。 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差。 2).父级添加overflow属性方法 1可以给父级添加： overflow为 hidden| auto| scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 3).使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了 12345678910111213.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125; /* IE6、7 专有 */.clearfix &#123; *zoom: 1;&#125; 优点：符合闭合浮动思想 结构语义化正确 缺点：由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 4).使用双伪元素清除浮动 12345678910111213.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 清除浮动总结1什么时候用清除浮动呢？ 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 CSS属性书写顺序建议遵循以下顺序： 布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background 文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word 其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient … 1234567891011121314151617.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, &#x27;Helvetica Neue&#x27;, Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; 定位(position)「1. 定位详解」 将盒子「定」在某一个「位」置 自由的漂浮在其他盒子(包括标准流和浮动)的上面。 所以，我们脑海应该有三种布局机制的上下顺序👇👇标准流在最底层 (海底) ——- 浮动 的盒子 在 中间层 (海面) ——- 定位的盒子 在 最上层 （天空） 定位是用来布局的，它有两部分组成：定位 &#x3D; 定位模式 + 边偏移在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的「边偏移」：（方位名词） 边偏移属性 示例 描述 top top: 80px 「顶端」偏移量，定义元素相对于其父元素「上边线的距离」。 bottom bottom: 80px 「底部」偏移量，定义元素相对于其父元素「下边线的距离」。 left left: 80px 「左侧」偏移量，定义元素相对于其父元素「左边线的距离」。 right right: 80px 「右侧」偏移量，定义元素相对于其父元素「右边线的距离」 「2. 定位模式(position)」在 CSS 中，通过 position 属性定义元素的「定位模式」，语法如下： 1选择器 &#123; position: 属性值; &#125; 值 语义 static 「静态」定位 relative 「相对」定位 absolute 「绝对」定位 fixed 「固定」定位 「3. 静态定位(static)」 静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。 静态定位 按照标准流特性摆放位置。它没有边偏移。 静态定位在布局时几乎不用 「4. 相对定位(relative)」 相对定位是元素相对于它原来在标准流中的位置来说的。 相对于自己原来在标准流中位置来移动的 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 「5. 绝对定位(absolute)」 绝对定位是元素以带有定位的父级元素来移动位置 完全脱表–完全不占位置； 父元素没有定位，则以浏览器为准定位(Document文档)。 父元素有定位 定位口诀–子绝父相「6. 固定定位(fixed)」 固定定位是绝对定位的一种特殊形式; 完全脱标–完全不占位置； 只认浏览器的可视窗口–浏览器可视窗口+边偏移属性来设置元素的位置 跟父元素没有任何关系；单独使用 不随滚动条滚动 定位(position)的扩展绝对定位的盒子居中 绝对定位&#x2F;固定定位的盒子不能通过设置margin: auto设置水平居中 在使用绝对定位时要向实现水平居中，可以按照下面的方法： left : 50%:让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;让盒子向左移动自身宽度的一半。 同理垂直居中。 堆叠顺序（z-index）在使用「定位」布局时，可能会「出现盒子重叠的情况」。 加了定位的盒子，默认「后来者居上」， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以「调整盒子的堆叠顺序」。如下图所示： z-index的特性如下: 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位 z-index只能用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 定位改变display属性前面提过， display 是 显示模式， 可以通过以下方式改变显示模式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了「浮动」、「固定定位」和「绝对定位」，不用转换，就可以给这个盒子直接设置宽度和高度等。 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 注意： 边偏移 需要和 定位模式 联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 CSS高级技巧元素的显示与隐藏 **目的:**让一个元素在页面中消失或者显示出来 **场景:**类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 1.1 display 显示（重点）display设置或检索对象是否显示或如何显示。 display: none 隐藏对象 特点：隐藏之后，不再保留位置。 display: block 除了转换为块级元素之外，同时还有显示元素的意思。 实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 1.2 visibility 可见性设置或检索是否显示对象 123visibility：visible ; 对象可视visibility：hidden; 对象隐藏 特点：隐藏之后，继续保留原有位置。 1.3 overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 1.4 显示与隐藏总结 属性 区别 用途 display 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 CSS用户界面样式所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓等。 防止表单域拖拽 2.1 鼠标样式设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 1234567&lt;ul&gt; &lt;li style=&quot;cursor:default&quot;&gt;我是小白&lt;/li&gt; &lt;li style=&quot;cursor:pointer&quot;&gt;我是小手&lt;/li&gt; &lt;li style=&quot;cursor:move&quot;&gt;我是移动&lt;/li&gt; &lt;li style=&quot;cursor:text&quot;&gt;我是文本&lt;/li&gt; &lt;li style=&quot;cursor:not-allowed&quot;&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 2.2 轮廓线 outline是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。最直接的写法是 ： outline: 0; 或者 outline: none; 2.3 防止拖拽文本域resize 1&lt;textarea style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt; 2.4 用户界面样式总结 属性 用途 用途 鼠标样式 更改鼠标样式cursor 样式很多，重点记住 pointer 轮廓线 表单默认outline outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用 防止拖拽 主要针对文本域resize 防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none vertical-align 垂直对齐 有宽度的块级元素居中对齐，是margin: 0 auto; 让文字居中对齐，是 text-align: center; vertical-align 垂直对齐，它只针对于「行内元素」或者「行内块元素」 12设置或检索对象内容的垂直对其方式。vertical-align : baseline |top |middle |bottom 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于「行内元素」或者「行内块元素」， 特别是行内块元素， 通常用来控制图片&#x2F;表单与文字的对齐。 3.1 图片、表单和文字对齐我们可以通过vertical-align 控制图片和文字的垂直关系了。默认的图片会和文字基线对齐。 3.2 去除图片底侧空白缝隙原因：图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。 就是图片底侧会有一个空白缝隙。 解决方法： 给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字省略号显示4.1 white-space white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 123white-space:normal ；默认处理方式white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。 4.2 text-overflow 文字溢出 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 123text-overflow : clip ；不显示省略标记（...），而是简单的裁切 text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...） 「注意」： 一定要首先强制一行内显示，再次和overflow属性 搭配使用 4.3 总结三步曲123456/*1. 先强制一行内显示文本*/ white-space: nowrap;/*2. 超出的部分隐藏*/ overflow: hidden;/*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; CSS精灵技术（sprite)CSS精灵技术（也称CSS Sprites、CSS雪碧）。 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。 为什么需要精灵技术：为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。 5.1 精灵技术讲解CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。 这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。 我们需要使用CSS的: background-image、 background-repeat background-position属性进行背景定位， 其中最关键的是使用background-position 属性精确地定位。 5.2 精灵技术使用的核心总结首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。 精确测量，每个小背景图片的大小和 位置。 给盒子指定小背景图片时， 背景定位基本都是 负值。 滑动门 6.1 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。最常见于各种导航栏的滑动门。 6.2 核心技术核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 123456789101112131415161718192021222324252627282930313233343536&lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt;* &#123; padding:0; margin:0; &#125; body&#123; background: url(images/wx.jpg) repeat-x; &#125; .father &#123; padding-top:20px; &#125; li &#123; padding-left: 16px; height: 33px; float: left; line-height: 33px; margin:0 10px; background: url(./images/to.png) no-repeat left ; &#125; a &#123; padding-right: 16px; height: 33px; display: inline-block; color:#fff; background: url(./images/to.png) no-repeat right ; text-decoration: none; &#125; li:hover, li:hover a &#123; background-image:url(./images/ao.png); &#125; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 CSS 三角形12345678910div &#123; width: 0; height: 0; line-height:0； font-size: 0; border-top: 10px solid red; border-right: 10px solid green; border-bottom: 10px solid blue; border-left: 10px solid #000; &#125; 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0;","tags":["前端笔记"],"categories":["前端笔记"]},{"title":"「学习笔记」HTML基础","path":"//","content":"「学习笔记」HTML基础一、认识WEB「网页」主要是由文字、图像和超链接等元素构成，当然除了这些元素，网页中还可以包括音频、视频以及Flash等。 「浏览器」是网页显示、运行的平台。 「浏览器内核」(排版引擎、解释引擎、渲染引擎) 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。 浏览器 内核 备注 IE Trident IE、猎豹安全、360极速浏览器、百度浏览器 firefox Gecko 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 Safari webkit 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕在厕所里面了。 chrome Chromium&#x2F;Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 Opera blink 现在跟随chrome用blink内核。 Web标准「构成」👉 结构标准，表现标准和行为标准 结构标准用于对网页元素进行整理和分类(HTML) 表现标准用于设置网页元素的版式、颜色、大小等外观属性(CSS) 行为标准用于对网页模型的定义及交互的编写(JavaScript) 「Web标准的优点」👇 易于维护：只需更改CSS文件，就可以改变整站的样式 页面响应快：HTML文档体积变小，响应时间短 可访问性：语义化的HTML（结构和表现相分离的HTML）编写的网页文件，更容易被屏幕阅读器识别 设备兼容性：不同的样式表可以让网页在不同的设备上呈现不同的样式 搜索引擎：语义化的HTML能更容易被搜索引擎解析，提升排名 二、HTML初识HTML初识「HTML」(Hyper Text Markup Language):超文本标记语言「所谓超文本，有2层含义：」 因为它可以加入图片、声音、动画、多媒体等内容（超越文本限制 ） 不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）。 「HTML骨架格式」 1234567891011&lt;!-- 页面中最大的标签 根标签 --&gt;&lt;html&gt; &lt;!-- 头部标签 --&gt; &lt;head&gt; &lt;!-- 标题标签 --&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;!-- 文档的主体 --&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 「团队约定大小写」 HTML标签名、类名、标签属性和大部分属性值统一用小写 「HTML元素标签分类」 常规元素(双标签) 空元素(单标签) 12345常规元素(双标签)&lt;标签名&gt; 内容 &lt;/标签名&gt; 比如&lt;body&gt;我是文字&lt;/body&gt;空元素(单标签)&lt;标签名 /&gt; 比如 &lt;br /&gt;或&lt;br&gt; 「HTML标签关系」 嵌套关系父子级包含关系 并列关系兄弟级并列关系 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位（一个tab是4个空格）。如果是并列关系，最好上下对齐。 文档类型「文档类型」用来说明你用的XHTML或者HTML是什么版本。&lt;!DOCTYPE html告诉浏览器按照HTML5标准解析页面。 页面语言langlang指定该html标签内容所用的语言 12&lt;html lang=&quot;en&quot;&gt; en 定义语言为英语 zh-CN定义语言为中文 「lang的作用」 根据根据lang属性来设定不同语言的css样式，或者字体 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别 字符集「字符集」(Character set)是多个字符的集合,计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 UTF-8是目前最常用的字符集编码方式 让 html 文件是以 UTF-8 编码保存的， 浏览器根据编码去解码对应的html内容。 1&lt;meta charset=&quot;UTF-8&quot; /&gt; 「meta viewport的用法」 通常viewport是指视窗、视口。浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域。在移动端和pc端视口是不同的，pc端的视口是浏览器窗口区域，而在移动端有三个不同的视口概念：布局视口、视觉视口、理想视口 meta有两个属性name 和 http-equiv name属性的取值 keywords(关键字) 告诉搜索引擎，该网页的关键字 description(网站内容描述) 用于告诉搜索引擎，你网站的主要内容。 viewport(移动端的窗口) robots(定义搜索引擎爬虫的索引方式) robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引 author(作者) generator(网页制作软件） copyright(版权) http-equiv有以下参数 http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容 content-Type 设定网页字符集(Html4用法，不推荐) Expires(期限) ,可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 Pragma(cache模式),是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出 Refresh(刷新),自动刷新并指向新页面。 cache-control（请求和响应遵循的缓存机制） 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; HTML标签的语义化 方便代码的阅读和维护，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 「拓展」 标签：规定页面上所有链接的默认 URL 和设置整体链接的打开状态 1234567&lt;head&gt; &lt;base href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt; &lt;base target=&quot;_self&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;测试&lt;/a&gt; 跳转到 百度&lt;/body&gt; HTML常用标签常用标签「1. 排版标签」主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签h(h1~h6) 段落标签p,可以把 HTML 文档分割为若干段落 水平线标签hr 换行标签br div和span标签:是没有语义的,是我们网页布局最主要的2个盒子。 「2. 排版标签」 b和strong 文字以粗体显示 i和em 文字以斜体显示 s和del 文字以加删除线显示 u和ins 文字以加下划线显示 「3. 标签属性(行内式)」 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。 12&lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;&lt;手机 颜色=&quot;红色&quot; 大小=&quot;5寸&quot;&gt; &lt;/手机&gt; 「4. 图像标签img」 注意： 标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 采取 键值对 的格式 key&#x3D;”value” 的格式 1&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot; /&gt; 「5. 链接标签(重点)」 123&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;target=&quot;_self&quot; 默认窗口弹出方式target=&quot;_blank&quot; 新窗口弹出 属性 作用 href 用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 src 和 href 的区别 一句话概括:src 是引入资源的 href 是跳转url的 src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。 src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。如果我们在文档中添加那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。 注意： 外部链接 需要添加 http:&#x2F;&#x2F; www.baidu.com 内部链接 直接链接内部页面名称即可 比如 &lt; a href&#x3D;”index.html”&gt; 首页 如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href&#x3D;”#”)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位：通过创建锚点链接，用户能够快速定位到目标内容。 123451. 使用相应的id名标注跳转目标的位置。 (找目标) &lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt; 2. 使用&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;创建链接文本（被点击的） &lt;a href=&quot;#two&quot;&gt; 「6. 注释标签」 123&lt;!-- 注释语句 --&gt; 快捷键是： ctrl + / 或者 ctrl +shift + / 团队约定： 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 「7. 路径」 「8. 其他知识」 预格式化文本pre标签元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 特殊字符什么是XHTML XHTML 指「可扩展超文本标签语言」（EXtensible HyperText Markup Language）。 XHTML 的目标是取代 HTML。 XHTML 与 HTML 4.01 几乎是相同的。 XHTML 是更严格更纯净的 HTML 版本。 XHTML 是作为一种 XML 应用被重新定义的 HTML,是严格版本的HTML。例如它要求标签必须小写，标签必须被正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。 XHTML 是一个 W3C 标准。 写HTML代码时应注意什么？ 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for来让说明文本和相对应的input关联起来。 表格「1. 表格」 现在还是较为常用的一种标签，但不是用来布局，常见显示、展示表格式数据。因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候表格运用是否熟练就显得很重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理。 「2. 创建表格」 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; table、tr、td，他们是创建表格的基本标签，缺一不可 table用于定义一个表格标签。 tr标签 用于定义表格中的行，必须嵌套在 table标签中。 td 用于定义表格中的单元格，必须嵌套在标签中。 字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。td像一个容器，可以容纳所有的元素。 表头单元格标签th:一般表头单元格位于表格的第一行或第一列，并且文本加粗居中,只需用表头标签替代相应的单元格标签 td&gt;&lt;&#x2F;td 即可。 表格标题caption通常这个标题会被居中且显示于表格之上。caption 标签必须紧随 table 标签之后。这个标签只存在 表格里面才有意义。你是风儿我是沙 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; 「3. 表格属性」 三参为0，平时开发的我们这三个参数 border cellpadding cellspacing 为 0 「4. 合并单元格」,合并的顺序我们按照 先上 后下 先左 后右 的顺序 ,合并完之后需要删除多余的单元格。 跨行合并：rowspan&#x3D;”合并单元格的个数” 跨列合并：colspan&#x3D;”合并单元格的个数” 「5. 总结表格」 标签名 定义 说明 表格标签 就是一个四方的盒子 表格行标签 行标签要再table标签内部才有意义 单元格标签 单元格标签是个容器级元素，可以放任何东西 表头单元格标签 它还是一个单元格，但是里面的文字会居中且加粗 表格标题标签 表格的标题，跟着表格一起走，和表格居中对齐 clospan 和 rowspan 合并属性 用来合并单元格的 「6. 表格划分结构」 对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead,tbody,tfoot来标注， 这样更好的分清表格结构。 注意： thead&gt;&lt;&#x2F;thead：用于定义表格的头部。用来放标题之类的东西。 内部必须拥有 标签！\\2. tbody&gt;&lt;&#x2F;tbody：用于定义表格的主体。放数据本体 。\\3. tfoot&gt;&lt;&#x2F;tfoot放表格的脚注之类。\\4. 以上标签都是放到table标签中。 列表「列表ul」容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表。 列表最大的特点就是整齐 、整洁、 有序，跟表格类似，但是它可组合自由度会更高。 「1. 无序列表 ul」 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 「2. 有序列表 ol」 标签中的type属性值为排序的序列号，不添加type属性时，有序列表默认从数字1开始排序。 常用的type属性值分别为是1，a，A，i，I 中的reversed属性能够让有序列表中的序列倒序排列。 中的start属性值为3，有序列表中的第一个序列号将从3开始排列。 12345&lt;ol type=&quot;A&quot;&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表二&lt;/li&gt; &lt;li&gt;列表三&lt;/li&gt;&lt;/ol&gt; 「2. 自定义列表 dl」 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 表单在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。表单目的是为了收集用户信息。 表单控件： 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。提示信息： 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。表单域： 它相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 「1. input 控件」 1&lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&gt; input 输入的意思 &lt;input &#x2F;标签为单标签 type属性设置不同的属性值用来指定不同的控件类型 除了type属性还有别的属性 常用属性： 12用户名: &lt;input type=&quot;text&quot; /&gt; 密 码：&lt;input type=&quot;password&quot; /&gt; value属性 value 默认的文本值。有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。 1用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt; name属性 name表单的名字， 这样，后台可以通过这个name属性找到这个表单。 页面中的表单很多，name主要作用就是用于区别不同的表单。 name属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以多个选其中的一个啦 name属性，我们现在用的较少，但是，当我们学ajax 和后台的时候，是必须的。 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女 checked属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。 123性 别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 input 属性小结 属性 说明 作用 type 表单类型 用来指定不同的控件类型 value 表单值 表单里面默认显示的文本 name 表单名字 页面中的表单很多，name主要作用就是用于区别不同的表单。 checked 默认选中 表示那个单选或者复选按钮一开始就被选中了 「2. label标签」 label 标签为 input 元素定义标注（标签）。 label标签主要目的是为了提高用户体验。为用户提高最优秀的服务。 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。 如何绑定元素呢 第一种用法就是用label标签直接包含input表单， 适合单个表单选择 第二种用法 for 属性规定 label 与哪个表单元素绑定(通过id)。 12345678第一种&lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt; &lt;/label&gt;第二种&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot;&gt; 「3. textarea控件(文本域)」 通过textarea控件可以轻松地创建多行文本输入框. cols&#x3D;”每行中的字符数” rows&#x3D;”显示的行数” 我们实际开发不用 123&lt;textarea &gt; 文本内容&lt;/textarea&gt; 文本框和文本域区别 表单 名称 区别 默认值显示 用于场景 input type&#x3D;”text” 文本框 只能显示一行文本 单标签，通过value显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 「4. select下拉列表」 如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表。 在option 中定义selected &#x3D;” selected “时，当前项即为默认选中项。 我们实际开发会用的比较少 1234567&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; form表单域 收集的用户信息怎么传递给服务器？ 通过form表单域 目的： 在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件&lt;/form&gt; 常用属性： 每个表单都应该有自己表单域。后面学 ajax 后台交互的时候，必须需要form表单域。 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get&#x2F;post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 GET 和 POST 的区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求大小一般是(1024字节)，http协议并没有限制，而与服务器，操作系统有关，POST理论上来说没有大小限制，http协议规范也没有进行大小限制，但实际上post所能传递的数据量根据取决于服务器的设置和内存大小。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 团队约定： 元素属性值使用双引号语法 元素属性值可以写上的都写上 123推荐&lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; /&gt; 从输入url到页面展示发生了什么(面试) 作者：Twinkle_链接：https://juejin.im/post/6869279683230629896来源：掘金 浏览器的多进程架构从浏览器输入 URL 到页面渲染的整个过程都是由 浏览器架构中的各个进程之间的配合完成。 浏览器主进程: 管理子进程、提供服务功能 渲染进程：将HTML、CSS、JS渲染成界面，js引擎v8和排版引擎Blink就在上面，他会为每一个tab页面创建一个渲染进程 GPU进程：本来是负责处理3Dcss的，后来慢慢的UI界面也交给GPU来绘制 网络进程：就是负责网络请求，网络资源加载的进程 插件进程：负责插件的运行的，因为插件很容易崩溃，把它放到独立的进程里不要让它影响别人 浏览器的多进程架构 从用户输入信息到页面展示的不同阶段，是不同的进程在发挥作用，示意图如下：从图中可以看出，整个过程是需要各个进程之间相互配合完成的，过程大致可以描述为： 用户输入url,处理输入信息，主进程开始导航，交给网络进程干活 网络进程发起网络请求，其中有可能会发生重定向 服务器响应URL之后，主进程就要通知渲染进程，你要开始干活了 渲染进程准备好了，要想渲染进程提交数据，这个时间叫做提交文档 渲染进程接受到数据，完成页面渲染。 具体过程 输入url 用户输入url，处理输入信息： 如果为非url结构的字符串，交给浏览器默认引擎去搜索改字符串； 若为url结构的字符串，浏览器主进程会交给 网络进程 ,开始干活。 2.1 查找浏览器缓存 网络进程会先看看是否存在本地缓存，如果有就直接返回资源给浏览器进程，无则下一步 DNS-&gt; IP -&gt; TCP 2.2 DNS解析 网络进程拿到url后，先会进行DNS域名解析得到IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。 2.2 建立TCP连接，三次握手 接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，向服务器发送请求。 服务器响应服务器收到请求信息后，会根据请求信息生成响应行、响应头、响应体，并发给网络进程。网络进程接受了响应信息之后，就开始解析响应头的内容。 网络进程解析响应行和响应头信息的过程： 3.1 重定向 如果响应行状态码为301（永久重定向）和302（临时），那么说明需要重定向到其他url。这时候网络进程会从响应头中的Location字段里读取重定向的地址，并重新发起网络请求。 3.2 响应数据处理 导航会通过请求头的Content-type字段判断响应体数据的类型。浏览器通过这个来决定如何显示响应体的内容。比如：若为application&#x2F;octet-stream，则会按照下载类型来处理这个请求，导航结束。若为text&#x2F;html，这就告诉浏览器服务器返回的是html格式，浏览器会通知渲染进程，你要干活了。 准备渲染进程 默认情况，每个页面一个渲染进程。但若处于同一站点（同根域名+协议），那么渲染进程就会复用。 5.提交文档 渲染进程准备好后，浏览器进程发出“提交文档的消息”，渲染进程接受了消息之后，会跟网络进程简历传输数据的管道。 等数据传输完成了，渲染进程会告诉浏览器进程，确认文档提交，这时候浏览器会更新页面，安全状态，url，前进后退的历史。 到这里导航结束，进入渲染阶段。 注：当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为百度首页的页面。因为需要等待提交文档阶段，页面内容才会被替换。 前端HTML基础面试题iframe有哪些缺点？iframe是一种框架，也是一种很常见的网页嵌入方式。 「iframe的优点」 iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 「iframe的缺点」 会产生很多页面，不容易管理。 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。 很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。 label的作用是什么？是怎么用的？例子1: 点击” 用户名:” 就可以定位光标到输入框 form&gt;&lt;label for=&quot;myid &quot;&gt; 用户名:/label&gt;&lt;input type=&quot;text&quot; id=&quot;myid&quot; /&gt;/form&gt; 例子2: 点击” 用户名:” 或按键alt+1, 都可以定位光标到输入框 form&gt; label for=&quot;myid&quot; accesskey=&quot;1&quot;&gt; 用户名:&lt;/label input type=&quot;text&quot; id=&quot;myid&quot; tabindex=&quot;1&quot; /&gt;&lt;/form for 属性功能：表示Label 标签要绑定的HTML 元素，你点击这个标签的时候，所绑定的元素将获取焦点。 acesskey 属性 功能：表示访问Label 标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。 局限性：accessKey 属性所设置的快捷键不能与浏览器的快捷键冲突，否则将优先激活浏览器的快捷键。 HTML5的form如何关闭自动完成功能？HTML的输入框可以拥有自动完成的功能，当你往输入框输入内容的时候，浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面，这样就不用全部输入进去了，直接选择列表中的项目就可以了。 但有时候我们希望关闭输入框的自动完成功能，例如当用户输入内容的时候，我们希望使用AJAX技术从数据库搜索并列举而不是在用户的历史记录中搜索。 关闭输入框的自动完成功能有3种方法： 在IE的Internet选项菜单里的内容–自动完成里面设置 设置form的autocomplete为”on”或者”off”来开启或者关闭自动完成功能 设置输入框的autocomplete为”on”或者”off”来开启或者关闭该输入框的自动完成功能 将 HTML5 看作成开放的网络平台「什么是 HTML5 的基本构件（building block）？」 语义 - 提供更准确地描述内容。 连接 - 提供新的方式与服务器通信。 离线和存储 - 允许网页在本地存储数据并有效地离线运行。 多媒体 - 在 Open Web 中，视频和音频被视为一等公民（first-class citizens）。 2D&#x2F;3D 图形和特效 - 提供更多种演示选项。 性能和集成 - 提供更快的访问速度和性能更好的计算机硬件。 设备访问 - 允许使用各种输入、输出设备。 外观 - 可以开发丰富的主题。 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在浏览器的html头部加上manifest属性，如果是第一次访问浏览器会根据manifest的内容进行下载存储离线内容，如果已经访问过则从离线存储中进行加载，然后在比对服务器如果有新内容在更新离线存储 离线的情况下，浏览器就直接使用离线存储的资源。 浏览器的渲染过程？1、将获取的html解析成dom树 2、处理css，构成层叠样式表模型CSSOM 3、将dom树和CSSOM合并为渲染树 4、根据CSSOM将渲染树的节点布局计算 5、将渲染树节点样式绘制到页面上 // 注意 在渲染的过程中是自上而下渲染， js会阻塞页面的渲染，优先等js执行完成 如果在渲染的过程中改变了样式，会造成回流需要重新渲染 link和@import的区别？1、从属关系区别： link属于html标签，而@import是css提供的。 2、加载顺序区别： 页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载。 3、兼容性区别： import只在IE5以上才能识别，而link是html标签，无兼容问题。 4、dom可操作性区别： 可以通过JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式 5、权重区别： 如果已经存在相同样式，@import引入的这个样式将被该 CSS 文件本身的样式层叠掉，表现出link方式的样式权重高于@import的权重这样的直观效果。（简而言之，link和@import，谁写在后面，谁的样式就被应用，后面的样式覆盖前面的样式。） src与href的区别？1、href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 2、src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。","tags":["前端笔记"],"categories":["前端笔记"]},{"title":"HTML基础","path":"//","content":"字符集12345678MARKDOWNutf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312；gb2312简单中文，包括6763个汉字；BIG5繁体中文，港澳台等用；GBK包含全部中文字符，是GB2312的扩展，加入对繁体字的支持，兼容GB2312；UTF-8则包含全世界所有国家需要用到的字符；记住一点：以后我们统统使用UTF-8字符集，这样就避免出现字符集不统一而引起乱码的情况了。 标题标签12345678单词缩写：head 头部、标题为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即：h1 h2 h3 h4 h5 h6标题标签语义：作为标题使用，并且依据重要性递减!---### 注意：h1标签因为重要，尽量少用，一般h1都是给logo使用。 段落标签123456MARKDOWN单词缩写：paragraph 段落在网页中要把文字有条理的显示出来，离不来段落标签，就如同写文章需要首行缩进、需要分段一样，整个网页也可以分为若干个段落。段落标签：&lt;p&gt;文本内容&lt;/p&gt;是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签1234PLAINTEXT单词缩写：horizontal横线在网页中常常看到一些水平线讲段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单的通过标记来完成，其基本语法格式如下：hello!&lt;hr&gt;张三 换行标签1234PLAINTEXT在HTML中一个段落的文字会从左到右依次排列，直到浏览器窗口的右端，然后自行换行。如果希望某段文本强制换行显示，就需要使用换行标签。&lt;br&gt;这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签1234PLAINTEXTdiv span是没有语义的，是我们网页布局主要的两个盒子；div就是分割、分区的意思，其实有很多div来组合网页；span跨度、跨距、范围。 文本格式化标签123456PLAINTEXT在网页中有时需要为文字设置粗体、斜体或者下划线效果，这时候就需要用到HTML中的文本格式化标记，使文字以特殊的方式显示。粗体：&lt;strong&gt;、&lt;b&gt;已废弃，不建议使用斜体：&lt;em&gt;、&lt;i&gt;已废弃，不建议使用删除线：&lt;del&gt;、&lt;s&gt;已废弃，不建议使用下划线：&lt;ins&gt;、&lt;u&gt;已废弃，不建议使用 图像标签1234PLAINTEXT图像标签：img该语法中src属性用于指定图像文件的路径和文件名，它是img标签的必要属性。&lt;img src=&quot;图像URL&quot;&gt; 手册文档 字符实体 HTML ISO-8859-1 HTML进阶meta1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; link标签 因为页面切换主题网速慢会出现空白区域影响体验，就了解相关优化方法，下面做个整理 rel preload优先加载（as必填的吧） prefetch预加载（空闲时加载） dns-prefetch使浏览器主动去执行域名解析的功能。 preconnect浏览器要建立一个连接，一般需要经过DNS查找，TCP三次握手和TLS协商（如果是https的话），这些过程都是需要相当的耗时的，所以preconnet，就是一项使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了。 prerender不仅会加载资源，还会解执行页面，进行预渲染，但是这都是根据浏览器自身进行判断。 123456&lt;!-- 浏览器加载资源顺序如下 --&gt;&lt;link rel=&quot;prefetch&quot; as=&quot;video&quot; href=&quot;4.html&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;2.css&quot;&gt;&lt;script src=&quot;3.html&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;5.html&quot;&gt;&lt;link rel=&quot;preload&quot; as=&quot;style&quot; href=&quot;1.css&quot;&gt; as audioAudio file. documentAn HTML document intended to be embedded inside a &lt;frame&gt; or &lt;iframe&gt;. embedA resource to be embedded inside an &lt;embed&gt; element. fetchResource to be accessed by a fetch or XHR request, such as an ArrayBuffer or JSON file. fontFont file. imageImage file. objectA resource to be embedded inside an &lt;embed&gt; element. scriptJavaScript file. styleStylesheet. trackWebVTT file. workerA JavaScript web worker or shared worker. videoVideo file. h5链接唤起App12345678&lt;a href=&quot;mqq://&quot;&gt;qq&lt;/a&gt;&lt;a href=&quot;mqqapi://forward/url?souce=baidu.com&quot;&gt;qq内置浏览器&lt;/a&gt;&lt;a href=&quot;weixin://&quot;&gt;微信&lt;/a&gt;&lt;a href=&quot;TencentWeibo://&quot;&gt;腾讯微博&lt;/a&gt;&lt;a href=&quot;taobao://&quot;&gt;淘宝&lt;/a&gt;&lt;a href=&quot;alipay://&quot;&gt;支付宝&lt;/a&gt;&lt;a href=&quot;sinaweibo://&quot;&gt;新浪微博&lt;/a&gt;&lt;a href=&quot;snssdk1128://&quot;&gt;抖音&lt;/a&gt; 微信相关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475微信 weixin://!发起群聊 weixin://dl/groupchat通讯录!添加朋友 weixin://dl/add上报日志 weixin://dl/log故障修复 搜索 :recover新的朋友 weixin://dl/recommendation群聊 weixin://dl/groups标签 weixin://dl/tags公众号 weixin://dl/officialaccounts发现朋友圈 weixin://dl/moments扫一扫 weixin://dl/scan购物（京东） weixin://dl/shopping游戏 weixin://dl/games我个人信息 weixin://dl/profile名字 weixin://dl/setname我的二维码 weixin://dl/myQRcode我的地址 weixin://dl/myaddress相册 weixin://dl/posts收藏 weixin://dl/favorites优惠券 weixin://dl/card表情 weixin://dl/stickers设置 weixin://dl/settingsQQ 号 weixin://dl/bindqq手机号 weixin://dl/bindmobile邮箱地址 weixin://dl/bindemail帐号保护 weixin://dl/protection新消息通知 weixin://dl/notifications通讯录黑名单 weixin://dl/blacklist不让他（她）看我的朋友圈 weixin://dl/hidemoments不看他（她）的朋友圈 weixin://dl/blockmoments通用 weixin://dl/general多语言 weixin://dl/languages字体大小 weixin://dl/textsize我的表情 weixin://dl/stickersetting朋友圈小视频 weixin://dl/sight功能 weixin://dl/features通讯录同步助手 weixin://dl/securityassistant群发助手 weixin://dl/broadcastmessage聊天记录迁移 weixin://dl/chathistory清理微信存储空间 weixin://dl/clear帮助与反馈意见反馈 weixin://dl/help 或 weixin://dl/feedback关于微信 weixin://dl/about其他隐藏入口 参数不明 第三方 Webview 接口 weixin://dl/businessWebview/link/隐藏入口 参数不明 第三方游戏库接口 weixin://dl/businessGame/library/隐藏入口 参数不明 第三方游戏详情接口 weixin://dl/businessGame/detail/隐藏入口 参数不明 第三方支付接口 weixin://dl/businessPay/隐藏入口 参数不明 第三方临时会话接口 weixin://dl/business/tempsession/ 或 weixin://dl/businessTempSession/未知weixin://dl/chatweixin://dl/designeremojiweixin://dl/login/common_viewweixin://dl/login/phone_viewweixin://dl/personalemoticonweixin://private/weixin://private/setresult/weixin://dl/updatenewestversionweixin://dl/wechatoutweixin://dl/wechatoutcoupon隐藏入口第三方公众号临时会话接口weixin://dl/business参数 ticketweixin://dl/business/?ticket= 缓存功能好像被废弃掉了，慎用！ 1&lt;html lang=&quot;zh-CN&quot; manifest=&quot;/manifest/main.appcache&quot;&gt; HTML5中audio与video：音频HTML5 中提供的音频 API 标签为 &lt;audio&gt;&lt;/audio&gt;，使用示例如： 1&lt;audio src=&quot;野狼disco.m4a&quot; controls&gt;&lt;/audio&gt; 兼容写法 1234567&lt;audio controls&gt; &lt;source src=&quot;resource/audio/OUTPUT.mp3&quot; type=&#x27;audio/mpeg&#x27;&gt; &lt;source src=&quot;resource/audio/OUTPUT.aac&quot; type=&#x27;audio/aac; codecs=&quot;aac&quot;&#x27;&gt; &lt;source src=&quot;resource/audio/OUTPUT.ogg&quot; type=&#x27;audio/ogg; codecs=&quot;vorbis&quot;&#x27;&gt; 您的浏览器不支持，&lt;a href=&quot;resource/audio/OUTPUT.mp3&quot;&gt;请下载&lt;/a&gt;&lt;/audio&gt; 当浏览器不支持或者当前音乐地址失效时会分别访问 source 提供的路径，如果全部失效则提示最下边的文本。 音乐属性 属性名 说明 controls 显示控件 autoplay 自动播放 loop 循环播放 preload 预加载 muted 静音 视频HTML5 中提供的音频 API 标签为 &lt;video&gt;&lt;/video&gt;，使用示例如： 1&lt;video src=&quot;不能说的秘密.mp4&quot; controls&gt;&lt;/video&gt; 兼容写法与音乐相同 视频属性 属性名 说明 controls 显示控件 autoplay 自动播放 loop 循环播放 muted 静音 poster 预览图片设置 preload 预加载 none: 不预先加载任何数据 metadata: 只预先加载元数据 （视频总时长，第一帧画面图形等） auto: 预先加载视频 音视频事件 事件名 说明 onloadedmetadata 当音频元数据加载完毕时触发，作用在于获取音视频文件的总时长 ontimeupdate 当音频播放时间变化时触发 onvolumechange 当声音改变时触发 音视频对象属性可读可写属性 属性名 说明 currentTime 音频已经播放时长（返回未格式化的秒） volume 控制音量。值为 0 ~ 1 的任意值。 muted 布尔值。静音。（ture 表示静音，false 表示非静音） playbackRate 播放速率 只读属性 属性名 说明 duration 音频总时长（返回未格式化的秒） paused 布尔值。音频文件是否暂停。（ture 表示暂停，false 表示播放） ended 布尔值。音频文件播放结束（ture 表示播放结束，false 表示播放中或者暂停） 音视频对象方法 方法名 说明 pause 暂停 play 播放","tags":["前端经验"],"categories":["前端经验"]},{"title":"U盘PE装原版Win10系统教程","path":"//","content":"本教程主要讲述如何用U盘PE启动安装原版Win10系统（即MSDN下载的ISO），当原系统损坏、崩溃或Win10升级异常导致系统启动不了时，都可以使用U盘启动来修复&#x2F;重装。U盘PE重装非常灵活，可以这么说学会灵活使用PE维护系统等于多一个撩小姐姐的技能（不管你信不信，反正我是懂了），下面10号搬运工以微PE为示范安装最新Win10原版。 前期准备 原系统重要文件备份（数据无价） 下载原版win10 iso映像文件 （回复关键词“Win10”可获取最新安装包下载） 8G或以上容量U盘 微PE工具箱（工具不唯一，请务必使用纯净无捆绑的工具） 制作U盘PE 1、连接一个空U盘 2、打开pe制作工具，选择安装方式为“U盘” 3、选择好“待写入U盘”，然后点击“立即安装进U盘”，其它默认即可 PS： 制作U盘格式建议选择支持单文件大于4G的exFAT或NTFS 请注意备份U盘资料 4、这样U盘pe便顺利制作完成了（制作成功后U盘可用空间会变小） 系统安装步骤 1、在下表查阅你的电脑对应的快捷启动热键，重启电脑时不停按启动热键（一般是F12、ESC），直到出现启动选择界面 （重要提醒：选择热键前，确保电脑连接着U盘） 2、在弹出的启动界面中选择U盘启动盘，如搬运工用的是金士顿U盘制作的，此步如有疑问可拍照片联系我协助解决 3、 进入界面后打开“CGI备份还原” 4、依次选择安装的盘（一般为C盘）和镜像文件，然后点击“执行” PS：然后在弹出的窗口选择Win10的版本（新版win10镜像一般包含多版本） 5、选择是否保留原系统内容和自动重启，此时可拨掉U盘 系统设置 前一步还原完成并重启后会进入系统部署过程，整个过程比较简单 1、默认中国 2、选择你常用的输入法 3、根据电脑是公用还是私用进行设置 4、创建一个账号或使用已有的账号，可不填密码 5、年龄是个秘密，其实手机也是 6、设置自己想要的功能 7、请耐心等待，愿所有的美好如期而至 恭喜你，成功安装原版Win10，请尽情体验 注意事项 示范版本为Win10 1709，不同版本可能有少许差异，请以实际为准 教程使用微PE做例子，看个人爱好来选择纯净的PE安装工具即可 PE的技能不限于重装，还可以修复引导、重新分区、转分区等等","tags":["Windows"],"categories":["Windows"]},{"title":"Windows系统网站-KMS","path":"//","content":"在重装系统的时候，一个干净安全可信任的Windows原版系统镜像是必不可少的，不过对于很多人来说，在茫茫的网络资源库里，想找到一个自己想要的东西，却有点困难，搞不好就被盗版 网站骗了，下载了一个流氓的系统镜像，装上之后一堆第三方推广应用，甚至可能会暗藏病毒、泄露隐私。今天就给大家介绍几个可以免费下载 Windows 原版镜像的网站。 1：MSDN，我告诉你 不必多说，不少人已经听说过这个网站了。这里面收录了来自微软官方的Windows系统原版镜像，同时还有一些文件资源。比如开发者工具、服务器、设计人员工具、应用和拓展插件等等。 官网： https://msdn.itellyou.cn/ 如果你想要下载Windows 10 2004 的新版本，则需要进入他们的新网站（https://next.itellyou.cn），登录之后才能下载。 2: 微软官网下载 用手机浏览器打开下面的网址（需要等待一段时间，网页加载速度比较慢）https://www.microsoft.com/zh-cn/software-download/windows10ISO 进入网站后，点击【选择版本】，在弹窗中选择Windows 10 版本， 点击确认， 接下来，产品语言选择【简体中文】，然后确认。等待一会儿后，进入到下面的页面，选择【64-bit下载】，开始下载 这个网站建议在手机浏览器打开。如果使用电脑浏览器，则出现以下界面，不容易找到原版镜像的下载入口 3：WZT网站 这也是一个收录Windows 系统镜像的网站。官网链接如下： https://tb.rg-adguard.net/public.php 下载的时候，在选择类型中，选择 WIndows(Final) ， 根据需求选择相应的版本 然后即可进入下载 4：Microsoft Windows and Office ISO DownloadTool 这是一个可以下载Windows和Office的下载器。使用的时候，双击运行.exe文件，就可以进入下载器。 文件链接： https://www.heidoc.net/php/Windows-ISO-Downloader.exe 在右侧选择你要下载的系统版本（Windows7、8、8.1、10），等待一会儿后，在左侧选择系统内部版本和系统语言，然后就会开始下载 下载 Office 的时候同理 以上就是几个可以免费下载微软WIndows系统原版镜像的方法，大家在进入网站的时候，注意区分是否是正版网站。建议直接复制网站网址，直接打开。 科普：Windows 10 Home–家庭版Windows 10 PRO–专业版Windows 10 Enterprise–企业版Windows 10 Education–教育版Windows 10 Mobile–移动版（已死）Windows 10 Mobile Enterprise–企业移动版（已死）Windows 10 IoT Core–物联网版Windows 10 S–可以理解为简化版或者学校版 Windows10各个版本的区别：一、Windows10家庭版目前绝大部分新出厂的电脑使用的都是Windows10家庭版系统，Windows10家庭版具备大多数Windows10的关键功能，包括全新的开始菜单、Edge浏览器、Windows Hello生物特征认证登录以及虚拟助手小娜。Windows10家庭版不能自己选择更新补丁，只能照单全收，系统将会自动安装任何安全补丁，不再向用户询问。win7和win8用户可以免费升级到家庭版。 二、Windows10专业版专业版用加入了域、群策略管理、BitLocker、企业模式IE浏览器、Assigned Access 8.1、远程桌面、Hyper-V客户端、加入Azure活动目录、浏览Windows10商业应用商店等全新的功能。拥有Win7以及8.1专业版的用户可以免费升级至Windows10专业版。 三、Windows10企业版Windows10企业版在拥有Windows10专业版所以功能的基础上，增加了Direct Access、支持应用白名单的AppLocker、通过点对点连接与其他PC共享下载与更新的BranchCache以及基于组策略控制的开始屏幕等功能。普通用户无法免费升级到Windows10企业版，Windows10企业版需要批量许可授权。 四、Windows10教育版Windows10教育部是微软第一次推出相关的版本，Windows10教育部是专门为大型学术机构设计的版本，具备企业版中的安全、管理及连接功能。功能和企业版基本没有差异。 使用KMS工具激活Windows系统或office系列软件 ~~ 注意：本站所提供的 KMS 激活服务器项目并未向 ©Microsoft 公司实质性购买任何与所提供激活服务有关的任何软件正式版的激活许可证，所以使用此方法所激活的任何软件明显属于盗版，所有激活服务仅限于个人及学习使用，切勿用于商业目的！！！~~ KMS 服务器地址 KMS.IFIBE.COM替代：kms.03k.org激活 Windows 系统首先需要将当前系统的密钥替换为批量授权 (GLVK) 然后在使用 KMS 激活，可以在这里找到对应的批量密钥1. 开始激活：以 Windows 专业版为例，运行一个管理员权限的 CMD 窗口或 PowerShell (管理员)，执行以下命令12345slmgr -upkslmgr -ipk W269N-WFGWX-YVC9B-4J6C9-T83GXslmgr -skms kms.ifibe.comslmgr -atoslmgr -dlv 其他版本的 Windows 系统可以在 KMS 工具说明页找到对应的 GLVK 密钥，替换 slmgr -ipk 后面的 W269N-WFGWX-YVC9B-4J6C9-T83GX 即可完成激活，最后可以使用 WIN+R 打开快捷运行输入 slmgr.vbs -dlv 查看激活详细信息。 补充： windows 10 家庭版 GLVK 密钥 系统版本 KMS 密钥 Win 10 Core TX9XD-98N7V-6WMQ6-BX7FG-H8Q99 Win 10 CoreN 3KHY7-WNT83-DGQKR-F7HPR-844BM Win 10 CoreSingleLanguage 7HNRX-D7KGG-3K4RQ-4WPJ4-YTDFH Win 10 CoreCountrySpecific PVMJN-6DFY6-9CCP6-7BKTT-D3WVR 激活 Office 首先需要确保安装的 Office 是 VOL 版本，这里可使用转换脚本来完成版本的切换。 切换完成打开管理员权限的 CMD 窗口或 PowerShell (管理员) 执行以下命令1234#64位软件目录cd &quot;C:\\Program Files\\Microsoft Office\\Office16&quot;#32位软件目录cd &quot;C:\\Program Files (x86)\\Microsoft Office\\Office16&quot; 切换到软件安装目录后执行12cscript ospp.vbs /sethst:kms.ifibe.comcscript ospp.vbs /act 即可完成 Office 的激活推荐 使用 OTool 工具来管理 Office 版本，这个工具可一键安装和切换不同 Office 版本，还可以进行 Office 的模块化安装，Office 各个版本的离线安装包可以在这里找到。 桌面图标变成白色方块图标一键恢复方法：当电脑系统的图标缓存功能出现问题后，在新建、修改或移动桌面快捷方式图标时，图标会显示成不正常的白色图样，双击图标任然能打开运行。 本文介绍如何使用简单的批处理文件快速解决白图标问题。 点击桌面右下角“开始”图标 输入“记事本”，搜索到“记事本”程序，点击打开“记事本”程序 在空白记事本文档里输入如下批处理命令（可复制粘贴到文档中）： 12345@echo offtaskkill /f /im explorer.exeCD /d %userprofile%\\AppData\\LocalDEL IconCache.db /astart explorer.exe 保存文件到桌面： 点击“文件”-“保存”； 选择保存位置：“桌面”； 输入文件名(必须英文“.bat”结尾)：xxx.bat 更改保存类型（重要！！）：所有文件 点击保存， 找到刚才创建的批处理文件，双击（或点右键打开）此文件 执行此批处理文件时，会闪下屏，重启桌面管理程序，此过程中若有杀毒软件弹出拦截提示，务必同意运行，否则批处理重新图标缓存将失败。","tags":["Windows"],"categories":["Windows"]},{"title":"Magisk卡刷-通刷官方-了解Fastboot","path":"//","content":"root，类似于Windows系统中的Administrator，root是Linux系统中的超级管理员用户帐户，该帐户拥有整个系统的最高权限，可方便地对于系统的部件进行删除或更改。 本教程正常情况无需双清或重装系统，可以进行OTA升级。升级后重复教程即可重新root。但还是要记得备份数据后进行以下操作。注：刷机有风险，玩机需谨慎。 操作不当所造成后果，与我无瓜 开始教程解锁手机bl锁大部分手机官方为了保证手机的安全，为手机设置了BL锁，在BL锁未解的情况下，用户是不能自行刷机或获取ROOT权限的，所以要想root就必须先解bl锁。 华为和ov貌似不可以，具体自己手机是哪个牌子的可以去查一查是否支持解bl锁，下文以小米手机为例 解锁bl锁之前要先把自己的小米账号跟手机绑定上 之后直接百度搜索小米解锁bl锁 下载完之后解压大概是得到这样的目录 打开miflash_unlock.exe并登录自己的小米账号进行解锁，解锁方式为在关机下音量下键与电源键一起按，当你看到这幅画面就证明你成功进入了Bootloader，之后就一路下一步就好了。 如果无法识别手机请打开手机的开发者选项并打开usb调试，miui的开发者选项是点击我的设备→全部参数→连续按miui版本就打开了开发者选项 ps:小米手机解bl锁是需要等七天的，七天之后才可以解锁 注意一定要备份，一定要备份，一定要备份！！！ 刷入第三方recREC全程Recovery,通俗一点讲就是手机刷机软件，手机开机时按住电源键和音量＋建就可以进入到rec rec分为官方rec和第三方rec这个就是官方rec，啥玩意也没有，有的有很鸡肋，所以这里我们可以刷入第三方rec。 第三方rec功能十分之多，可以直接一键root,这里推荐TWRP。 刷入第三方rec首先要做的就是找到你手机对应的第三方rec,集合文件的下载地址： 天翼云盘 O网页链接（访问码：vv8a）自行找到与自己手机对应的rec下载 下载完成后解压直接运行twrp一键刷入工具bat 部分机型可能没有这个文件，别慌你只需要找到一个有这个文件的，然后右键记事本打开它，把我画上的这个镜像文件名字改成你自己手机对应的rec里面带的镜像文件，改完之后保存把这个改完之后的bat文件放到你手机对应rec的文件夹里运行就可以了，记得运行时手机要处在Bootloader模式。 root系统此时你的手机就会重启进入TWRP，这个时候点击高级→关闭AVB2.0校验 之后还是点击高级→root系统，这里会自动安装面具，之后手机会自动重启，手机上会多一个面具 这个时候你的手机就已经root成功了，你可以选择很多框架比如xp exp lsp框架，反正root好处多多，还有太多功能等待发掘 最后总结一下关于第三方REC的一些小技巧和知识第三方REC有哪些？ LR.Team定制版TWRP、OrangeFox（橙狐）等… 以上提供了几个主流的第三方REC下载地址，几乎覆盖了全部机型。强烈推荐 LR.Team定制版TWRP！ 双清、三清、四清、五清、格式化Data、恢复出厂设置各是指的什么？ 先介绍一下这几个分区： 一般的安卓系统都有以下几个存储空间分区：Data，Cache，Dalvik Cache，System，内置存储几个。SD卡是指外置TF卡，USB-OTG是指外挂的U盘，这两个不属于手机自身的存储设备。 它们各自有以下作用： Data分区：保存应用程序的相关数据数据 Cache：保存系统以及应用的缓存数据 Dalvik Cache：安卓系统启动时，会建立一个所有程序的信任分支、以优化缓存文件，加快启动速度，即虚拟机缓存。 System分区：系统固件分区 内置存储分区：手机的内部存储文件（用户直接可见，即文件管理显示的内容空间） 下面说说双清、三清、四清、五清、格式化Data、恢复出厂设置的区别： 双清：清除Data、Cache 进入第三方的Rec，进入后点击【清除】，此时下面有个【滑动按钮确认恢复出厂设置】，即为双清。 以下清除操作属于高级操作，需要进入高级清除界面。 三清：清除Data、Cache和Dalvik Cache。 四清：清除Data、Cache、DalvikCache和System分区。 五清：清除了Data、Cache、Dalvik Cache、System分区和内置存储。 格式化DATA分区：全盘格式化 格式化Data分区以及五清操作会清除内部存储，这意味所有文件会全部丢失；所以在进行此操作之前，务必转移数据；尤其是ROM固件，很多人一时上头在格式化Data或者五清之后，把ROM固件也删除了，导致时手机内部没有固件可以刷入。 哪些情况下可以进第三方REC（如何进第三方REC）？ 1：不同的手机不一样，对小米系列来说，长按电源键+音量加，待手机重启之后，松开电源键，继续按住音量加即可进入 2：在系统更新界面，选择“重启到Recovery”，也可以进入第三方REC；某些官改会在开机界面提供“卡刷模式”，亦即第三方REC模式。 3：卡米等情况下也可以进，方法如1 第三方REC如何设置中文（前提是本身支持，某些不支持中文）： 1：如果你是首次刷入，在进入首页之前，选择“SelectLanguage”这个按钮，找到“Chinese（Simplified）”这个选项，然后确认即可 2：如果你已经进入了首页，可以点击“Setting”，选择第四个图标，选择语言。然后确认。 第三方REC设置：1：设置页，可以调节震动，语言，时间， 2：建议关闭“ZIP签名校验”功能 3：某些第三方REC的高级设置中有一些“重载主题”、ROOT系统、取消强制加密、恢复官方REC、签名boot、清除开机密码，清除电池信息等功能 4：第三方REC中有文件管理功能，并且是系统级的；你可以在这里进行一些应用的删除，文件修改等操作； 一些常用的目录：1：sdcard：内部存储目录（即手机系统中文件管理显示的目录） 2：external_sd：外置TF卡目录 3：QQ文件目录：sdcard&#x2F;Tencent&#x2F;QQfile_recv 4：系统下载目录：sdcard&#x2F;Download 注意： 1：当系统进行了安卓底层更新的时候，一般来说，第三方REC也需要自己进行升级；否则会出现刷ROM错误。 2：在进行“更新官方系统”或者第一次刷入第三方REC的操作时，务必在重启手机之前刷入Magisk框架；防止第三方REC恢复成官方REC。 其他： 1：在第三方REC模式下，手机可以用数据线直接连接电脑，进行数据传输 2：第三方REC下，可以使用截图；和系统截图一样，都是按下电源键+音量减，实现截图操作。所以以后如果要将刷机过程中的错误发给别人看，最好用截图功能。 你真的了解Fastboot模式吗? 硬核科普！不知道机友们对Fastboot模式了解多少，或许大部分机友只在解锁的时候进Fastboot，刷TWRP的时候进Fastboot，好奇这个模式还能干什么？ 本篇文章就结合我的经验充分解释一下有关Fastboot在普通用户层面的相关知识，可能存在差异，后续更新完善，本人文字功底较差也欢迎指正！ Fastboot模式与刷机紧密的联系着，有一种说法，能进Fastboot就不是真砖，当然，只针对经验丰富的老司机，新手来说，我的手机开不了机了，就是砖头。 CMD命令行 在没有适配adb环境的电脑上，不可以直接用开始菜单里的cmd来执行adb&#x2F;fastboot命令，后续抽空写一下全局adb教程 1## https://wwi.lanzoui.com/iAQUYskx50b## 下载谷歌官方提供的工具，第一个文件夹里有fastboot驱动 进入Fastboot模式 彻底关机下: （小米&#x2F;联想&#x2F;努比亚）: 音量下＋电源键(长按) （一加）: 三个键一起按住(音量上+下+电源键) （三星）: 插上数据线-音量上+下+电源键进入Recovery-用音量键选择reboot to bootloader再按电源键进入 仅举例部分，可到各大机型板块或网上搜索关键字 连接电脑 Fastboot模式连接手机，如下图所示，没有驱动 Fastboot模式连接手机，如下图所示，连接正常（名称可能差异） 驱动在上面有提供 解锁BL 解锁会全盘格式化，各家厂商解锁方法不一 1fastboot oem unlock ## 一加 Fastboot命令 http://www.miui.com/unlock ## 小米 网页申请 仅举例部分，可到各大机型板块或网上搜索关键字 解锁成功每次开机都会弹出警告页面(小米定制在第一屏) 查看是否解锁 最后一行显示locked视为未解锁 最后一行显示unlocked视为已解锁 小米的开机第一屏有把锁判定 解除加密 vbmeta分区加密的作用是保护系统不被修改，如果你想ROOT或者是想删掉一些系统文件，则必须去除，其原理是做空 通过以下命令: 12## https://wwi.lanzoui.com/iWlOVvdiffcfastboot --disable-verity --disable-verification flash vbmeta vbmeta.img## https://wwi.lanzoui.com/iaJ6Bvdifgdfastboot flash vbmeta_system vbmeta_system.img 不去除加密的情况下修改系统文件，会循环卡死Fastboot 在预装Android10.0的手机上，想要修改系统文件，将涉及到一个新的概念 -动态分区- 动态分区是什么? Android存放系统文件的分区有: System&#x2F;Vendor&#x2F;odm等 非预装安卓10.0的手机，例如红米K20Pro，获取ROOT权限以后，就可以通过MT自己精简系统了，把一些不会用到的预装APP删了重启，OK这些APP没了 但如果！我的手机出厂就是安卓10.0及安卓10.0以上的系统，就拿我的红米K30S来说，按照大佬们的方法获取了ROOT权限，删了个不会用到的预装APP重启，你们猜会怎样? 没错，就是卡兔子(Fastboot模式) 其根本的原因就是因为动态分区。本来单独固定大小的三个系统分区 (System&#x2F;Vendor&#x2F;odm) 合并成了一个super分区，其里面包含的子分区是可以随意调整大小的 打个比方: super分区&#x3D;10G System&#x3D;5G Vendor&#x3D;4G odm&#x3D;1G 我可以把System调整为4G，把odm扩大到2G 在非动态分区的情况下，此操作异常危险且无法通过OTA完成 在动态分区的情况下，可以轻松通过修改super镜像完成，且可以通过OTA系统更新到用户的手机 变化导致无法直接修改系统文件，但第三方ROM可以解决，例如一些官改就支持修改系统分区，只能说仅仅原版系统有这种限制，至于原因就不得而知了 有哪些系统分区？ 早期的刷机包非常简陋，整个刷机包才一两百m，只有一个系统分区System(不包括boot和底层) 安卓8.0开始，从System里分离出来了Vendor 安卓10.0开始，从System里分离出来了product 安卓11.0开始，从System里分离出来了system_ext 当前存放系统文件的分区有: System+Vendor+product+system_ext 刷入镜像 通过以上，我们对系统分区有一定了解，而镜像的意思就是存放系统文件的压缩包，这跟我们平常压缩的文件不同，是一种特定的压缩形态，能保持每个文件对应的权限，在刷机包里一般是后缀为img的文件(卡刷包一般压缩为dat&#x2F;br) Fastboot模式可以刷入img格式的镜像，例如刷入System分区镜像: 1fastboot flash system xx.img## XX.img指镜像目录## system指将刷入的分区 刷入Vendor分区镜像： 1fastboot flash vendor xx.img## XX.img指镜像目录## vendor指将刷入的分区 Fastbootd Fastbootd是动态分区专属的一个模式，属于Recovery分区的功能。部分TWRP也适配 预装动态分区的手机上是无法通过在Fastboot模式刷入系统镜像的(指super内的子分区)，只能完整刷入super.img 在fastboot下执行: 1Fastboot reboot fastboot 进入Fastbootd方可正常刷入 双分区概念 网上相关科普很多，你可以理解成我的手机里有两个大分区，通常我们手机系统更新步骤是 下载系统包-点击更新-手机重启-离线安装-自动重启 如果是AB分区的机型 下载系统包-点击更新-在线安装-安装完成-提示重启 没错，可以一边系统更新一边正常使用手机，没有关机安装更新的步骤，其原理很容易理解 我的手机有两个分区A和B，我在使用A分区收到系统更新，系统会将系统安装到B分区，安装完成提示重启，就会进入B分区 好处有很多，比如把手机搞变砖了还可以切换另一个分区继续用 切换分区 1fastboot set_active a## 切换到A分区 1fastboot set_active b## 切换到B分区 回锁BL 在执行回锁指令之前，你必须确定当前系统没有任何修改，否则无法开机。因此回锁操作十分危险。 1fastboot oem lock 小米通用刷回官方系统教程此方法并非万能，倘若你的设备无法进入Fastboot，就只能求助售后了 在这里下载你机型的线刷包 https://www.miui.com/shuaji-393.html 下载通用刷机工具 解压到英文目录的文件夹，如果不懂就直接解压到桌面 最新线刷包一般两层压缩，还需要解压一次 点进去文件夹能看到这些东西 解压通用刷机工具并打开这个 点这里安装驱动 点这里选择解压出来的文件夹 注意是包含内容的那个文件夹 如果选错了会有错误提示 目录必须是全英文 第1个是常规的刷回，第3个是回锁并刷回(解锁不易，慎重回锁)，第2个是MIUI升级版本 把手机彻底关机，音量下＋电源键进入兔子模式插上 是否连接成功取决于你的数据线&#x2F;电脑接口，可在设备管理器查看 点击加载设备，就能看到你的手机连上了 点击刷机开始刷入，一定要保持稳定连接，等待完成","tags":["安卓玩机"],"categories":["安卓玩机"]},{"title":"前端免费资源大汇总","path":"//","content":"前端免费资源大汇总1、前端开发电子书 PDF 电子书 《JavaScript Succinctly》 《Bootstrap 4 Succinctly》 《JavaScript Enlightenment》 《Designing Scalable JavaScript Application》 《JavaScript For Impatient Programmers》 在线电子书 《Learning JavaScript Design Patterns》作者：Addy Osmani， https://addyosmani.com/resources/essentialjsdesignpatterns/book/ 《你不懂 JavaScript》系列，在 GitHub 有 92k+ Star https://github.com/getify/You-Dont-Know-JS 《JavaScript 秘密花园》（这是中文版） http://bonsaiden.github.io/JavaScript-Garden/zh/ 《jQuery 基础》 http://jqfundamentals.com/ 《Speaking JavaScript》 http://speakingjs.com/es5/ 《DOM Enlightenment》 http://domenlightenment.com/ 《Learn CSS Layout the pedantic way》 http://book.mixu.net/css/ 《Node 的艺术》GitHub 上有 7900+ Star https://github.com/maxogden/art-of-node/blob/master/readme.zh-cn.md 《深入 HTML 画布》 https://joshondesign.com/p/books/canvasdeepdive/toc.html 2、前端开发速查表 PDF 速查表 13 张速查表，包括：CSS、HTML、jQuery、Vue、React、Angular、响应式 Web 设计、Bootstrap 等。 交互式速查表 Bootstrap Icon https://glyphicons.bootstrapcheatsheets.com/ Vue.js 2.2 速查表 https://vuejs-tips.github.io/cheatsheet/ HTML 速查表 https://htmlcheatsheet.com/ CSS 速查表 https://htmlcheatsheet.com/css/ CSS 布局速查表 https://learn-the-web.algonquindesign.ca/topics/css-layout-cheat-sheet/ CSS grid 速查表 https://alialaa.github.io/css-grid-cheat-sheet/ 3、GitHub Awesome 系列 JavaScript 资源大全中文版 https://github.com/jobbole/awesome-javascript-cn CSS 资源大全中文版 https://github.com/jobbole/awesome-css-cn Awesome Vue https://github.com/vuejs/awesome-vue Awesome React https://github.com/enaqx/awesome-react Awesome Angular https://github.com/gdi2290/awesome-angular 4、前端学习视频 《Web Development in 2018 - A Practical Guide》 https://www.youtube.com/watch?v=Zftx68K-1D4 《CSS Crash Course For Absolute Beginners》 https://www.youtube.com/watch?v=yfoY53QXEnI 《CSS3 Animation &amp; Transitions Crash Course》 https://www.youtube.com/watch?v=zHUpx90NerM 《Intro to JavaScript》Udacity 新手入门课程 https://www.udacity.com/course/intro-to-javascript--ud803 《Programming for the Web with JavaScript》 https://www.edx.org/course/programming-web-javascript-pennx-sd4x 《麻省理工学院（MIT）和 JS 相关的公开课列表》 https://ocw.mit.edu/search/ocwsearch.htm?q=JavaScript https://ocw.mit.edu/search/ocwsearch.htm?q=CSS","tags":["其他技术栈"],"categories":["其他技术栈"]},{"title":"Git基础-Github自定义域名","path":"//","content":"「学习笔记」Git基础 1. Git基础 Git官网(下载速度慢) https://git-scm.com/ 阿里云加速(下载速度快)：https://npm.taobao.org/mirrors/git-for-windows/ 1.1 版本管理 1.1.1什么是版本管理版本管理是一种记录文件变化的方式，以便将来查阅特定版本的文件内容。 1.1.2 Git基本概念 版本库👉.git 当我们使用git管理文件时，比如git init时，会创建出一个.git文件，我们把这个文件称为版本库。 .git文件另外一个作用就是它在创建的时候，会自动创建master分支,并且将HEAD指针指向master分支。 工作区 本地项目存放文件的位置，即workspace 暂存区(Index&#x2F;Stage) 暂时存放文件的地方，通过add命令将工作区的文件加到缓冲区 本地仓库(Repository) 通常情况下，我们使用commit命令可以将暂存区的文件添加到本地仓库 通常而言，HEAD指针指向的是master分支 远程仓库(Remote) GitHub托管项目时，它就是一个远程仓库 通常我们使用clone命令将远程仓库代码拷贝下来，本地代码更新后，通过push推送到远程仓库 1.1.3 人为维护文档版本的问题 文档数量多且命名不清晰导致文档版本混乱 每次编辑文档都需要复制，不方便 多人同时编辑同一个文档，容易产生覆盖 1.2 Git 是什么 Git是一个版本管理控制系统(缩写VCS)，它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。 1.3 基本工作流程 git仓库 暂存区 工作目录 用于存放提交记录 临时存放被修改文件 被Git管理的项目目录 1.4 Git使用前配置 在使用git前，需要告诉git你是谁，在向git仓库中提交时需要用到。 配置提交人姓名:git config --global user.name 提交人姓名 配置提交人邮箱:git config --global user.email 提交人邮箱 查看git配置信息:git config --list 「注意」 如果要对配置信息进行修改，重复上述命令即可。 配置只需要执行一次。 1.5 提交步骤 git init初始化git仓库 git status查看文件状态 git add 文件列表追踪文件 git commit -m 提交信息向本地仓库中提交代码 git log查看提交记录 git push https://github.com/ovfan/git-demo.git master本地仓库推送到GitHub远程仓库 git remote add origin https://github.com/ovfan/git-demo.git 为远端仓库地址添加别名。 添加完别名后，下次推送使用git push origin master git push -u 远程仓库地址别名 分支名称 -u 记住推送地址及分支，下次推送只需要输入git push即可 1.6 撤销 用暂存区中的文件覆盖工作目录中的文件：git checkout 文件 将文件从暂存区中删除：git rm --cached 文件 将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作区目录：git reset --hard commitID 2. Git 进阶 2.1 分支 为了便于理解，可以认为分支就是当前工作目录中代码的一份副本，使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。 2.1.1 分支细分 主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。 主分支，用于部署生产环境的分支，确保稳定性。 master分支一般由develop以及hotfix分支合并，任何情况下都不能直接修改代码。 开发分支（develop）：作为开发的分支，基于 master 分支创建。 develop为开发分支，通常情况下，保存最新完成以及bug修复后的代码。 开发新功能时，feature分支都是基于develop分支下创建的。 功能分支（feature）：作为开发具体功能的分支，基于开发分支创建。 开发新功能，基本上以develop为基础创建feature分支。 分支命名：feature&#x2F; 开头的为特性分支， 命名规则: feature&#x2F;user_module、 feature&#x2F;cart_module。 4.release分支 release 为预上线分支，发布提测阶段，会release分支代码为基准提测。 5.hotfix分支 分支命名：hotfix&#x2F; 开头的为修复分支，它的命名规则与 feature 分支类似。 线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。 「功能分支 -&gt; 开发分支 -&gt; 主分支」 2.12分支命令 git branch 查看本地分支 git branch -r查看远程分支 git branch 分支名称创建分支 git checkout -b 分支名称创建并切换到新建分支 git checkout 分支名称切换分支 git merge 来源分支合并分支 git branch -d 分支名称删除分支 分支被合并后才允许删除 git branch -D强制删除 git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;重命名分支 git add .全部上传到缓存区 git add 指定文件指定文件上传到缓存区 2.2 暂时保存更改 在git 中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。 使用场景：分支临时切换 存储临时改动:git stash 恢复改动:git stash pop 3. GitHub当和开发团队共享数据时，设置一个远程仓库，可以把它看成一个文件管理服务器，利用这个服务器可以与开发团队的其他成员进行数据交换。 3.1 拉取操作 克隆远端数据仓库到本地：git clone 仓库地址 拉取远程仓库中最新的版本：git pull 远程仓库地址 分支名称 3.2 ssh免登录 生成密钥：ssh-keygen 密钥存储目录:C:\\Users\\lenovo.ssh 公钥名称：id_rsa.pub 私钥名称：id_rsa 3.3 GIT忽略清单 将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。 git忽略清单文件名称：「.gitignore」 将工作目录中的文件全部添加到暂存区：git add . 看看如何配置该文件信息。👇 123456789101112131415161718192021# 此行为注释 会被Git忽略# 忽略 node_modules/ 目录下所有的文件node_modules# 忽略所有.vscode结尾的文件.vscode# 忽略所有.md结尾的文件*.md# 但README.md 除外!README.md# 会忽略 doc/something.txt 但不会忽略doc/images/arch.txtdoc/*.txt# 忽略 doc/ 目录下所有扩展名为txt文件doc/**/*.txt Github Pages 绑定自定义域名如果觉得 GitHub 自动分配的二级域名有点长，还不太好记忆。可以绑定一下自定义域名。 域名购买首先，你得先注册一个域名。 我这用的是阿里云，也可以去腾讯云、GoDaddy等注册也行！！ 阿里云新用户活动界面：https://promotion.aliyun.com/ntms/act/domainbrand.html 阿里云域名1元首年：https://wanwang.aliyun.com/domain/1yuan 注意：.cn 后缀的好像必须要备案才能正常使用！其它后缀是国内服务器要备案。 域名解析 购买好域名后打开控制台： 控制台 打开：产品与服务 —》 域名： 域名管理 注意：新购买可能需要实名认证,到实名认证页面上传身份证照片和输入身份证号码就等他认证成功就行了 实名认证完继续如下步骤： 找到你的域名，点击解析： 解析域名 点击添加记录: 添加记录 A记录 CNAME记录 填好直接保存就行了。 分别添加 四个A 记录 和 一个 CNAME 记录 A 记录需要添加的 ip 如下： 12345PLAINTEXT185.199.108.153185.199.109.153185.199.110.153185.199.111.153 添加完成后如图： 添加完成解析地址 手机客户端手机客户端也可以进行域名解析，首先下载阿里云的手机客户端。 打开登陆后在主页找到域名管理: 域名管理 找到你的域名，点击旁边的 三点图标，再选择解析: 解析域名 点击右上角的+加号添加一条解析记录： 解析内容和上面网页端一样,分别添加 四个A 记录 和 一个 CNAME 记录： 添加记录完成 修改GitHub Pages 设置域名解析好就可以到GitHub Pages 设置添加自定义域名了 打开你的仓库地址，选择 setting 打开设置 左侧菜单找到 Pages，在 Custom domain 处输入你的域名。 填好域名点击 save 保存就好了！，就会发现你的网址变成了自定义的域名。 输入自定义域名 如果下面的HTTPS没有打开建议勾选上。 https 补充内容 如果你是用 Hexo 生成的静态网站，需要在 source 文件夹内创建个CNAME 文件,如果文件存在则直接打开编辑。用任意文本编辑器打开，把你的域名输入进去，保存就行了。例如，我的域名是guguge.top内容则为： CNAME文件内容","tags":["GitHub"],"categories":["GitHub"]},{"title":"CSS笔记","path":"//","content":"CSS笔记link rel&#x3D;”stylesheet” href&#x3D;”文件名”margin:0px auto;（块级元素居中）和width：的组合写2个数：第一个代表上下，第二个代表左右写3个数:第一个代表上，第二个代表左右,第三个下写4个数：上，右，下,左text-align:center；（行级元素居中）list-style：none （去除符号）clear：both（去除浮动）overflow:hidden;(超过大小就不显示)overflow:scroll 滚动条border:none;outline:none;去除按钮边框 li:nth-child(1)：第一个transform：移动、旋转、倾斜、3D转换none定义不进行转换。translate(x,y)定义 2D 转换。translate3d(x,y,z)定义 3D 转换。translateX(x)定义转换，只是用 X 轴的值。translateY(y)定义转换，只是用 Y 轴的值。translateZ(z)定义 3D 转换，只是用 Z 轴的值。scale(x,y)定义 2D 缩放转换。scale3d(x,y,z)定义 3D 缩放转换。scaleX(x)通过设置 X 轴的值来定义缩放转换。scaleY(y)通过设置 Y 轴的值来定义缩放转换。scaleZ(z)通过设置 Z 轴的值来定义 3D 缩放转换。rotate(angle)定义 2D 旋转，在参数中规定角度。rotate3d(x,y,z,angle)定义 3D 旋转。rotateX(angle)定义沿着 X 轴的 3D 旋转。rotateY(angle)定义沿着 Y 轴的 3D 旋转。rotateZ(angle)定义沿着 Z 轴的 3D 旋转。skew(x-angle,y-angle)定义沿着 X 和 Y 轴的 2D 倾斜转换。skewX(angle)定义沿着 X 轴的 2D 倾斜转换。skewY(angle)定义沿着 Y 轴的 2D 倾斜转换。perspective(n) 为 3D 转换元素定义透视视图transition 2s 简写属性，用于在一个属性中设置四个过渡属性。transition-property：all background width height 规定应用过渡的 CSS 属性的名称。transition-duration 2s 定义过渡效果花费的时间。默认是 0。transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。transition-delay 规定过渡效果何时开始。默认是 0。伪类选择器：hoverdisplay:none 隐藏display:block 显示placeholder：显示内容点击就会删除values：显示内容点击不会删除cursor:pointer（鼠标移动位置变成小手）opacity:0.2(透明度)tansform:rotate(180deg):旋转border-radius:50% 设置边框的角度border-radius: 60px 0 0 60px;左半圆border-radius: 0 0 0 60px;扇形 border-radius: 60px 60px 0 60px;花瓣border-radius: 50px;胶囊 border-radius: 80px&#x2F;50px;椭圆盒子模型：margin:盒子与盒子之间的距离 padding：文字到边框的距离contenr：具体内容的大小行级元素要设置浮动才有效果 文本属性：给标题添加阴影: text-shadow: 5px 5px 5px #FF0000; 属性适用于盒子阴影：box-shadow: 10px 10px 5px #888888;text-overflow:省略文本溢出overflow:hidden;(超过大小就不显示)word-wrap：自动换行word-break：字的断开line-height：行高（与height使用可以让文字垂直居中）text-align：对齐（center文字水平居中） 行级元素letter-spacing：字符间距（空隙）text-decoration：文本修饰（nono去除下划线、underline(加下划线)line-ovrline（上方加下划线）、line-through（中间加下划线）） 字体属性：font-weight： 粗细 bold(加粗)font-size：30px 大小font-family：”宋体” 字体样式Color：字体颜色边框属性：border-radius：50% 边框圆角box-shadow:边框阴影border-image:边框图像 背景设置 background-image: linear-gradient(to right, red , yellow);线性渐变background-color:背景颜色background-image:url(“图片路径”):背景图片background-repeat:(no-repeat):不重复 repeat-x(x轴重复) repeat-y(y轴重复)background-position:（x,y）设置背景的坐标，偏移量 定位布局(position：)position：static:静态定位 (没有改变他们的位置，内容按照从上到下，从左到右进行布局）position：relative：相对定位（相对于元素页面本身位置偏移）position：absolute：绝对定位 （相对于父容器位置进行偏移） 父容器加 positon:relative 会脱离标准文档流position：fixed：固定定位 做广告栏 (相对于body进行偏移) 清除浮动踏陷：父容器加高度overflow：hidden：大于我的内容会被隐藏掉行级元素转为块级元素，块级元素转为行级元素。隐藏内容display：block（块级元素） inline（行级元素） none（隐藏） inline-block:将行级元素转为一行显示的块级元素行级元素：没有宽和高 CSS整理版大小 {font-size: x-large;}(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD 样式 {font-style: oblique;}(偏斜体) italic;(斜体) normal;(正常) 行高 {line-height: normal;}(正常) 单位：PX、PD、EM 粗细 {font-weight: bold;}(粗体) lighter;(细体) normal;(正常) 变体 {font-variant: small-caps;}(小型大写字母) normal;(正常) 大小写 {text-transform: capitalize;}(首字母大写) uppercase;(大写) lowercase;(小写) none;(无) 修饰 {text-decoration: underline;}(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁) 常用字体： (font-family) “Courier New”, Courier, monospace, “Times New Roman”, Times, serif, Arial, Helvetica, sans-serif, Verdana 背景属性： (background) 色彩 {background-color: #FFFFFF;} 图片 {background-image: url();} 重复 {background-repeat: no-repeat;} 滚动 {background-attachment: fixed;}(固定) scroll;(滚动) 位置 {background-position: left;}(水平) top(垂直); 简写方法 {background:#000 url(..) repeat fixed left top;} &#x2F;简写·这个在阅读代码中经常出现，要认真的研究&#x2F; 区块属性： (Block) &#x2F;这个属性第一次认识，要多多研究&#x2F; 字间距 {letter-spacing: normal;} 数值 &#x2F;这个属性似乎有用，多实践下&#x2F; 对齐 {text-align: justify;}(两端对齐) left;(左对齐) right;(右对齐) center;(居中) 缩进 {text-indent: 数值px;} 垂直对齐 {vertical-align: baseline;}(基线) sub;(下标) super;(下标) top; text-top; middle; bottom; text-bottom; 词间距word-spacing: normal; 数值 空格white-space: pre;(保留) nowrap;(不换行) 显示 {display:block;}(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑) marker;(标记) table; inline-table; table-raw-group; table-header-group; table-footer-group; table-raw; table-column-group; table-column; table-cell; table-caption;(表格标题) &#x2F;display 属性的了解很模糊&#x2F; 方框属性： (Box) width:; height:; float:; clear:both; margin:; padding:; 顺序：上右下左 边框属性： (Border) border-style: dotted;(点线) dashed;(虚线) solid; double;(双线) groove;(槽线) ridge;(脊状) inset;(凹陷) outset; border-width:; 边框宽度 border-color:#; 简写方法border：width style color; &#x2F;简写&#x2F; 列表属性： (List-style) 类型list-style-type: disc;(圆点) circle;(圆圈) square;(方块) decimal;(数字) lower-roman;(小罗码数字) upper-roman; lower-alpha; upper-alpha; 位置list-style-position: outside;(外) inside; 图像list-style-image: url(..); 定位属性： (Position) Position: absolute; relative; static; visibility: inherit; visible; hidden; overflow: visible; hidden; scroll; auto; clip: rect(12px,auto,12px,auto) (裁切) css属性代码大全 一 CSS文字属性： color : #999999; &#x2F;文字颜色&#x2F; font-family : 宋体,sans-serif; &#x2F;文字字体&#x2F; font-size : 9pt; &#x2F;文字大小&#x2F; font-style:itelic; &#x2F;文字斜体&#x2F; font-variant:small-caps; &#x2F;小字体&#x2F; letter-spacing : 1pt; &#x2F;字间距离&#x2F; line-height : 200%; &#x2F;设置行高&#x2F; font-weight:bold; &#x2F;文字粗体&#x2F; vertical-align:sub; &#x2F;下标字&#x2F; vertical-align:super; &#x2F;上标字&#x2F; text-decoration:line-through; &#x2F;加删除线&#x2F; text-decoration: overline; &#x2F;加顶线&#x2F; text-decoration:underline; &#x2F;加下划线&#x2F; text-decoration:none; &#x2F;删除链接下划线&#x2F; text-transform : capitalize; &#x2F;首字大写&#x2F; text-transform : uppercase; &#x2F;英文大写&#x2F; text-transform : lowercase; &#x2F;英文小写&#x2F; text-align:right; &#x2F;文字右对齐&#x2F; text-align:left; &#x2F;文字左对齐&#x2F; text-align:center; &#x2F;文字居中对齐&#x2F; text-align:justify; &#x2F;文字分散对齐&#x2F; vertical-align属性 vertical-align:top; &#x2F;垂直向上对齐&#x2F; vertical-align:bottom; &#x2F;垂直向下对齐&#x2F; vertical-align:middle; &#x2F;垂直居中对齐&#x2F; vertical-align:text-top; &#x2F;文字垂直向上对齐&#x2F; vertical-align:text-bottom; &#x2F;文字垂直向下对齐&#x2F; 二、CSS边框空白 padding-top:10px; &#x2F;上边框留空白&#x2F; padding-right:10px; &#x2F;右边框留空白&#x2F; padding-bottom:10px; &#x2F;下边框留空白&#x2F; padding-left:10px; &#x2F;*左边框留空白 三、CSS符号属性： list-style-type:none; &#x2F;不编号&#x2F; list-style-type:decimal; &#x2F;阿拉伯数字&#x2F; list-style-type:lower-roman; &#x2F;小写罗马数字&#x2F; list-style-type:upper-roman; &#x2F;大写罗马数字&#x2F; list-style-type:lower-alpha; &#x2F;小写英文字母&#x2F; list-style-type:upper-alpha; &#x2F;大写英文字母&#x2F; list-style-type:disc; &#x2F;实心圆形符号&#x2F; list-style-type:circle; &#x2F;空心圆形符号&#x2F; list-style-type:square; &#x2F;实心方形符号&#x2F; list-style-image:url(&#x2F;dot.gif); &#x2F;图片式符号&#x2F; list-style-position: outside; &#x2F;凸排&#x2F; list-style-position:inside; &#x2F;缩进&#x2F; 四、CSS背景样式： background-color:#F5E2EC; &#x2F;背景颜色&#x2F; background:transparent; &#x2F;透视背景&#x2F; background-image : url(&#x2F;image&#x2F;bg.gif); &#x2F;背景图片&#x2F; background-attachment : fixed; &#x2F;浮水印固定背景&#x2F; background-repeat : repeat; &#x2F;重复排列-网页默认&#x2F; background-repeat : no-repeat; &#x2F;不重复排列&#x2F; background-repeat : repeat-x; &#x2F;在x轴重复排列&#x2F; background-repeat : repeat-y; &#x2F;在y轴重复排列&#x2F; 指定背景位置 background-position : 90% 90%; &#x2F;背景图片x与y轴的位置&#x2F; background-position : top; &#x2F;向上对齐&#x2F; background-position : buttom; &#x2F;向下对齐&#x2F; background-position : left; &#x2F;向左对齐&#x2F; background-position : right; &#x2F;向右对齐&#x2F; background-position : center; &#x2F;居中对齐&#x2F; 五、CSS连接属性： a &#x2F;所有超链接&#x2F; a:link &#x2F;超链接文字格式&#x2F; a:visited &#x2F;浏览过的链接文字格式&#x2F; a:active &#x2F;按下链接的格式&#x2F; a:hover &#x2F;鼠标转到链接&#x2F; 鼠标光标样式： 链接手指 CURSOR: hand 十字体 cursor:crosshair 箭头朝下 cursor:s-resize 十字箭头 cursor:move 箭头朝右 cursor:move 加一问号 cursor:help 箭头朝左 cursor:w-resize 箭头朝上 cursor:n-resize 箭头朝右上 cursor:ne-resize 箭头朝左上 cursor:nw-resize 文字I型 cursor:text 箭头斜右下 cursor:se-resize 箭头斜左下 cursor:sw-resize 漏斗 cursor:wait 光标图案(IE6) p {cursor:url(“光标文件名.cur”),text;} 六、CSS框线一览表： border-top : 1px solid #6699cc; &#x2F;上框线&#x2F; border-bottom : 1px solid #6699cc; &#x2F;下框线&#x2F; border-left : 1px solid #6699cc; &#x2F;左框线&#x2F; border-right : 1px solid #6699cc; &#x2F;右框线&#x2F; 以上是建议书写方式,但也可以使用常规的方式 如下: border-top-color : #369 &#x2F;设置上框线top颜色&#x2F; border-top-width :1px &#x2F;设置上框线top宽度&#x2F; border-top-style : solid&#x2F;设置上框线top样式&#x2F; 其他框线样式 solid &#x2F;实线框&#x2F; dotted &#x2F;虚线框&#x2F; double &#x2F;双线框&#x2F; groove &#x2F;立体内凸框&#x2F; ridge &#x2F;立体浮雕框&#x2F; inset &#x2F;凹框&#x2F; outset &#x2F;凸框&#x2F; 七、CSS表单运用： 文字方块 按钮 复选框 选择钮 多行文字方块 下拉式菜单 选项1选项2 八、CSS边界样式： margin-top:10px; &#x2F;上边界&#x2F; margin-right:10px; &#x2F;右边界值&#x2F; margin-bottom:10px; &#x2F;下边界值&#x2F; margin-left:10px; &#x2F;左边界值&#x2F; CSS 属性： 字体样式(Font Style) 序号 中文说明 标记语法 1 字体样式 {font:font-style font-variant font-weight font-size font-family} 2 字体类型 {font-family:”字体1”,”字体2”,”字体3”,…} 3 字体大小 {font-size:数值|inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small} 4 字体风格 {font-style:inherit|italic|normal|oblique} 5 字体粗细 {font-weight:100-900|bold|bolder|lighter|normal;} 6 字体颜色 {color:数值;} 7 阴影颜色 {text-shadow:16位色值} 8 字体行高 {line-height:数值|inherit|normal;} 9 字 间 距 {letter-spacing:数值|inherit|normal} 10 单词间距 {word-spacing:数值|inherit|normal} 11 字体变形 {font-variant:inherit|normal|small-cps } 12 英文转换 {text-transform:inherit|none|capitalize|uppercase|lowercase} 13 字体变形 {font-size-adjust:inherit|none} 14 字体 {font-stretch:condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider} 文本样式(Text Style) 序号 中文说明 标记语法 1 行 间 距 {line-height:数值|inherit|normal;} 2 文本修饰 {text-decoration:inherit|none|underline|overline|line-through|blink} 3 段首空格 {text-indent:数值|inherit} 4 水平对齐 {text-align:left|right|center|justify} 5 垂直对齐 {vertical-align:inherit|top|bottom|text-top|text-bottom|baseline|middle|sub|super} 6 书写方式 {writing-mode:lr-tb|tb-rl} 背景样式 序号 中文说明 标记语法 1 背景颜色 {background-color:数值} 2 背景图片 {background-image: url(URL)|none} 3 背景重复 {background-repeat:inherit|no-repeat|repeat|repeat-x|repeat-y} 4 背景固定 {background-attachment:fixed|scroll} 5 背景定位 {background-position:数值|top|bottom|left|right|center} 6 背影样式 {background:背景颜色|背景图象|背景重复|背景附件|背景位置} 框架样式(Box Style) 序号 中文说明 标记语法 1 边界留白 {margin:margin-top margin-right margin-bottom margin-left} 2 补 白 {padding:padding-top padding-right padding-bottom padding-left} 3 边框宽度 {border-width:border-top-width border-right-width border-bottom-width border-left-width} 宽度值： thin|medium|thick|数值 4 边框颜色 {border-color:数值 数值 数值 数值} 数值：分别代表top、right、bottom、left颜色值 5 边框风格 {border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove} 6 边 框 {border:border-width border-style color} 上 边 框 {border-top:border-top-width border-style color} 右 边 框 {border-right:border-right-width border-style color} 下 边 框 {border-bottom:border-bottom-width border-style color} 左 边 框 {border-left:border-left-width border-style color} 7 宽 度 {width:长度|百分比| auto} 8 高 度 {height:数值|auto} 9 漂 浮 {float:left|right|none} 10 清 除 {clear:none|left|right|both} 分类列表 序号 中文说明 标记语法 1 控制显示 {display:none|block|inline|list-item} 2 控制空白 {white-space:normal|pre|nowarp} 3 符号列表 {list-style-type:disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none} 4 图形列表 {list-style-image:URL} 5 位置列表 {list-style-position:inside|outside} 6 目录列表 {list-style:目录样式类型|目录样式位置|url} 7 鼠标形状 {cursor:hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize}","tags":["前端经验"],"categories":["前端经验"]},{"title":"Vscode笔记-24款插件","path":"//","content":"首先当然是一些语言支持的插件，这个大家根据自己的需要安装就好了。平时编写什么语言，就安装什么语言的插件。 这里简单列举一些语言。 C&#x2F;C++ 提供 C++ 语法识别、智能补全、代码跳转、调用依赖识别等，一般来说学生党安装这一个就可以了。还有一些其他的插件也非常不错，如 C++ Intellisense, C&#x2F;C++ Clang Command Adapter 等。 Java 提供代码调整、自动补全、jdk 文档查询、Lint、类型检查、debug 等功能。 因为 Java 的工程往往比较庞大，而 vscode 相对比较轻量级，相对来说不是非常合适。而且 Java 工程需要的插件也非常多，比如 Tomcat、spring、数据库等等……全部安装下来还是比较重的。所以还不如直接使用全部环境都集成好的 IDEA。 Go vscode 对 go 语言的支持非常不错，在某些功能上甚至比 Jetbrains 家的 Goland 还要好用，比如 golint。 和 Java 一样，golang 一般也是用来编写大型的后端项目，这类的项目代码文件非常多，感觉还是不太适合 vscode，这点还是仁者见仁。 Hive SQL Hive SQL 语法支持，主要就用到高亮和补全，毕竟 hive sql 都不在本地运行。 HTML&#x2F;CSS HTML&#x2F;CSS 语法支持，前端党必备。 Markdown markdown 语法支持，可以在 vscode 当中编辑 markdown 文档，还支持图床的图片上传功能。 由于很多 github 的 repo 都提供了 markdown 语法格式的 readme 文件，所以还是需要安装一下，这样才方便阅读。 Python Python 的语法支持，支持 Python 的单测、lint、语法高亮、代码格式化、debug、jupyter 等功能。 当中对 jupyter 的支持非常不错，可以在 vscode 当中快速打开、运行 .ipynb 文件，再也不用在 web 当中运行 notebook 了，体验大大提升。 各种神器上面介绍的都是语言支持型插件，大家根据自己平时编写的需要酌情安装即可。当然这里列举的也只是其中一部分。 下面来介绍一下功能性的插件，可以实现一些各种各样的功能，有些是开发神器，有些是摸鱼神器，各有各的用处。 Auto Close Tag 前端神器，只需要编写左标签，例如&lt;a&gt;,&lt;body&gt;,&lt;html&gt;等，会自动替我们完成右侧标签的填充如：&lt;/a&gt;, &lt;/body&gt;, &lt;/html&gt;等。 Auto Rename Tag 前端神器，自动修改标签名，当我们修改一个标签时，自动修改对应的右侧标签。 Better Comments 美化注释，可以将我们的多行注释按照类别自动高亮，如： Bracket Pair Colorizer 开发神器，当使用多层括号嵌套时，自动将不同层次的括号设置成不同的颜色，防止配对时眼瞎。 CodeIf 变量起名神器，还在为起变量名发愁吗？使用它搜索一下，自动推荐合适的变量名，支持中文！ Excel Viewer 顾名思义，Excel 表格预览，数据分析党的神器，再也不用一个窗口看数据一个窗口写代码了。 ESLint前端神器，不解释。 JslintJSLint，JavaScript lint 工具，前端党必备。 jupyter vscode 中支持 jupyter，和 Python 插件对 jupyter 的支持类似。 leetcode 上班摸鱼、实验室摸鱼神器，再也不用担心刷题被老板看到了。 live server前端神器，可以在 vscode 中预览编写的网页。 Path Intellisense 编码神器，相对路径自动补全 Remote - SSH 开发神器，通过 vscode 以窗口的形式连接远程服务器，直接在 vscode 当中编写服务器代码！ Tabnine 开发神器，超强大的代码自动补全。 Terminal Here开发神器，在当前窗口打开 terminal，再也不用每次开 terminal 都要不停地 cd 了。 vscode-icons给你的 vscode 中文件夹、文件换上更好看的图标。 zhihu 摸鱼神器，年薪百万的秘密…… vscode当中好用的插件还有非常多，如果还知道什么其他神器的，可以在评论区留言。 【了解】GitHub 代码一键转 VS Code，太好用了！ VS Code 是一个由微软开发，同时支持 Windows、 Linux 和 macOS 等操作系统的免费代码编辑器，它支持测试，并内置了 Git 版本控制功能，同时也具有开发环境功能，例如代码补全、代码片段和代码重构等。 作为程序员常用的代码编辑器之一，VS Code 是一个可在所有平台上使用的开源、可扩展和轻量级的编辑器。这些品质使其大受欢迎，并成为 Python 开发的绝佳平台。 那么，有没有可能提供 GitHub 链接，直接在 VS Code 上查看 Repo 代码呢？ 近日，GitHub 上出现了这样一个项目，可以使用户直接在 VS Code 界面读取 GitHub 项目的代码，实现了 GitHub 项目与 VS Code 的无缝衔接。 这个项目名为 github1s，它的使用方法非常简单，只需要在浏览器地址栏 GitHub 网址链接中的「github 」后面添加 1s ，然后 Enter 键，即可在 VS Code 界面访问该项目的 Repo 代码。据项目主页显示，项目开发者来自百度。 项目地址：https://github.com/conwnet/github1s 以 GitHub 项目「时间序列数据分析 Python 库 Deeptime」(https://github.com/deeptime-ml/deeptime)为例，在浏览器地址栏输入该项目的网址，在「github 」后面添加「1s 」，如下图中红框所示： 然后回车键即可进入到 VS Code 界面，浏览该项目的相关内容。 这就是加「1s」的神奇力量！ 用户需要准备以下先决条件： 1234567891011git clone git@github.com:conwnet/github1s.git$ cd github1s$ yarn$ yarn watch$ yarn serve # in another shell$ # Then visit http://localhost:5000 once the build is completed.并构建：$ yarn$ yarn build Vscode笔记 通过在命令行输入 code . 使 vscode 打开文件夹Mac 打开 VS code 打开命令面板（ ⇧⌘P ） 输入 shell command 找到: Install &#39;code&#39; command in PATH 点击一下就 OK 了。 win（默认有 code-insiders . 新增 code .） 把 Code-insiders.exe 复制一份重命名 Code.exe 或者用 1gitbash 配置别名 echo &#39;alias code=&quot;code-insiders&quot;&#39; &gt;&gt; vim ~/.bashrc echo &#39;alias web=&quot;webstorm64&quot;&#39; &gt;&gt; vim ~/.bashrc source ~/.bashrc使别名立即生效 code .使用vscode打开当前文件夹 终端切换 左下角设置——&gt;功能——&gt;终端——&gt;External:Windows Exec配置好之后，打开终端，点击选择默认shell，选中后重新打开终端 cmdC:\\Windows\\System32\\cmd.exe gitbashD:\\Git\\git-bash.exe 调试技巧VSCode Debug功能按钮从左到右功能依次为： 按钮1：运行&#x2F;继续 F5，直接跳转到下一断点； 按钮2：单步跳过(又叫逐过程) F10，按语句单步执行。当有函数时，不会进入函数； 按钮3：单步调试（又叫逐语句） F11：当有函数时，点击这个按钮，会进入这个函数内； 按钮4：单步跳出 ⇧F11:如果有循环，点击该按钮，会执行到循环外面的语句； 按钮5：重启 ⇧⌘F5； 按钮6：停止 ⇧F5 VSCode launch.json常用变量 ${workspaceRoot}：VS Code当前打开的文件夹 ${file} ：当前打开的文件 ${relativeFile}：相对于workspaceRoot的相对路径 ${fileBasenameNoExtension}：当前文件的文件名，不带后缀，也即launch ${fileBasename}： 当前打开文件的文件名 ${fileDirname}： 所在的文件夹，是绝对路径 ${fileDirname}：文件所在的文件夹路径 ${lineNumber}：当前文件光标所在的行号 ${fileExtname}：当前打开文件的拓展名，如.json ${cwd}： 启动时任务运行程序的当前工作目录 ${workspaceFolder}：表示当前workspace文件夹路径 ${workspaceRootFolderName}：表示workspace的文件夹名 ${env:PATH}：系统中的环境变量 VSCode调试配置项说明 request：请求配置类型，可以为launch（启动）或attach（附加） 下面是launch 和 attach 类型共有的属性 1234567891011121314151617MDprotocol：设置调试协议auto： 尝试自动检测目标运行时使用的协议inspector 新的V8调试器协议，解决遗留版本的多数问题，node versions &gt;= 6.3 and Electron versions &gt;= 1.7.4legacy： 原始的v8调试器协议，node versions &lt; v8.0 and Electron versions &lt; 1.7.4.port：调试使用的端口address ：TCP/IP地址，用于远程调试localRoot： 远程调试时映射的本地地址remoteRoot： 远程调试时的远程目录地址sourceMaps： 默认为trueoutFiles ：当map文件不在js文件同目录时用于指定 sourceMaps的位置restart ：自动重启调试timeout： 配置自动附加的超时时间stopOnEntry： 自动断点到第一行代码处smartStep： 自动跳过未映射到源代码的代码skipFiles :[]String,指定跳过单步调试的代码trace ： 启用诊断输出 以下是特定于类型 launch(启动)的配置属性 123456789101112MDprogram： 指定调试入口文件地址args ： []String 传递给程序的参数,可在process.argv拿到cwd ：指定程序启动调试的目录 ,当vscode启动目录不是项目根目录，并且调试npm script时非常有用runtimeExecutable： 设置运行时可执行文件路径，默认是node可以是其他的执行程序，如npm、nodemonruntimeArgs： 传递给运行时可执行文件的参数,例如：runtimeVersion： 设置运行时可执行程序的版本，如果使用nvm，可以切换node.js版本env： 添加额外的环境变量envFile： 文件加载环境变量console： 配置终端可以是外部终端或者内部集成终端，默认值internalConsoleautoAttachChildProcesses： 跟踪调试对象的所有子过程，并自动附加到在调试模式下启动的子过程 调试内容来源 扩展 Settings Sync 只需要通过GistID:fc1481c83fb01baf1b818b817bec4e7a就可以同步更新已有的配置和扩展 .gitignore Generator 自动生成.gitignore文件 Auto Rename Tag 修改双标签如：div，会自动同步修改对应的闭合标签（开始标签、结尾标签） Babel JavaScript ES201x，React JSX，Flow和GraphQL的JavaScript语法突出显示。 Bash Debug 一个基于超赞bashdb脚本的bash调试器GUI前端（bashdb现在包含在软件包中）。 Better Comments 更好的注释扩展，将帮助您在代码中创建更人性化的注释。 Bracket Pair Colorizer 给括号上色的，如：((()))，闭合括号会有相同颜色，相邻括号颜色会有明显区分 Chinese (Simplified) 简体中文扩展 Code Runner 代码运行器，代码片段运行器。在单独JS文件上右键run code或Ctrl+Alt+N或F1-&gt;点击run code Community Material Theme 主题，ctrl+shift+p—&gt;color theme—&gt;输入Community按上下选择主题 Darcula Theme - WebStorm Edition 主题，ctrl+shift+p—&gt;color theme—&gt;输入WebStorm选择主题 Dart Dart Code通过支持 Dart编程语言扩展了VS Code，并提供了有效编辑，重构，运行和重新加载Flutter 移动应用程序和AngularDart Web应用程序的工具。 Debugger for Chrome Chrome调试 Docker Docker扩展使从Visual Studio Code轻松构建，管理和部署容器化应用程序变得容易。它还提供了在容器内对Node.js，Python和.NET Core的一键式调试。 EJS language support EJS语言支持。注意：如果看不到任何样式，请将“ * .ejs”的文件关联设置为html Auto Import 对import自动导入（注意检查代码，有时候自动导入了乱七八糟的东西导致报错，需要手动删除） ESLint 将ESLint集成到VS Code中。 Flutter 此VS Code扩展增加了对有效编辑，重构，运行和重新加载Flutter 移动应用程序的支持，以及对Dart编程语言的支持。 Flutter Helpers Flutter代码提示 Flutter Widget Snippets Flutter代码片段 Formatting Toggle 可以通过单击来打开和关闭格式化程序（漂亮，漂亮，…）。 GitLens — Git supercharged 内置到Visual Studio代码Git的能力。它可以帮助您通过Git责任注释和代码镜头一目了然地看到代码作者的身份，无缝地导航和浏览Git存储库，通过强大的比较命令获得有价值的见解，等等。 Gradle Language Support 字面意思，Gradle语言支持 HTML CSS Support 字面意思，html css语言支持（支持&#x3D;&#x3D;提示） Ignore files .gitignore引用gitignore和忽略文件，还支持：.npmignore、.dockerignore、.coffeelintignore、.slugignore、.atomignore、.hgignore、.vscodeignore、.eslintignore、.prettierignore、.stylelintignore Import Cost 计算imports、requires的包大小 IntelliSense for CSS class names in HTML 标签的class里面自动提示classname JavaScript (ES6) code snippets ES6代码提示 JavaScript Booster 当在JavaScript（或TypeScript&#x2F;Flow）中编辑代码时，此VS Code扩展提供了各种代码操作（快速修复）。只需注意左侧的灯泡，然后按一下它即可了解如何在光标下转换代码。 json2ts 可将JSON转换为TypeScript接口。您可以从VS Code中浏览和安装扩展。Ctrl+P通过键入来按并缩小列表命令的范围ext install json2ts。 LeetCode vscode支持LeetCode做题、搜题 licenser 快速创建许可文件，或插入许可注释，支持多语言 Live Server 字面意思，实时服务器 Live Share 实时分享，Microsoft Visual Studio实时共享 Markdown All in One Markdown对Visual Studio Code的支持，Markdown所需的全部功能（键盘快捷键，目录，自动预览等）。 Material Icon Theme 文件图标、文件夹图标、自定义文件夹颜色、文件夹主题、自定义图标的不透明度、自定义图标饱和度、自定义图标关联、文件关联、自定义SVG图标、文件夹关联、自定义SVG文件夹图标、语言协会 Material Theme vscode主题 Move TS - Move TypeScript files and update relative imports 移动包含TypeScript的TypeScript文件和文件夹，并更新其相对导入路径。 neuron Visual Studio Code的神经元，面向数据科学家的交互式编程体验 Node.js Exec 使用node.js执行当前文件或您选择的代码。 Node.js Modules Intellisense Visual Studio Code插件，可以自动完成导入语句中的JavaScript &#x2F; TypeScript模块。 npm Intellisense Visual Studio Code插件，可自动完成导入语句中的npm模块。 Output Colorizer VSCode日志输出着色器 Path Intellisense 路径智能感知 Live Sass Compiler vscode自动编译scss文件为css文件 Prettier - Code formatter 更漂亮-代码格式化程序 Remote - SSH Visual Studio代码远程-SSH Remote - SSH: Editing Configuration Files Visual Studio Code远程-SSH：编辑配置文件 SCSS Everywhere HTML、Svelte、Latte、Slim、Liquid、TSX/JSX、Haml、Elixir、Smarty、PHP、ERB、Javascript、CSS和SCSS的&#39;.class&#39;和&#39;#id&#39;完成。只需在模板或CSS/SCSS中声明类，然后在任何地方都可以看到它。（两个方向） SCSS Formatter SCSS格式化程序 SCSS IntelliSense SCSS智能感知 shell-format shell格式化 Swig(.tpl) Swig的简单语法着色和漂亮的代码片段。现在支持.tpl扩展名。 TypeScript Hero TypeScript Hero是一个vscode扩展，使您的生活更轻松。在编写大量代码时，TypeScript您可能需要vscode来组织导入。 TSLint eslit是JS/ES的，TSLint则是相对于TS的 Turbo Console Log 通过自动执行写有意义的日志消息的操作，此扩展使调试变得更加容易。 TypeScript Importer 在工作空间文件中自动搜索TypeScript定义，并提供所有已知符号作为完成项以允许代码完成。 TypeScript Toolbox 优化&#x2F;自动导入，生成吸气剂&#x2F;设置器和构造函数 Vetur 对vue友好支持，代码提示，高亮，格式化，整理&#x2F;错误检查，智能感知，调试等。 Visual Studio IntelliCode 为Python，TypeScript/JavaScript和Java开发AI辅助开发功能在Visual Studio Code，基于理解你的代码的上下文与机器学习相结合的见解。 Vue Peek 支持Vue快捷编辑，很方便 Vue.js Extension Pack Vue.js扩展包，该扩展包为Vue.js开发添加了功能。 Vue VSCode Snippets Vue代码提示 VueHelper 支持Vue快捷编辑，很方便 YAML 红帽的YAML语言支持 picgo 图床，支持markdown粘贴图片自动上传并生成链接 Browser Preview,在vscode中实现预览调试 Settings Sync 上传和拉取vscode 可以快速完成配置，自动安装相关扩展 搜索扩展并安装Settings Sync 拉取公共配置文件和扩展 安装好后会自动弹出 Setting Sync（或者 ctrl+shift+p 输入sync，找到sync:advanced options，然后点击—&gt;再点击打开设置） 第一次使用未配置过 点击LOGIN WITH GITHUB下面的Download Public Gist，粘贴你的 gist fc1481c83fb01baf1b818b817bec4e7a，回车即可 如果已配置（或修改gist） 在Environment Settings下面的Gist ID处修改ID，然后ctrl+shift+p 输入 sync，点击sync:download setting 上传配置文件和扩展 生成 1token 点击EDIT CONFIGURATION，然后去生成 github token 登录 github 并打开 https://github.com/settings/tokens 点击 Generate new token 输入账号密码 输入 Note 选择[*] gist Create gists 点击Generate token 配置 安装好后会自动弹出 Setting Sync（或者 ctrl+shift+p 输入 sync，找到sync:advanced options，然后点击—&gt;再点击打开设置） 第一次使用未配置过需要点击EDIT CONFIGURATION 如果你的 github 账号上传过，可以把老的Gist ID粘贴在Environment Settings处 将生成成功的token粘贴至Global Settings的获取令牌，失焦自动保存 如果没有自动上传生成Gist ID，手动shift+alt+u上传下 Environment Settings下面的选项全部勾了，当前设备会自动强制更新同步为Gist ID的最新配置扩展 配置和使用 命令面板(ctrl+shift+p)—&gt;输入 sync 即可查看相关设置 上传配置shift+alt+u ESlint 使用vscode-eslint 搜索安装或打开vscode-eslint点击安装 配置保存自动修复 1234567891011121314JS// 下面的设置为包括ESLint在内的所有提供程序打开“自动修复”：&quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll&quot;: true&#125;// 相反，此配置仅在ESLint上将其打开：&quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.eslint&quot;: true&#125;// 您还可以通过以下方式有选择地禁用ESLint：&quot;editor.codeActionsOnSave&quot;: &#123; // 除过 eslint 的项目都修复 &quot;source.fixAll&quot;: true, &quot;source.fixAll.eslint&quot;: false&#125; 项目安装npm安装eslint 初始化配置文件npm install eslint --save-dev &amp;&amp; npx eslint --init 打开进行配置：eslint官网doc 配置完之后通过此命令校验js文件：npx eslint src/**/*.js 配置参考如下： 1.eslintrc 123456789101112131415161718192021222324252627282930313233343536373839404142JS// 展示样式的规则 https://eslint.org/docs/rules/#stylistic-issues&#123; &quot;env&quot;: &#123; // 指定环境、指定全局、指定解析器选项、文档 https://eslint.org/docs/user-guide/configuring/language-options#specifying-environments &quot;browser&quot;: false, // 浏览器全局变量不需要支持 // var process: NodeJS.Process &#x27;process&#x27; is not defined. // var process: NodeJS.Process &#x27;process&#x27; is not defined. &quot;node&quot;: true, // Node.js全局变量和Node.js作用域。 // 添加所有ECMAScript 2021全局变量并将ecmaVersion解析器选项自动设置为12。 // es6 的解析器为 6 &quot;es2021&quot;: true &#125;, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 12, // 报错：Parsing error: &#x27;import&#x27; and &#x27;export&#x27; may appear only with &#x27;sourceType: module&#x27;eslint &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;rules&quot;: &#123; &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;], // 结尾是否需要分号，never不要，always要 https://eslint.org/docs/rules/semi#require-or-disallow-semicolons-instead-of-asi-semi &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;,&#123; &quot;allowTemplateLiterals&quot;: true &#125;], // double 双引号 single 单引号 allowTemplateLiterals 支持es6`` https://eslint.org/docs/rules/quotes &quot;no-multi-spaces&quot;: &quot;error&quot;, // 禁止多个空格 https://eslint.org/docs/rules/no-multi-spaces#disallow-multiple-spaces-no-multi-spaces // 以下打开搜索名称即可 https://eslint.org/docs/rules/#stylistic-issues &quot;block-spacing&quot;: &quot;error&quot;, &quot;comma-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;], &quot;space-unary-ops&quot;: &quot;error&quot;, &quot;space-before-blocks&quot;: [&quot;error&quot;, &#123; &quot;functions&quot;: &quot;never&quot;, &quot;keywords&quot;: &quot;never&quot;, &quot;classes&quot;: &quot;never&quot; &#125;], &quot;space-before-function-paren&quot;: [&quot;error&quot;, &quot;never&quot;], &quot;space-in-parens&quot;: [&quot;error&quot;, &quot;always&quot;, &#123; &quot;exceptions&quot;: [&quot;[]&quot;] &#125;], &quot;no-multiple-empty-lines&quot;: [&quot;error&quot;, &#123; &quot;max&quot;:1, &quot;maxBOF&quot;: 0&#125;], &quot;lines-around-comment&quot;: [&quot;error&quot;, &#123; &quot;beforeBlockComment&quot;: true, &quot;allowClassStart&quot;: true &#125;], &quot;indent&quot;: [&quot;error&quot;, 2], &quot;arrow-body-style&quot;: [&quot;error&quot;, &quot;as-needed&quot;], &quot;arrow-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: false, &quot;after&quot;: false &#125;], &quot;arrow-parens&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;no-confusing-arrow&quot;: &quot;error&quot;, &quot;yield-star-spacing&quot;: [&quot;error&quot;, &quot;after&quot;], &quot;rest-spread-spacing&quot;: [&quot;error&quot;, &quot;never&quot;] &#125;&#125;// 可以参考这里的配置 https://www.cnblogs.com/520future/p/11038793.html ESlint+Prettier1、VScode搜索并安装这两个插件：ESlint Prettier 安装完成之后，按下ctrl+shit+p，输入setting.json，选择首选项：打开设置（json）回车 在设置中插入如下配置 1234567891011JS// eslint配置项，保存时自动修复&quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.eslint&quot;: true&#125;,// 默认使用prettier格式化支持的文件&quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,// 自动设定eslint工作区&quot;eslint.workingDirectories&quot;: [ &#123; &quot;mode&quot;: &quot;auto&quot; &#125;], 2、为你的项目安装以下插件 yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-config-prettier eslint-plugin-prettier --devor npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-config-prettier eslint-plugin-prettier --save-dev 3、新建eslint配置文件 在项目根目录下新建.eslintrc.js文件 写入如下内容 12345678910111213141516JSmodule.exports = &#123; parser: &quot;@typescript-eslint/parser&quot;, // 指定ESLint解析器 parserOptions: &#123; sourceType: &quot;module&quot;, // 允许使用导入 &#125;, extends: [ &quot;plugin:@typescript-eslint/recommended&quot;, // 使用@ typescript-eslint / eslint-plugin中的推荐规则 &quot;prettier/@typescript-eslint&quot;, // 使用eslint-config-prettier禁用一些与Prettier冲突的ESLint规则 &quot;plugin:prettier/recommended&quot; // 启用eslint-plugin-prettier和eslint-config-prettier，使编辑器显示错误提示，确保这项是扩展数组中的最后一个配置 ], rules: &#123; // 放置ESLint规则的位置。可用于覆盖从扩展配置中指定的规则 // 例如 &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;, &#125;,&#125;; 4、配置Prettier 这步是可选的，如果pretter的默认配置你觉得用着蛋疼，那么你可以在项目根目录下新建 1.prettierrc 修改它的配置，下面列举一些常用设置，全部为默认选项，请按需修改 12345678910111213JS&#123; &quot;printWidth&quot;: 80, //限制每行字符个数 &quot;tabWidth&quot;: 2, //指定每个缩进级别的空格数 &quot;useTabs&quot;: false, //使用制表符而不是空格缩进 &quot;semi&quot;: true, //在语句末尾打印分号 &quot;singleQuote&quot;: false, //使用单引号而不是双引号 &quot;trailingComma&quot;: &quot;es5&quot;, //多行时尽可能打印尾随逗号 &quot;bracketSpacing&quot;: true, //在对象文字中的括号之间打印空格 &quot;arrowParens&quot;: &quot;always&quot;, //始终给箭头函数的参数加括号 &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;, //指定HTML文件的全局空格敏感度 &quot;endOfLine&quot;: &quot;lf&quot; //检测换行符类型，如果出现大量换行符报错，可以修改为auto不检测&#125; 更多配置可参考Pretter文档 5、其它 如果还想配置vue、react文件相关的格式化，可以参考下面的说明https://github.com/prettier/eslint-config-prettier 抄的这里的，版本升级比较快，这里可以做下参考，一般只需要配置eslint就可以了，两个一起配置会冲突，解决比较麻烦。 Using ESLint and Prettier in a TypeScript Project .gitignore GeneratorVSCode 使用 .gitignore Generator 生成 .gitignore 文件 搜索安装.gitignore Generator ctrl+shift+p 输入：Generate .gitignore File 选择 确定 or 选择 创建 确定 or 选择 更新 确定 GitLensGitLens可以帮助您更好地理解代码。快速查看更改行或代码块的对象，原因和时间。回顾历史，以进一步了解代码的演变方式和原因。毫不费力地探索代码库的历史和演进。 搜索安装即可或点开安装GitLens Import Cost计算 imports&#x2F;requires 的大小显示在包后面 安装 Import Cost 目前支持： 默认导入：import Func from &#39;utils&#39;; 整个内容导入：import * as Utils from &#39;utils&#39;; 选择性导入：import &#123;Func&#125; from &#39;utils&#39;; 选择性导入别名：import &#123;orig as alias&#125; from &#39;utils&#39;; 子模块导入：import Func from &#39;utils/Func&#39;; 要求：const Func = require(&#39;utils&#39;).Func; 同时支持Javascript和Typescript Live Sass CompilerVSCode 配置自动编译 Sass 安装扩展：Live Sass Compiler 监听 .scss 文件自动编译为 css 文件，非常方便 Node modules resolveVSCode对配置别名（alias）的支持代码中使用 @ (如：import &#123;util&#125; from &#39;@/utils/index&#39;)，鼠标放在 util 上面 按 ctrl ，点击后会定位到 utils&#x2F;index 搜索安装 Node modules resolve 配置 1jsconfig.json ， vscode doc 官网关于 jsconfig.json 说明 123456789101112JSON&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es2017&quot;, &quot;allowSyntheticDefaultImports&quot;: false, &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]&#125; Search node_modulesVS Code的简单插件，可让您快速浏览项目node_modules目录中的文件。可能是您node_modules从VS Code的内置搜索中排除了该文件夹，这意味着如果您想在其中打开和&#x2F;或编辑文件node_modules，则必须手动找到它，当node_modules文件夹很大时，这可能会很烦人。 搜索安装Search node_modules ctrl+shift+p—&gt;选择 search node_modules—&gt;输入包命（文件夹名称）—&gt;选择要打开的文件或文件夹 ctrl+n试试—&gt;输入包命（文件夹名称）—&gt;选择要打开的文件或文件夹 Turbo Console Log对 console.log 插入，注释，删除 搜索安装Turbo Console Log 插入有意义的日志消息 选择作为调试主题的变量 按Ctrl + Alt + L 多光标支持 注释当前文档中所有由扩展名插入的日志消息 要注释当前文档中扩展名插入的所有日志消息，只需按alt + shift + c 取消注释当前文档中扩展名插入的所有日志消息 取消注释当前文档中由扩展名插入的所有日志消息的全部操作是按alt + shift + u 从当前文档中删除所有由扩展名插入的日志消息 要从当前文档中删除所有由扩展名插入的日志消息，只需按alt + shift + d vueHelper输入 vue 快速生成模板结构 在vscode应用商店输入 oysun.vuehelper，点击安装(install) 打开 vue.json 方法1 文件-&gt;首选项-&gt;用户片段-&gt;输入 vue或vue.json(第一次打开显示 vue,后面打开就会是 vue.json(vue),不理解意思忽略)-&gt;回车 打开 vue.json 方法2 alt+f-&gt;p-&gt;s-&gt;s-&gt;enter-&gt;输入 vue或vue.json -&gt;enter 123456789101112131415161718192021JSON&#123; &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;vue&quot;, &quot;body&quot;: [ &quot;&lt;template&gt;&quot;, &quot; &lt;div&gt;$0&lt;/div&gt;&quot;, &quot;&lt;/template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;export default &#123;&quot;, &quot;&quot;, &quot;&#125;&quot;, &quot;&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;style&gt;&quot;, &quot;&lt;/style&gt;&quot; ], &quot;description&quot;: &quot;Log output to console&quot;\t&#125;&#125; picgoVSCode 上传图片到图床支持：从剪贴板上传图像、从资源管理器上传图像、从输入框上传图像 搜索安装&#x2F;或打开链接点击安装 picgo 首选项—&gt;设置—&gt;扩展—&gt;找到 1picgo 进行配置，具体参考文档 可参考 picgo 官网配置文档 可参考 《jsdelivr 各种加速，非常强大》 有 picgo+github 的配置说明 可参考 《vscode配置picgo实现图床自动上传》 快捷方式| 操作系统 | 从剪贴板上传图像 | 从资源管理器上传图像 | 从输入框上传图像 || — | — | — | — || Windows &#x2F; Unix | Ctrl + Alt + U | Ctrl + Alt + E | Ctrl + Alt + O || 操作系统 | Cmd + Opt + U | Cmd + Opt + E | Cmd + Opt + O | Browser Preview 预览通过扩展安装后，当前机器上还必须有chrome浏览器才能正常预览调试使用 docker 123的服务器是 Debian ，参考 Debian安装chrome 下载安装包：wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 开始安装：sudo apt install ./google-chrome-stable_current_amd64.deb 安装完成后刷新vscode即可使用","tags":["Vscode"],"categories":["Vscode"]},{"title":"免费常用的前端CDN库","path":"//","content":"免费常用的前端CDN库1️⃣https://www.jsdelivr.com/使用最为广泛的CDN了，除了有静态库的加速外，还有npmgithubWordPress加速，甚至还能加速你自己的GitHub库。不过21年年底，国内CDN备案给注销了，现在使用的是日本等周边的服务器，速度已经比不上以前了。 2️⃣https://cdnjs.com/CDNJS提供非常完整的 JavaScript 库，无论是热门或是冷门的一应俱全。若你觉得它们缺少哪些好用的函式库，也可以自行提交到网站里，通过审核后就 CDNJS 就会为你分流 js文件！唯一的缺点是国外的。 3️⃣http://staticfile.org/七牛云提供的CDN库，速度不错。 4️⃣http://cdn.bytedance.com/字节跳动静态资源库，CDN节点也非常多，值得推荐的国内站点，背靠字节跳动，质量也比较有保障。 5️⃣https://www.bootcdn.cn/bootcdn，国内节点众多，BootCDN 是猫云联合 Bootstrap 中文网 共同支持并维护的前端开源项目免费 CDN 服务，致力于为 Bootstrap、jQuery、React、Vue.js 一样优秀的前端开源项目提供稳定、快速的免费 CDN 加速服务。BootCDN 所收录的开源项目主要同步于 cdnjs 开源项目仓库。 6️⃣https://cdn.baomitu.com/原360前端库的资源，除了有静态库，还有Google字体库 7️⃣http://www.asp.net/ajaxlibrary/cdn.ashxMicrosoft ASP.net CDN，ASP.NET 开发团队推出的一个新的微软 Ajax CDN（Content Delivery Network，内容分发网络）服务，该服务提供了对 AJAX 库（包括 jQuery 和 ASP.NET AJAX）的缓存支持。该服务是免费的，不需任何注册，可用于商业性或非商业性用途。 Ps：微软出品，自然不会太差。虽然在国外，速度依然不会太慢（当然比不上国内的其他 cdn）。 8️⃣https://cdn.baomitu.com/原 360 前端静态资源库是由奇舞团支持并维护的开源项目免费 CDN 服务，支持 HTTPS 和 HTTP&#x2F;2，囊括上千个前端资源库和 Google 字体库。该站静态资源库数据均同步于 cdnjs 开源项目仓库。 9️⃣https://unpkg.com/unpkg 是一个内容源自 npm 的全球快速 CDN。它部署在 cloudflare 上，在大陆地区访问到的是香港节点。 它支持 h&#x2F;2 和很多新特性，如果不考虑网络延迟的原因，性能优化较为出色。在国内一些互联网公司也有镜像，例如知乎和饿了么。 国内 Unpkg 镜像目前找了对外的国内 Unpkg 有两个： 饿了么：https://npm.elemecdn.com/ 知乎：https://unpkg.zhimg.com/ 可用npm镜像jsDelivrhttps://cdn.jsdelivr.net/npm unpkghttps://unpkg.com/ unpkg 自建https://cdn.cbd.int npm elementhttp://npm.elemecdn.com/ cdn1.tianli0.tophttps://tianli-blog.club/jsd/ 处申请 cdn.afdelivr.tophttps://cdn.afdelivr.top/npm/包名@版本号/文件名 https://arcitcgn.cn/202.html 其他cdnbootcdnhttps://www.bootcdn.cn/ loli （cdnjs）https://cdnjs.loli.net/ Staticfilehttps://staticfile.org/ 75CDNhttps://cdn.baomitu.com/ 今日头条 CDNhttps://cdn.bytedance.com/ cdnjshttps://cdnjs.com/","tags":["其他技术栈"],"categories":["其他技术栈"]},{"title":"软件及网站推荐","path":"//","content":"Feem局域网文件传输神器： Feem 是一款局域网传输工具，支持 iOS、Android、Windows、macOS、Linux 系统之间互传文件和文字可以说是目前市面上最稳定速度最快的局域网传输工具，只要确保手机与电脑处于同一 Wi-Fi 就能跑满带宽，推荐作为日常局域网使用工具。 由于官网提供的下载方式国内无法下载，已提供国内网盘下载方式。iOS 手机通过：App Store 安装 或直接应用商店搜索：Feem 安装—- Feem 下载 官网：https://feem.io 免费文件存储分享服务汇总：日常文件存储可用：阿里云盘、天翼网盘 蓝奏网盘老牌免费网盘，下载速度快，文件永久保存。也是目前分享小文件最多的平台，最大文件限制 100m，可分享安卓应用或压缩包 https://lanzou.com 蓝奏分享链接如无法打开，可手动将网址修改为： lanzoup.com lanzoux.com musetransfer界面和以前的奶牛快传比较相似，可把 musetransfer 当作一个山寨的奶牛快传，最大可上传 10g 文件，可上传文件夹，有效期 7 天，登陆后文件最多可保存 1 年。上传下载可无需登录，速度国内满速，可作为临时分享文件利器。 https://musetransfer.com 分享链接 （移动端与电脑端一致，下载速度自测） https://musetransfer.com/s/myujzpmqy 分秒帧不限速、不限容量，下载速度快。分享的链接可在微信中打开，可设置密码和过期时间，且没有压缩。除了下载需微信扫码登录的缺点，其他都还不错。 https://mediatrack.cn 分享链接 （视频 &#x2F; 音频 &#x2F; 图片，无需登陆可直接预览，下载需要微信扫码） https://mdl.ink/lnISx2 123 网盘界面和阿里云盘相似度极高，可当作一个山寨阿里云盘，注册可获取 2t 空间，上传下载不限速，分享下载无需登录，没有限制分享类型（实测.mp4 文件无法分享）可设置分享时间，缺点是稳定性未知，且移动端优化不到位。 https://www.123pan.com 分享链接 （可分享除 mp4 外的其他类型文件，下载速度自测） https://www.123pan.com/s/ZAzA-pM8wh 轻文档最高上传 200m 文件，下载满速文件保存 24 小时，适合临时分享小文件。 http://qingwendang.com 小麦云链小麦云盘推出的文件直链服务，上传文件直接获取下载链接，文件有效期 7 天（稳定性未知） http://ftpod.cn 快文件国内上传下载速度快，适合临时传输文件，默认 10 分钟后删除文件，可以续期。 https://quickfile.cn 虫洞一个国外的安全文件共享网站，最大可上传 10G 的文件。 分享链接有效文件期 24 小时，适合临时分享一些私密文件，国内下载速度尚可。 https://wormhole.app gofile一个国外的文件存储网站，对文件大小没有限制，比较适合个人存储使用。定期下载可以保证文件永久存储，动态 IP 不定期下载则存储失效，作为分享工具仅适合临时传输文件，国内下载速度尚可。 https://gofile.io/welcome anonfilesanonfiles 是一个无限容量网盘，没有分享时间限制与下载限制。上传单文件最大 20g，速度国内不同地区较大差异。适合国外用户使用。 https://anonfiles.com 分享链接： https://anonfiles.com/LcnbE2Afu9/wallhaven-o31dk5_jpg 网页在线工具汇总： 文件传输 图片压缩 视频压缩 今日热榜 上班摸鱼 短视频解析 文本配音 PDF 压缩 做 Logo 加密解密 ocr 识别 pp 直连 在线笔记 电影网站 写简历 工具合集： 影视在线大全 音乐在线大全 短信接码网站 网盘加速方法 资源搜索引擎 图片无损放大 图片压缩网站 在线抠图大全 免费文件存储 免费图床大全 67 工具箱 国内在线分享服务 实用在线工具： 在线格式转换 加密格式音乐解锁 视频 AI 转换文本 兔二工具 在线 pdf 工具箱 AirPortal 空投快传 音乐剪辑 m3u8 下载 在线图标制作 网页托管 冷熊简历 域名查询 PotPlayer下载： 免费影音播放器 PotPlayer 是 Windows 平台知名的视频播放器。 PotPlayer 美化精简版，由极客下载提供，基于官方版本，美化图标、精简多余文件。 阿里云盘https://www.aliyundrive.com/s/w53asMpyvf2 蓝奏云盘https://lanzoup.com/b00tcipdi 分秒帧：无限视频存储平台： 如果你看到这段文字，说明视频挂掉。 云时代音视频生产，协作工具 支持极速传输的审片协作神器 随时随地审片协作无论在办公室还是移动状态，可随时通过小程序预览高清视频，进行审片协作。 自媒体或公司企业等\u0010组织可用分秒帧提供的审片协作批注功能。 个人用户可以把分秒帧当做一个 云存储空间无限，上传下载不限速的个人视频云盘。 超过 500M 的视频可通过网页版上传，微信小程序超过 500M 可能会无法上传。 官网：https://mediatrack.cn 装系统必看：纯净 Windows 系统 itellyou 十余年持续提供可靠的原版系统 win7 吻妻出品专注 win7 win10 吻妻出品专注 win10 Windsys Project 针对原版系统优化 当电脑系统没问题时可以将系统做备份，将备份拷贝至 u 盘或网盘中以备不时之需。 平时需要提前准备 U 盘启动，U 盘启动制作十分简单，仅需以下两步！ U 盘「16G 以上」 买个便宜的即可。 微 PE 工具箱 或 rufus 制作 U 盘启动。 当系统出现问题时，插上 u 盘在 BIOS（进入 BIOS 根据自己的硬件搜索，不同品牌进入 BIOS 方式不同） 在 BIOS 设置 u 盘启动为优先启动，进入 u 盘启动中将之前备份的系统还原即可。 U 盘中常备 网卡驱动 驱动精灵带网卡版或 360 驱动带网卡版 系统镜像 ghost 系统 或 原版纯净系统 正常电脑系统备份 日常可以灵活变通，在 U 盘启动制作完毕后，可以存放 ghost 系统镜像 + 原版系统 + 正常的系统备份到 U 盘中。 如无法开机（非硬件问题）需要重装系统，又没有提前制作 U 盘启动可以找一台能够连接 U 盘的电脑制作 u 盘启动，例如：网吧 上述操作如无法理解，直接找一个电脑店花钱解决。 免费在线影视网站合集：CCTV节目官网：http://tv.cctv.com/ 观看电视剧还需要flash，可以看央视节目片 吧 —- http://pbpb.tv —- 免费在线，影视剧（手机页面）新飞影视 —- https://www.9dan.cc —- 免费在线，影视剧南柯电影网：http://www.nkdyw.com/ 视频清晰度不太统一，有的1080P，有的720P 130个相见恨晚的超实用网站：搞学习CSDN： https://www.csdn.net/TED（最优质的演讲）：https://www.ted.com/谷粉学术： https://gfsoso.99lb.net/scholar.html大学资源网：http://www.dxzy163.com/简答题：http://www.jiandati.com/网易公开课：https://open.163.com/ted/网易云课堂：https://study.163.com/中国大学MOOC：www.icourse163.org网易云课堂：study.163.com哔哩哔哩弹幕网： www.bilibili.com我要自学网： www.51zxw.net知乎：www.zhihu.com学堂在线：www.xuetangx.com爱课程：www.icourses.cn猫咪论文：https://lunwen.im/iData（论文搜索）：www.cn-ki.net文泉考试：https://www.wqkaoshi.com 写代码GitHub：https://github.com/码云：https://gitee.com/源码之家：https://www.mycodes.net/JSON to Dart： https://javiercbk.github.io/json_to_dart/Json在线解析验证： https://www.json.cn/在线接口测试（Getman）：https://getman.cn/ 导航页（工具集）偷渡鱼：https://touduyu.com/小呆导航：https://www.webjike.com/index.html简法主页：http://www.jianfast.com/KIM主页：https://kim.plopco.com/精准云工具合集：https://jingzhunyun.com/兔2工具合集：https://www.tool2.cn/爱资料工具（在线实用工具集合）：www.toolnb.com工具导航：https://hao.logosc.cn/ 找图片https://pixabay.com/https://www.pexels.com/彼岸图网：http://pic.netbian.com/极像素（超高清大图）：https://www.sigoo.com/免费版权图片搜索：https://www.logosc.cn/so/","tags":["其他技术栈"],"categories":["其他技术栈"]},{"title":"记录 Vscode 插件","path":"//","content":"必备翻译（英汉词典）ID: codeinchinese.englishchinesedictionary说明：不依赖任何在线翻译 API，无查询次数限制。英语救星VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=CodeInChinese.EnglishChineseDictionary Chinese (Simplified) Language Pack for Visual Studio CodeID: ms-ceintl.vscode-language-pack-zh-hans说明：简体中文语言包VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans 颜色主题Dracula OfficialID: dracula-theme.theme-dracula说明：暗黑风格主题VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula Horizon ThemeID: jolaleye.horizon-theme-vscode说明：猛男粉配色主题VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=jolaleye.horizon-theme-vscode Nebula ThemeID: chirtlelovesdolls.nebula-theme说明：一款偏紫黑风格的颜色主题VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=ChirtleLovesDolls.nebula-theme 图标主题Material Icon ThemeID: pkief.material-icon-theme说明：材质图标主题VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme git 增强Git Emoji Commit 中文版ID: maixiaojie.git-emoji-zh说明：给 git 提交添加 emoji 表情VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=maixiaojie.git-emoji-zh Git GraphID: mhutchie.git-graph说明：git 图形扩展VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph Git HistoryID: donjayamanne.githistory说明：git 历史记录VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory git-commit-pluginID: redjue.git-commit-plugin说明：自动生成 git 提交信息VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=redjue.git-commit-plugin markdown 写作Markdown All in OneID: yzhang.markdown-all-in-one说明：md 语法增强插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one Markdown ImageID: hancel.markdown-image说明：md 中图片插入增强插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=hancel.markdown-image Markdown Preview EnhancedID: shd101wyy.markdown-preview-enhanced说明：更好的 md 预览插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced MarkdownFormatID: liushilive.markdownformat说明：针对 md 格式的格式化插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=liushilive.markdownformat markdownlintID: davidanson.vscode-markdownlint说明：md 语法规范化VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint markdown-formatterID: mervin.markdown-formatter说明：对 md 格式进行格式化VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=mervin.markdown-formatter 前端Auto Close TagID: formulahendry.auto-close-tag说明：自动闭合 html 标签VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag Auto Rename TagID: formulahendry.auto-rename-tag说明：自动同步修改 html 标签VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag open in browserID: techer.open-in-browser说明：在浏览器中打开文件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=techer.open-in-browser Live ServerID: ritwickdey.liveserver说明：实时预览静态文件的简易服务器VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer 其他Image previewID: kisstkondoros.vscode-gutter-preview说明：增强 vscode 中的图片预览插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview joplin-vscode-pluginID: rxliuli.joplin-vscode-plugin说明：直接在 vscode 中管理写作 joplin 文章VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin Open in TyporaID: cyberbiont.vscode-open-in-typora说明：在 Typora 中打开VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=cyberbiont.vscode-open-in-typora PicGoID: spades.vs-picgo说明：图床插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo Prettier - Code formatterID: esbenp.prettier-vscode说明：针对多种格式的格式化插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode TinyPNGID: andi1984.tinypng说明：非常棒的图片压缩插件VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=andi1984.tinypng vscode-hexo-utilsID: fantasy.vscode-hexo-utils说明：在 vscode 更加方便的使用 hexoVS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=fantasy.vscode-hexo-utils Better TOMLID: bungcip.better-toml说明：对 toml 格式文件添加高亮VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=bungcip.better-toml Local HistoryID: xyz.local-history说明：给文件添加本地历史记录VS Marketplace 链接：https://marketplace.visualstudio.com/items?itemName=xyz.local-history","tags":["Vscode"],"categories":["Vscode"]},{"title":"Hexo-QQ音乐排行-Netlify CMS","path":"//","content":"Hexo-QQ音乐排行-Netlify CMS 在 aplayer 上面增加了页面跳转、刷新会接着上一句继续播放、页面关闭其它页面继续播放功能 正在播放音乐的页面关闭后，下次打开浏览器也会接着上一句继续播放 发布了 npm 包 aplayer2 准备 获取音乐列表ID 打开QQ音乐PC客户端并登录，依次点击【音乐馆】【排行】【新歌榜】【批量操作】【全选】【添加到】【添加到新歌单】【输入歌单名并保存】 在左侧创建的歌单找到【歌单名】并单击，点击【分享】【复制链接https://c.y.qq.com/base/fcgi-bin/u?__=f346JO4t】 打开浏览器粘贴到地址栏https://y.qq.com/n/yqq/playlist/8037641642.html，音乐列表ID就是`8037641642` 配置 1\\_config.butterfly.yml`或者`\\themes\\butterfly\\_config.yml 12345678910# Inject the css and script (aplayer/meting)（******此处修改******）aplayerInject: enable: true per_page: trueCDN: # aplayer（******此处修改******） aplayer_css: //cdn.jsdelivr.net/npm/aplayer2/dist/APlayer.min.css aplayer_js: //cdn.jsdelivr.net/npm/aplayer2/dist/APlayer.min.js meting_js: //cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js 在\\_config.yml最下面添加 1234# 音乐aplayer: meting: true asset_inject: false 在任意(.md)文档中加入 12345# 配置参考文档：https://github.com/MoePlayer/hexo-tag-aplayer#meingjs-support-new-in-30# 音乐列表ID：8037641642（必填）# 服务：tencent（必填）# 类型：playlist（必填）&#123;% meting &quot;8037641642&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125; 在\\_config.yml最下面添加 1234# 音乐aplayer: meting: true asset_inject: false 在任意(.md)文档中加入 12345# 配置参考文档：https://github.com/MoePlayer/hexo-tag-aplayer#meingjs-support-new-in-30# 音乐列表ID：8037641642（必填）# 服务：tencent（必填）# 类型：playlist（必填）&#123;% meting &quot;8037641642&quot; &quot;tencent&quot; &quot;playlist&quot; %&#125; 如何在整站配置？修改文件themes\\butterfly\\layout\\includes\\layout.pug 123456789101112131415if !page.meting // !page.meting 加上后，可以单独页面关闭音乐；改为 page.meting ，可在页面中单独开启 div#aplayerBox( class=&quot;aplayer aplayer-tag-marker meting-tag-marker&quot; data-id=&quot;8037641642&quot; data-server=&quot;tencent&quot; data-type=&quot;playlist&quot; data-mode=&quot;circulation&quot; data-autoplay=&quot;false&quot; data-mutex=&quot;true&quot; data-listmaxheight=&quot;340px&quot; data-preload=&quot;auto&quot; data-theme=&quot;#f7630c&quot; data-storagename=&quot;QQ新歌排行榜&quot; data-fixed=&quot;true&quot; ) 1234567891011121314---title: hexo-butterfly播放QQ新歌排行榜音乐date: 2020-12-29tags: - musiccategories: - hexoexcerpt: 在 aplayer 上面增加了页面跳转播放、页面关闭其它页面继续播放功能、发布了 npm 包 aplayer2cover: https://d33wubrfki0l68.cloudfront.net/5997a40576f3beca7bbbd86fe79a795e9d520d8e/87f88/themes/screenshots/landscape.pngmeting: true # 配合使用 !page.meting ---&#123;% meting &quot;8037641642&quot; &quot;tencent&quot; &quot;playlist&quot; &quot;theme:#f7630c&quot; &quot;storagename:QQ新歌排行榜&quot; %&#125; 还有一种整站配置方法123inject: bottom: - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;000PeZCQ1i4XVs&quot; data-server=&quot;tencent&quot; data-type=&quot;artist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-preload=&quot;none&quot; data-autoplay=&quot;true&quot; muted&gt;&lt;/div&gt; Hexo Netlify CMS我们都知道，hexo是一个静态部署博客的框架，优点在于速度快，成本低（无需服务器），缺点在于繁琐，你每次更新文章都需要去改代码，再部署推送，修改配置也是如此，你不能像WordPress一样直接在后台修改配置并使它生效。 不过有很多教程可以让你无需繁琐的部署，只管推送代码，通过GitHub Actions，travis-ci，vercel，Netlify等都可以便捷的进行博客的部署，只管写代码然后推送就好，类似的教程有非常多，在此就不再重复介绍。那么，我们是否可以在此基础上，更加便捷的进行静态博客的写作和管理？答案是可以的。 我们可以通过将博客部署到Netlify，并使用Netlify cms来做到这一点。 首先，我们来了解一下配置完之后可以做到哪些事情？ 在线新建，编辑，预览，删除博客文章 支持文章草稿，工作流 支持对博客图片的管理 支持在线修改博客配置，例如对首页顶部图的修改，友链的修改 🎈 图片预览配置完的界面 在线对文章进行编辑，修改 工作流 对媒体资源的管理 对其他页面的修改 在线修改博客首页、文章页、归档页等页面的顶部图 在线添加、编辑友链页面 🔗 在线演示为了更加直观，做了一个已经配置完毕的博客，你可以在线体验上述功能 👉点我查看 📃 简单说明下面我将会以hexo+fluid 主题做演示，并配置fluid 主题的友链功能，达到在线编辑预览友链的目的，但此方法不仅仅只适用于fluid 主题的友链功能，其他各类主题也可以通过此方法达到在线修改配置的目的，只要你配置完成，几乎可以修改所有配置项。包括但不限于以下类型的文件yml、yaml、toml、json、md、markdown、html具体请查看 👉Netlify cms文档。 🔧 具体配置Netlify cms使用的前提条件是你必须将博客部署到Netlify上。因为网上有很多部署教程，这里不再重复。 具体可以查看： 博客通过 Netlify 实现持续集成 将 Hexo 静态博客部署到 Netlify 👟 准备工作在部署完成后，你需要开启Identity 进入设置中 将Registration preferences修改为Invite only此项为是否开启注册，默认是开启注册。修改为Invite only后表示仅受邀请的用户可以注册，当然此项你可以在自己注册完毕之后再行修改。 下滑找到Git Gateway并开启。 至此准备工作完成 🎨 修改博客配置 在博客根目录中找到_config.yml并修改，这一步是跳过文件夹渲染，不然后面会出错 1skip_render: admin/*Copy 在博客source文件夹中，创建admin文件夹，并新建两个文件index.html和config.yml 在index.html中添加以下内容 1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;x-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;white&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://identity.netlify.com/v1/netlify-identity-widget.js&quot;&gt;&lt;/script&gt; &lt;title&gt;魔王の领地&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script defer=&quot;true&quot; src=&quot;https://cdn.jsdelivr.net/npm/netlify-cms@2/dist/netlify-cms.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;Copy 在config.yml 中添加以下折叠内容 点我查看 请注意，这里我对fluid 主题进行了配置，例如banner_img、index_img等项目，不能正常使用请删除，如果你不是fluid 主题请根据实际情况对source\\admin\\config.yml配置进行修改，如果你和我一样是fluid主题，还需要将主题配置文件（/_config.fluid.yml）中的相对应的字段及其内容一并注释掉才能使其生效，类似于这样 并且创建source\\_data\\fluid_config.yml，将相关配置复制粘贴到里面（请根据此配置去主题配置文件中注释掉相对应的字段） 点我查看 请保持这样的格式，当然如果你对yml语法非常了解也可以自行修改 🤣 123456links: items: - title: # 博客名称 intro: # 博客描述 link: # 博客链接 avatar: # 博客logoCopy 🤣 完成说一下为什么不推荐直接修改根目录下的_config.fluid.yml因为通过Netlify cms在线修改配置文件后，仅会保留你已经在source\\admin\\config.yml中配置的选项，没有配置的选项会默认清空，按主题默认配置进行，你当然可以将所有选项进行配置，但是没必要，所以推荐通过source\\_data\\fluid_config.yml仅复制粘贴需要的选项进行修改配置。 至此Netlify cms配置就算完成了，只要推送代码，等待片刻，通过你部署在Netlify上的域名，加/admin/即可访问你的博客后台。 🚀 一键部署如果你感觉有点繁琐，或者怕配置出错可以直接使用我配置好的一键部署来快速搭建你的博客👉点击前往 ps: 即使是一键部署也不要忘记准备工作里的步骤，这很重要","tags":["Hexo"],"categories":["Hexo"]},{"title":"玩转全球最大同性交友网站-开源社区GitHub","path":"//","content":"玩转全球最大同性交友网站-开源社区GitHub1. 你是否有过这样的需求? 刚接触github，被一堆菜单选项搞得头大， 不知道怎么玩 想做一个网站，发布到公网， 让所有的人都可以访问到 希望全面知晓github一个开源项目的结构，也能像其他大神一样，把github 玩转 所以，跟着学起来吧！ 2. GitHub介绍你需要的前置知识：GitHub 的基本操作 GitHub 是一个面向开源及私有软件项目的托管平台， 官网： https://github.com/ 被称为 “程序员的维基百科全书”被戏称 “全球最大同性交友网站” 以 Git 为唯一的版本库格式进行托管，故名 GitHub 注意: Git是一个版本管理工具，GitHub 是一个软件项目的托管平台(社区&#x2F;网站) GitHub 于 2008上线，除了 Git 代码仓库托管以外(界面方式)，还提供订阅、讨论组、在线文件编辑器、协作图谱、代码片段分享（Gist）等功能。 托管版本数量也是非常之多，知名开源项目 Ruby on Rails、jQuery、python 、Vue等。 2018 年 ，微软宣布，通过 75 亿美元的股票交易收购代码托管平台 GitHub 3. GitHub实战: 创建repository发布到公网，所有人能访问 效果：网站 https://xjsgithub.github.io/ 就会看到 好大的一只鲸鱼 3.1 步骤1 : 按照规范创建一个repository，【提示使用电子邮件，先创建一个github账号】，访问github，推荐使用谷歌浏览器， vpn，格式是 username.github.io 3.2 步骤2: 下载github desktop，并和 github账号关联 3.3 步骤3：创建本地 repository仓库 直接进 sign in to github.com 输入密码后，就可以登录，选择创建 repository 3.4 步骤4: 选择 username.github.io 的窗口，进行clone 3.5 步骤5: 将本地仓库上传到 GitHub clone后，进入到项目对应的文件夹(空的)，将你的项目源码文件拷贝到这里 会看到github desktop 有新的文件，先commit到本地仓库, 然后在进行publish branch（进上传到 github.com）, 这时你会看到github.com 你的username.github.io 有源文件加入了 3.6 步骤6: 访问网站 https://xjsgithub.github.io/ 就会看到 好大的一只鲸鱼 4. 申请顶级域名，并指向 https://xjsgithub.github.io/4.1 在阿里云、腾讯云、 GoDaddy或者 freenom 去申请域名，指向 https://xjsgithub.github.io/ https://www.aliyun.com/ https://cloud.tencent.com/ https://sg.godaddy.com/ https://www.freenom.com/ 4.2 在GitHub上设置你自己的域名即可 5. 看一个实际开源项目 jQuery5.1 界面 https://github.com/jquery/jquery github上的项目文档是 markdown编写 Watch: 关注项目变化，如被别人提交了 pull request、发起了issue等等，在你的通知中心，收到一条消息 Star: 类似微信朋友圈的点赞， 支持，让该项目更有热度. Fork: 得到一份原项目的拷贝，如果后续原项目改变，需要自己去处理同步 Branch: 分支 Tag: 标签 5.2 项目不同版本比较 https://github.com/jquery/jquery/compare 项目的url/compare 可以对不同版本比较，如图 比如可以看到有多少个文件的变化，有多少次commit 提示：直接使用 git工具也可以进行版本比较 5.3 issues issues —- 评论&#x2F;话题，对项目提出各种讨论，比如Bug、Build 、help wanted等，有各种问题都可以提 状态 Open : 讨论中 Closed：关闭，如已经解决 issues 可以增加开发者和使用者的交流，也可以创建一个issue 5.4 pull requests 简称pr，你如果要往该项目贡献代码，你可以在Github上发起一个Pull Request 如果被审核(code review)通过并正式合并，这样你就为项目做贡献了 5.5 Actions GitHub Action 是 GitHub 推出的一个 CI\\CD 服务 CI\\CD 其实是：持续集成、持续交付、持续部署 一般我们把GitHub当做代码仓库或者版本管理工具来用，有 GitHub Action 以后，能做的事情就更多，比如在 master 分支上提交了一段代码， GitHub Action 可以自动部署到指定的服务器上去，还可以把代码做成镜像，将镜像自动提交到镜像仓库里 5.6 Projects GitHub 上的项目板【需要权限】 帮助组织工作和排列工作的优先级。 项目板可以灵活地创建适合需求的工作流程。 项目板包括议题、拉取请求和注释，在选择的列中分类为卡片 拖放或使用键盘快捷键对列中的卡片重新排序，在不同列之间移动卡片，以及更改列的顺序 5.7 Wiki 维基百科（Wikipedia） 可以把项目的方方面面进行说明，支持markdown 5.8 insights 项目的总体浏览相关统计信息 Contributors: 看到用户在相应日期中发送提交、添加代码、删除代码的大致数量 commits: 显示了一年收到的提交大致数量。可以判断某个仓库是否在积极更新 Code Frequency（频率）：显示了该仓库中代码行数的增加量和删除量。 Network（分支网络）: 显示包括克隆仓库在内的所有分支的提交。 Fork: 服务端的代码仓库克隆情况 5.9 settings 对仓库进行任何设置。用户必须有更改权限的设置(一般是自己的repository)才看到这个页面 修改仓库名称 Features： 更改Wiki和Issue的相关设置。如果想关闭某些功能，只要取消勾选相应复选框即可。 Merge Button: 设置合并代码方式 GitHub Pages: 每个Github账户都可以开一个自己的静态网站（域名为 username.github.io) Danger Zone: 用户可以将仓库改为私有或是变更仓库的所有者，甚至删除仓库本身。这里操作一定要谨慎","tags":["GitHub"],"categories":["GitHub"]},{"title":"jQuery自动触发事件与bootstrap/jQuery插件用法","path":"//","content":"jQuery自动触发事件与bootstrap&#x2F;jQuery插件用法jQuery自动触发事件：有些事件希望自动触发,比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。 语法： 123451、element.click();2、element.trigger();3、element.triggerHandler(&quot;event-type&quot;) jQuery事件对象：事件被触发，就会有事件对象的产生. 1element.on (events, [selector] ,function(event) &#123;&#125;) 阻止默认行为:event.preventDefault()或者return false 阻止冒泡: event.stopPropagation0 这个效果和web api中效果类似 jQuery对象拷贝：如果想要把某个对象拷贝(合并)给另外一个对象使用，此时可以使用$.extend()方法 语法: 1s.extend ( [deep], target, object1, [objectN]) 1.deep:如果设为true为深拷贝，默认为false浅拷贝 2.target要拷贝的目标对象 3.object1:待拷贝到第一个对象的对象 4.objectN:待拷贝到第N个对象的对象。 5.浅拷贝是把被拷贝数据中的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。 6.深拷贝，前面加true，完全克隆(拷贝的对象,而不是地址)，修改目标对象不会影响被考贝对象。 第五点浅拷贝解析：拷贝时是把拷贝对象中的复杂数据类型的地址传递到被拷贝的对象当中，当我们对拷贝对象或者被拷贝到对象的复杂类型地址的修改时机会对所有的拷贝对象数据进行修改 第六点深拷贝解析：拷贝时是将所有的数据拷贝到另外一个对象当中，因此再修改拷贝对象中的复杂数据类型数据时不会对拷贝对象中的数据造成任何影响 eg：浅拷贝案例 jQuery多库共存：问题概述: jQuery使用$作为标示符，随着jQuery的流行,其他js库也会用这$作为标识符，这样 一起使用会引起冲突。 客观需求： 需要一个解决方案，让jQuery和其他的s库不存在突，可以同时存在，这就叫做多库共存. jQuery解决方案: 1.把里面的$符号统一改为jQuery。比如jQuery(“div’) 2.jQuery变量规定新的名称:$.noConflict() 123var o = $.noConflict();o(&quot;span&quot;);利用这个方法一样可以获取到span这个标签 jQuery插件的使用 jQuery功能比较有限，想要更复杂的特效效果，可以借助于jQuery插件完成。 注意:这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件 JQuery插件常用的网站：1.jQuery插件库 jQuery插件库-收集最全最新最好的jQuery插件 jQuery之家 jQuery之家-自由分享jQuery、html5、css3的插件库 插件使用步骤: 1.引入相关文件。( jQuery文件和插件文件） 2.复制相关html、css、js(调用插件)。 1、制作瀑布流案例+页面懒加载效果 修改HTML结构内容即可 2、图片懒加载(图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载)以下页面正常只是需要载入时间。 3、全屏滚动案例（隐藏侧边滚动条，页面以一帧一帧的方式去展现） gilHub : https://github.corn/alvarotrigoffullPage.js 中文翻译网站:jQuery全屏滚动插件fullPage.js演示_dowebok","tags":["jQuery"],"categories":["jQuery"]},{"title":"使用Hexo和Github搭建个人博客","path":"//","content":"使用Hexo和Github搭建个人博客仅为个人经验总结，应该有更好的搭建方式。建议：最好至少要具备一定的前端知识。 准备工具在开始配置之前，需要下载以下几个程序： 1、Git 2、node 3、Typora （推荐，用来编辑博客，可用其他编辑器，也可搭建完成后再安装）建议直接到官网下载。 4、一个代码编辑器，推荐VScode，用于修改配置文件时使用。 开始配置windows10使用控制终端操作，快捷键：win+R，搜索cmd打开 1、安装node后可以通过如下命令检查是否安装成功： 12node -v #查看node版本``npm -v #查看npm版本 2、安装淘宝的cnpm npm install -g cnpm –registry&#x3D;http://registry.npm.taobao.org 检查版本： 1cnpm -v 3、安装hexo框架 1cnpm install -g hexo-cli 检查版本： 1hexo -v 4、在任意位置创建blog文件夹（名字也随意，不一定是blog），用来放本地博客的数据和文件。如我在H盘创建了blog，地址如：H:\\blog。 创建完成后，打开Git CMD（Git正确安装的话，应该在开始菜单内） 使用命令进入创建的这个blog文件夹，例如： 12C:\\Users\\cai&#x27;cheng&gt;H:H:\\&gt;cd blog\\ 无误后输入如下代码，进行配置（此步可能花费很长时间，如失败或退出，删除该这个blog文件夹，重来）： 1hexo init 待出现 “Start blogging with Hexo！”后，即代表成功。此时blog下会出现很多文件（大概八个），这就是以后操作博客的地方。 5、验证是否成功： 1hexo s #启动服务 （1）待出现提示”Hexo is running at http://localhost:4000. Press Ctrl+C to stop”后即代表成功，其他提示则错。 （2）打开浏览器地址栏输入localhost:4000，出现hexo的页面则代表你的blog创建成功，但这一步是本地预览，还未托管成功，别人在网上看不到。 注：如第（1）步成功，第（2）步失败，代表4000端口被占用，返回Git CMD先按Ctrl+C退出服务，输入： 1hexo s -p 5000 #以5000端口启动服务 再在浏览器输入localhost:5000，就能进入页面。 上传到Github Pages1、首先安装插件： npm install hexo-deployer-git –save 2、、在自己的Github主页创建一个新的repository。创建的repository的名字必须为 yourname.github.io。注意替换yourname。 3、设置Git的SSH。 回到博客根目录的git bash中，输入 12git config --global user.name &quot;yourname&quot;``git config --global user.email &quot;youremail&quot; 然后创建SSH,一路回车 1ssh-keygen -t rsa -C &quot;youremail&quot; 成功生成后一般会在C盘user文件夹里找到.ssh这个文件夹，里面的id_rsa.pub文件就是SSH密钥。 将这个密钥复制下来，在Github的SSH设置里面填入这个密钥，保存后才能部署成功 4、在本地hexo目录下的config_yml里定位到deploy编辑成如下格式，注意冒号有一个空格，必须严格按照格式填写。 12345YMLdeploy: type: git repository: http://github.com/yourname/yourname.github.io.git branch: master 5、需要部署时在博客根目录Git bush使用以下三件套命令： 123456YMLhexo clean #清除缓存hexo g #生成静态文件hexo d #推送到远端仓库 6、本地测试时在博客根目录Git bush使用命令： 1hexo s 出现Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.时则可以在浏览器打开http://localhost:4000进行测试。 如果在浏览器不能打开http://localhost:4000，则代表4000端口被占用，需要使用其他端口，以5000为例： 1hexo s -p 5000 #以端口5000进行本地测试。 本地测试时可以改动博客的代码或文件，仅需在浏览器刷新就能看到改动，因此更新博客时最好在本地测试无误后再上传。 编写博客并上传1、如果没安装，可以安装Typora了，这是一个常用的编辑器，具体功能自行探索。 2、安装好后，在blog根目录下打开Git Bush Here，（下文均默认此操作），输入新建文章命令： hexo n &quot;文章名&quot; #生成一篇文章 此时，会在source文件夹里的_posts文件夹里生成 “第一篇文章.md”的文件，双击它可调用Typora进行编写。 其中，title是文章标题，time是生成时间，tags是标签（没有tags暂时不管），然后是正文。编写完后即保存。 注：当你编辑一个新文件完成后，必须将此文件保存到&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;路径下，不然不能上传博客。 在Git Bush Here里面输入： 1hexo d 即可更新到github。 使用Vercel部署并绑定域名使用Vercel部署的好处一是快，二是每当push到github时，Vercel会自动同步，省去了手动部署的麻烦，部署完成还会发送邮件通知。 1、前往https://vercel.com/注册，注册时选择绑定github。 2、创建新项目，选择导入github的博客仓库。 3、在域名提供商处将域名解析到Vercel的DNS地址。 4、在setting里选择domain，填入自己的域名，确定。 5、过一会便能通过此域名访问博客。更新时只需要照常hexo d到github即可，Vercel会自动同步部署。 更改主题由于建立博客后的初始主题很难看，所以应当换个主题。不同的主题配置方式都不太相同，需要自己修改主题配置文件，所以需要自己去动手了解。官方主题网站：https://hexo.io/themes/ ， 选择好后跳转到github下载。好看的有butterfly，next等。以Jerry开发的主题butterfly为例： 在GitHub下载ZIP文件后（或者本地clone仓库），解压。 将文件夹复制到&#x2F;blog&#x2F;themes下，然后回到blog\\根目录下，用记事本打开_config.yml文件，在最后找到这三行代码： 12345YMLExtensionsPlugins: https://hexo.io/plugins/Themes: https://hexo.io/themes/theme: butterfly 将上方theme后的代码改为下载主题的 文件夹的文件名，其他不改，注意空格，如改为Next主题： 12345CODEExtensionsPlugins: https://hexo.io/plugins/Themes: https://hexo.io/themes/theme: Next 完成后点击保存。回到Git Bush Here输入： 12345CODEhexo g\t#生成hexo dhexo clean\t#清理hexo缓存hexo g --d #一键部署","tags":["Hexo"],"categories":["Hexo"]},{"title":"Hexo博客搭建指南","path":"//","content":"Hexo博客搭建超级指南环境部署工作2.1 安装Node.js1.进入官网选择对应的系统下载：官网：https://nodejs.org/en/download/2.安装选好路径，完成安装3.检查打开cmd或者powershell,输入: 12node -vnpm -v 显示版本号，即安装无误 npm为Node.js的包管理工具 2.2 安装Git1.进入官网下载官网：https://git-scm.com/downloads2.安装选好路径，完成安装3.检查打开git bash，输入： 1git --version 2.3 注册Github账号1.Github官网https://github.com,注册账号2.新建项目 项目名字为你的昵称.github.io，例如： 12//我的昵称是Justlovesmile所以我的项目名称为Justlovesmile.github.io 3.代码库设置 创建好之后，保存&lt;&gt;code内的SSH，即： 1git@github.com:XXXXXXXXX/XXXXXXXXX.github.io.git 点击右侧的Settings 向下找到Gihub pages,点击Launch automatic page generator，Github将会自动替你创建出一个pages的页面。 如果配置没有问题，大约几分钟之后，yourname.github.io这个网址就可以正常访问了 5.推荐开启强制使用https 2.4 安装Hexo1.在合适的位置，如E:/hexo，安装hexo-cli,输入： 12cd /e/hexo/npm install hexo-cli -g 再安装hexo 1npm install hexo --save 安装完成后，检查 1hexo -v 2.初始化一个文件夹： 123cd /e/hexo/hexo initnpm install 3.生成Hexo页面： 1hexo g 4.启动服务： 1hexo s 默认是localhost:4000，打开浏览器输入即可 2.5 推送到Github1.配置个人信息 12git config --global user.name &quot;XXXX&quot;git config --global user.email &quot;XXXXXXXXX@XXX.com&quot; 2.生成密钥 1ssh-keygen -t rsa -C &quot;XXXXXXXXX@XXX.com&quot; 3.查看id_rsa.pub文件，并整个复制 1cat ~/.ssh/id_rsa.pub 4.然后再在Github中添加ssh key 5.修改hexo根目录下的文件_config.yml中的deploy，添加之前保存的ssh： 12345deploy: type: git repository: github: git@github.com:Justlovesmile/Justlovesmile.github.io.git branch: master 6.上传到github： 1hexo d -g 如果没有hexo-deployer-git，安装 1npm install hexo-deployer-git --save 7.查看blog,https://username.github.io 3. Hexo基础3.1 写博客1.新建文章 12HAXEhexo new post &#x27;我的第一篇文章&#x27; 2.hexo自动生成一个md文件，修改md内容头部如： 12345678YAML---title: postName #文章页面上的显示名称date: 2020-03-10 12:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意冒号:后面有个空格description: 摘要--- 3.在头部下面即可写文章内容 markdown，支持html和其自带的语法。Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 3.2 新建页面12HAXEhexo new page &quot;music&quot; 会在source文件夹中生成music文件夹，其内的index.md为页面内容 3.3 常用基本命令1234567891011121314LIVECODESERVERhexo new &quot;文章&quot;hexo new post &quot;文章&quot;hexo new page &quot;页面&quot;hexo clean #清除缓存，每次重新部署时最好执行hexo g #生成静态页面hexo s #本地端口，默认4000运行hexo s -p 5000 # 端口5000hexo d #部署hexo deploy #部署1C#为了方便，每次准备推送时,可以👇hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 4. Hexo进阶4.1 推荐编辑器方便后续魔改内容 VSCode https://code.visualstudio.com/ Sublime Text http://www.sublimetext.com/ 4.2 更换主题1.因为自带的主题并不好看，所以可以更换主题，常见主题的很多，例如butterfly 123AWKcd /e/hexo/git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 2.修改hexo根目录下的_config.yml中的 theme: landscape改成theme： butterfly ,(注意冒号：后面有一个空格) 4.3 注册Coding账号1.由于国内访问github的速度较慢，因此可以通过双部署同时部署到Codinghttps://coding.net/，同样注册账号，新建项目，项目名随意2.创建好后，同样记住SSH3.修改hexo根目录下的文件_config.yml中的deploy，添加之前保存的ssh：例如我的： 1234567STYLUSdeploy: type: git repository: github: git@github.com:Justlovesmile/Justlovesmile.github.io.git coding: git@e.coding.net:justlovesmile/justlovesmile.top.git branch: master 4.在Coding中保存你的密钥，方法同Github 12ARCADEcat ~/.ssh/id_rsa.pub 5.下次hexo d -g部署后,开启静态网站，然后可以通过其提供的//xxxxxxx.coding-pages.com访问。（第一次记得点，立即部署） 6.推荐开启强制使用https 4.4 注册Gitee账号1.除了Coding外，网内访问速度较快的还有码云https://gitee.com/，同样注册账号，新建项目`yourname`2.创建好后，同样记住SSH3.修改hexo根目录下的文件_config.yml中的deploy，添加之前保存的ssh：例如我的： 12345678LESSdeploy: type: git repository: gitee: git@gitee.com:justlovesmile/justlovesmile.git coding: git@e.coding.net:justlovesmile/justlovesmile.top.git github: git@github.com:Justlovesmile/Justlovesmile.github.io.git branch: master 4.在Gitee中保存你的密钥，方法同Github 12ARCADEcat ~/.ssh/id_rsa.pub 5.开启GiteePages服务，Gitee只能免费使用gitee.io域名,其他的域名要收费，并且免费版每次部署后，需要手动点击更新来更新网站内容5.推荐开启强制使用https 4.5 绑定域名1.在阿里云https://wanwang.aliyun.com/购买自己喜欢的域名 2.在阿里云控制台找到云解析DNS 找到自己购买的域名,点击解析设置 添加记录 3.如果多部署了，可以设置多条 一条给github.io，一条给coding-pages.com等等 4.再返回到对应的部署页面，修改解析域名 Github的在仓库的Settings--Github_Pages--Custon_domain Coding的静态网站-设置-自定义域名 4.6 安装插件1.安装hexo插件 1234MIPSASMnpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-feed --save 2.在hexo根目录下的文件_config.yml中添加 12345678910DTSPlugins: # 在该区域添加两个插件名称 - hexo-generator-sitemap - hexo-generator-baidu-sitemap - hexo-generator-feed# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 3.更多插件见Hexo插件推荐 4.7 添加robots.txt1.在hexo根目录下的source文件夹中，创建一个名为robots.txt的文件2.内容为 123456789101112131415DTSUser-agent: * Allow: /Allow: /categories/Allow: /tags/Allow: /archives/Disallow: /js/Disallow: /css/Disallow: /images/Disallow: /img/Disallow: /lib/Sitemap: https://XXXXXXXXXXX.XXX/sitemap.xmlSitemap: https://XXXXXXXXXXX.XXX/baidusitemap.xml 4.8 创建百度站长账号1.进入百度站长https://ziyuan.baidu.com/，注册账号，登录2.点击用户中心-站点管理-添加网站 3.验证（1）若选择文件验证，则下载文件到根目录下的source文件夹中，并在文件内容最上面添加三行 1234YAML---layout: false--- （2）若选择HTML标签验证，需要找到主题下的head文件位置，添加其给的html代码，（一般在/themes/xxxxxx/layout/**/head.pug(ejs)内) （3）若选择CNAME验证，操作和绑定域名操作一样，看其给的说明即可 4.推送你的网址，使之更快收录点击左侧资源提交-普通收录可以选择三种方式提交网址 4.9 创建百度&#x2F;谷歌统计账号1.现在绝大部分国内主题集成了百度统计https://tongji.baidu.com/和[谷歌统计](https://search.google.com/)功能，如果没有可以自行在head文件内添加，和上面的html标签验证相似 12345678910XML&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?a2ee893562999ebad688b0d82daa100a&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; 其中问号?之后的一串数字为你的统计id 12INIhm.src = &quot;https://hm.baidu.com/hm.js?a2ee893562999ebad688b0d82daa100a&quot;; 2.谷歌同理，不过需要翻墙才能进去 4.10 CDN图床1.博客中往往会使用到很多图片，如果全部都保存在博客中，那肯定是不行的，推荐使用Github+Jsdelivr+PicGo搭建免费图床2.在Github中创建一个新仓库CDN，名字随意3.生成Token在右上角个人设置处（不是仓库设置）依次选择Settings-Developer settings-Personal access tokens-Generate new token，勾选repo，然后点击Generate token生成一个Token 注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 4.配置PicGo，使用jsDelivr的CDN(1)下载PicGo https://github.com/Molunerfinn/picgo/releases(2)设置仓库名(3)设置分支名(4)设置Token(5)指定存储路径(6)设定自定义域名 123VALA#每次上传后,生成图片路径自定义域名+/+储存路径+上传的图片名 5. 主题配置总结5.1 Ayer主题修改–适用ejs类型的主题5.1.1 随机博客封面Hexo博客美化之随机封面 5.1.2 添加二级菜单Hexo博客添加二级菜单 5.1.3 添加公告板Hexo博客美化之添加公告板 5.2 Butterfly主题–适用pug类型的主题 看Butterfly作者的教程https://butterfly.js.org/ 看小康博客https://www.antmoe.com/posts/a811d614/index.html 6. 主题魔改6.1 页脚养鱼🐟 摘取自木槿：Hexo大结局 1.在\\themes\\butterfly\\layout\\includes\\footer.pug最后添加这句话 1234567PLAINTEXT#jsi-flying-fish-container.containerstyle. @media only screen and (max-width: 767px)&#123; #sidebar_search_box input[type=text]&#123;width:calc(100% - 24px)&#125; &#125; 2.然后添加js文件，如果是butterfly在主题配置的inject处添加即可 12HTML&lt;script data-pjax src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN@latest/js/fish.js&quot;&gt;&lt;/script&gt; 3.修改样式，butterfly在themes\\butterfly\\source\\css\\_layout\\footer.styl，这一部分对应修改 1234567891011121314151617181920212223242526YAML#footer position: relative background: $light-blue background-attachment: local background-position: bottom background-size: cover if hexo-config(&#x27;footer_bg&#x27;) != false &amp;:before position: absolute width: 100% height: 100% background-color: alpha($dark-black, .1) content: &#x27;&#x27;#footer-wrap position: absolute padding: 1.2rem 1rem 1.4rem color: $light-grey text-align: center left: 0 right: 0 top:0 bottom: 0 6.2 valine评论博客美化之valine 6.3 博客文章加密添加博客加密: 文章添加密码功能 6.4 打字机效果花里胡哨的打字机js Type.js打字机效果: 添加打字机效果 6.5 图标，动态图标，网页运行时间，全站黑白，鼠标点击特效，网页动态标题，樱花，音效博客中能用到的代码: 关于font awesome图标字体库，使用动态图标，添加网页运行时间，全站变黑白，鼠标点击特效，网页标题的动态效果，网页樱花特效，鼠标触动音乐特效 6.6 旋转小人，每日诗句博客中能用到的代码（二）: 添加旋转小人和每日诗句 6.7 展示pdfHexo竟然可以展示PDF 6.8 插件汇总Hexo插件总结推荐 6.9 前端禁止右键，F12，F5 在文件中添加以下代码 123456789101112131415HTML&lt;script&gt;function unmouse()&#123; document.oncontextmenu = new Function(&quot;return false;&quot;);\tdocument.onkeydown = document.onkeyup = document.onkeypress = function(event) &#123; var e = event || window.event || arguments.callee.caller.arguments[0]; if (e &amp;&amp; (e.keyCode == 123 || (e.keyCode == 116 &amp;&amp; e.type!=&#x27;keypress&#x27;))) &#123; e.returnValue = false; return (false); &#125;\t&#125;&#125;unmouse()&lt;/script&gt; 6.10 星空背景 星空和流星特效 6.11 动态分类条、标签条 动态分类标签条，自动获取全站分类与标签进行展示 6.12 提取图片主题色并修改字体颜色 如何提取图片主题色并自动选择标题字体颜色 7. 高级魔改7.1 Github Calendar Gitcalendar教程：基于Butterfly主题（去jquery）的gitcalendar3.0 7.2 首页磁贴Akilar：Categories Magnet 7.3 首页置顶轮播图 Akilar：Slider Bar 7.4 友链朋友圈 最后，本文章原创作者均来自网络。","tags":["Hexo"],"categories":["Hexo"]},{"title":"Hexo相关","path":"//","content":"Hexo相关的脚本：上传仓库：将D:\\Hexo\\Hexo改为自己的博客根目录即可，随后保存为.bat文件1234567@echo offD:cd D:\\Hexo\\Hexogit add .git commit -m &quot;github action update&quot;git push origin mainpause 指令说明： 第一条指令@echo off，关闭回显第二叫指令D:，切换到博客站点目录所在的盘符，我这里是D盘第三条指令cd D:\\Hexo\\Hexo，进入站点目录，我这里是D:\\Hexo\\Hexo第四条指令git add -A commit -m &#39;test&#39; git push推送到github第五条指令pause,暂停 刷新dns：由于某些情况可能暂时无法访问github，需要更改Hosts，更改完需要刷新DNS才会生效，保存为.bat文件123@echo offipconfig /flushdnspause 新建文章：打开后输入文章名即可新建文章，将D:\\Hexo\\Hexo更改为自己的博客根目录即可，保存为.sh文件12345set -ecd &quot;D:\\Hexo\\Hexo&quot;read -p &quot;文章名称: &quot; titlehexo new $layout $titlecd - 本地预览：将D:\\Hexo\\Hexo更改为自己的博客根目录即可，保存为.sh文件12cd &quot;D:\\Hexo\\Hexo&quot;hexo S 清理缓存：将D:\\Hexo\\Hexo更改为自己的博客根目录即可，保存为.sh文件12cd &quot;D:\\Hexo\\Hexo&quot;hexo clean 根目录：如果要运行指令需要到跟目录右键打开git，简化操作，一键cd到更目录。将D:\\Hexo\\Hexo更改为自己的博客根目录即可，保存为.sh文件12cd &quot;D:\\Hexo\\Hexo&quot;exec /bin/bash hexo-butterfly美化：樱花飘落背景12cd theme/Butterfly/source/jswget https://yremp.live/wp-content/uploads/resource/js/sakura.js 把下载好的Js文件放在theme/Butterfly/source/js文件夹下/Butterfly/layout/includes文件夹下找到head.pug文件，在最后引入 12if theme.sakura.enable script(src=&quot;/js/sakura.js&quot;) 在主题的主配置文件加入Butterfly/_config.yml 123# 页面樱花飘落动效sakura: enable: true 浏览器标题恶搞在theme/Butterfly/source/js文件夹下添加crash_cheat.js文件填入以下内容记得要修改你喜欢的标题 12345678910111213141516var OriginTitle = document.title; var titleTime; document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/joke.ico&quot;); document.title = &#x27;看不见我🙈~看不见我🙈~&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/favicon.ico&quot;); document.title = &#x27; ( ๑•̀ㅂ•́) ✧被发现了～&#x27;; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 在Butterfly/layout/includes/layout.pug中添加以下代码来引入 1script(type=&#x27;text/javascript&#x27;, src=&#x27;/js/crash_cheat.js&#x27;) 注意因更新最新主题版本出现以下报错 1JQuery - $ is not defined 解决方式 引入以下js https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js 示例在inject: -&gt; bottom: 1- &lt;script src=&quot;https://cdn.jsdelivr.net/gh/weilain/cdn-photo/js/jquery.min.js&quot;&gt;&lt;/script&gt; 解决我了遇到的问题！ 添加标签云使用命令进行安装插件 1cnpm install hexo-tag-cloud --save 打开Butterfly/layout/includes/widget/card_tags.pug文件，用下面内容将其替换掉，最好把之前的文件备份一下,防止后悔 123456789101112if site.tags.length .card-widget.card-tags .card-content .item-headline i.fa.fa-tags(aria-hidden=&quot;true&quot;) span= _p(&#x27;aside.card_tags&#x27;) script(type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;) script(type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;) #myCanvasContainer.widget.tagcloud(align=&#x27;center&#x27;) canvas#resCanvas(width=&#x27;200&#x27;, height=&#x27;200&#x27;, style=&#x27;width=100%&#x27;) != tagcloud() != tagcloud(&#123;min_font: 16, max_font: 24, amount: 50, color: true, start_color: &#x27;#999&#x27;, end_color: &#x27;#99a9bf&#x27;&#125;) 添加个性化板娘 由stevenjoezhang 魔改项目最简单引用方式在Butterfly/_config.yml中inject添加 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt; bottom: - &lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 添加访客地图前往 clustrmaps 网站注册一个帐号 找到 Free Tools 下面的 Website Widget, 点击 Get Map Widget 输入你的博客网址，点击 Next 根据你自己的喜好选择样式 Map widget 或 Globe Widget 找到如下代码，记住 src (****** 的部分): 1&lt;script type=&quot;text/javascript&quot; id=&quot;clstr_globe&quot; src=&quot;**********************&quot;&gt; 在 themes/butterfly/layout/includes/widget/ 文件夹新建 card_map.pug 文件，文件内容如下: 123456.card-widget.card-map .card-content .item-headline i.fa.fa-globe-asia(aria-hidden=&quot;true&quot;) span= _p(&#x27;aside.card_map&#x27;) script#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;此处填入你自己的代码&quot;) 编辑 themes/butterfly/layout/includes/widget/index.pug 文件，在你想要显示的位置插入以下代码: 12if theme.aside.card_map !=partial(&#x27;includes/widget/card_map&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;) 注意格式 编辑 butterfly/_config.yml 文件，在 card_webinfo 下面添加一行 card_map: true 编辑 themes/Butterfly/languages/zh-CN.yml 文件 (请根据你的网站语言选择)，找到 aside 下对应格式添加 card_map: 访客地图 (后面的文本可自定义) 如果不想显示，直接把 butterfly/_config.yml 文件的 card_map: true 改为 card_map: false 即可 页脚跳动的♥编辑博客根目录themes/Butterfly/layout/includes/footer.pug文件，将 1.copyright!= `&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125; By $&#123;config.author&#125;` 改为 1.copyright!= `&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt; $&#123;config.author&#125;` 将 1.copyright!= `&amp;copy;$&#123;nowYear&#125; By $&#123;config.author&#125;` 改为 1.copyright!= `&amp;copy;$&#123;nowYear&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt; $&#123;config.author&#125;` 编辑butterfly.yml文件 在inject-&gt;head下面添加如下内容： 1- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;&gt; Butterfly加载动画修改添加配置文件 在目录themes/butterfly/layout/includes/loading下添加loaded.ejs文件，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;% if (theme.preloader.enable) &#123; %&gt;&lt;div id=&#x27;loader&#x27;&gt; &lt;% if(theme.preloader.layout == &#x27;gear&#x27; ) &#123;%&gt; &lt;div class=&quot;outer_box&quot;&gt; &lt;div class=&#x27;loader_overlay&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;loader_cogs&#x27;&gt; &lt;div class=&#x27;loader_cogs__top&#x27;&gt; &lt;div class=&#x27;top_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;top_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;top_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;top_hole&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&#x27;loader_cogs__left&#x27;&gt; &lt;div class=&#x27;left_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;left_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;left_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;left_hole&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&#x27;loader_cogs__bottom&#x27;&gt; &lt;div class=&#x27;bottom_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;bottom_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;bottom_part&#x27;&gt;&lt;/div&gt; &lt;div class=&#x27;bottom_hole&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;p style=&quot;text-align:center&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;loading...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125; else if(theme.preloader.layout == &#x27;spinner-box&#x27;) &#123; %&gt; &lt;div class=&quot;loading-left-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;loading-right-bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;spinner-box&quot;&gt; &lt;div class=&quot;configure-border-1&quot;&gt; &lt;div class=&quot;configure-core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;configure-border-2&quot;&gt; &lt;div class=&quot;configure-core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;loading-word&quot;&gt;加载中...&lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;/div&gt;&lt;script&gt; var endLoading = function () &#123; document.body.style.overflow = &#x27;auto&#x27;; document.getElementById(&#x27;loader&#x27;).classList.add(&quot;loading&quot;); &#125; window.addEventListener(&#x27;load&#x27;,endLoading);&lt;/script&gt;&lt;% &#125; %&gt; 引入样式文件 &#96;&#96;&#96;spinner-box123风格样式文件 及默认 butterfly123主题加载： 123- gear风格样式文件 1234567将上面两行代码加到主题目录`_config _yml`下的`inject`中引入到页面找到 `themes/butterfly/layout/includes/`下的文件`layout.pug`,将代码 if theme.preloader !=partial('includes/loading/loading', {}, {cache:theme.fragment_cache}) 123替换为 if theme.preloader !&#x3D;partial(‘includes&#x2F;loading&#x2F;loaded.ejs’, {}, {cache:theme.fragment_cache}) 12345开启加载主题目录`_config _yml`中的 preloader: true 123替换为 preloader: enable: true layout: gear # gear, spinner-box 两种样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879### Hexo 博客之优雅使用阿里 iconfont 图标：Font Awesome 无论是 v4 还是 v5 图标都有一些局限性。因此不少小伙伴想到了使用阿里 iconfont 图标。然而很多小伙伴并不是前端这个专业，可能对使用图标存在一定的问题。因此创作这篇水文，帮助小伙伴解决无法引入阿里 iconfont 图标的问题。什么人能够使用？理论上来说任何主题任何驱动都可以。只要你的网页还是 HTML+CSS。引入并不是什么难事，这篇文章只是给小白看的，有相关经验或者大佬可以直接关掉这篇水文了。引入前的准备能够登录阿里 iconfont认识汉字及部分单词（content、class 等）具备一定的前端知识：了解什么是标签具备一定的前端知识：能够使用开发者工具具备一定的前端知识：能够找到相应的标签具备一定的前端知识：明白 css 的语法其他说明此教程理论上可以在任意主题（需自己具备一定的能力）使用，此主题只以 butterfly（版本：2.3.5）主题为例。### 建立项目进入[阿里 iconfont](https://www.iconfont.cn/) 寻找你想要添加的图标，并且添加到项目。1. 找到你想添加的图标（如果你不会找，可以直接关掉此文了。） 将你想要添加的图标点击 “添加入库” 按钮，也就是图中圈起来的图标。2. 添加至项目 点击右上角小购物车图标。这里会看到你刚刚添加的所有图标 接下来就是为你的图标创建一个项目，名称随意。创建完成后你将看到如下页面3. 生成在线链接 （font class 方式）点击 Font class 按钮然后生成链接。 如果使用 svg，那么请点击 symbol，然后生成链接。4. 查看链接 点击链接会看到一些 css 代码。将鼠标下拉会看到刚才你添加的样式。### 引入字体及样式引入字体样式其实就是把刚才的链接引入到博客中，可以直接使用阿里的链接，也可以下载下来。为了方便方便修改，我建议下载下来放到本地。同样以 butterfly 主题为例：1. 下载 右键另存为即可。路径选择 `\\themes\\Butterfly\\source\\css\\`2. 引入文件&gt; 不同主题引入外部 css/js 的方法都不相同，请参考你所使用主题引入外部样式的设置。&gt; 如果你不想自己创建而是想直接使用博主的，那么可以直接把链接换成：https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/iconfont.min.css。&gt;&gt; 图标库预览：https://www.antmoe.com/iconfont/1. 如果使用 svg 如果使用 svg 图标，那么需要在 css 样式表中加入如下样式。如果使用 FontClass，那么可以无视这一步 CSS.icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } 123456789### 开始使用 iconfont上述步骤全部完成后，那么接下来可以使用小图标了。### 个人信息栏的小图标–font 字体方式这里直接写阿里提供的样式即可。YAMLsocial: iconfont icon-bilibili: https://www.bilibili.com 123小图标如果你觉得小，可以自行修改。 CSS.icon-bilibili:before { content: “\\e600”; &#x2F;* 修改颜色 &#x2F; color: blue; &#x2F; 修改大小 *&#x2F; font-size: 24px;} 123这样修改会导致所有这个图标的大小都会变动。建议的方式是重新写一个 css，为其添加规则。设置时只需要多加一个 class 即可例如： CSS.icon-bilibili:before { content: “\\e600”;}&#x2F;* 卡片处小图标 &#x2F;.card_icon { &#x2F; 修改颜色 &#x2F; color: blue; &#x2F; 修改大小 *&#x2F; font-size: 24px;} 123设置时的方法： YAMLsocial: iconfont icon-bilibili card_icon: https://www.bilibili.com 12345### 个人信息栏的小图标–svg 方式svg 也称多色图标，由于不是通过类名，而是使用了 svg 标签，因此需要通过脚本的方式动态插入。例如： JAVASCRIPT$(“.card-info-social-icons”).append( ‘‘); 1234567891011其中两个空分别表示地址，例如 `https://www.antmoe.com`, 另外一个为图标名，例如`#icon-QQ`，名字根据你自己库来写，不是随便写的。### 标题美化处的修改butterfly 主题的标题标签前有一个图标，如何为其更改为阿里 iconfont 呢？通过开发者工具我们可以看到主题为前边小图标的样式：因此我们改动起来也很简单，只需要在刚才我们的 `iconfont.css` 文件中覆盖这个样式即可。 CSS#article-container h1:before,#article-container h2:before,#article-container h3:before,#article-container h4:before,#article-container h5:before,#article-container h6:before { font-family: “iconfont”; content: “\\e6a0”;} 12345678910111213141516171819此时就能看到图标已经发生了变化。[![img](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)](https://cdn.jsdelivr.net/gh/blogimg/picbed@latest/2020/05/07/f4993de6d089f3232aad38ea1bcd8f1f.png)&gt; 这里解释下代码，方便大家自行决策如何修改。&gt;&gt; `font-family` 是必须写的，因为作者的代码只写了 FontAwesome，因此需要覆盖他。&gt;&gt; `content` 可以不在 css 中写，这样可以在配置文件里定义内容。如果写了，会导致配置文件的设置失效。颜色设置同理.### 其他修改不管是什么主题，不管是什么样式。只要你想使用阿里的图标，必须改变其标签的字体为 `iconfont`, 接下来可以用伪类方式，也可以使用 class 方式。文章中使用 svg 也很简单，首先需要确保全局引用了 js。如果没有，在文中局部引入也是可以的。接下来只需要在需要的地方插入 svg 标签即可。 HTML &#96;&#96;&#96; 最后如果你遇到了如下问题，请向上查找解决方案. 修改图标大小及颜色 图标不显示 (无效果) 这种原因很多种，但如果你稍有常识就不会遇到. 不知道在哪改 在你创建的 css 文件中.","tags":["Hexo"],"categories":["Hexo"]},{"title":"Markdown高级教程","path":"//","content":"Markdown基础教程作为程序员，如果你不清楚 Markdown 估计没人敢相信，毫不夸张地说，Markdown 是目前世界上最受欢迎的标记语言之一，所以今天我就带领大家初步了解一下 Markdown 的魅力，带你快速上手 Markdown 什么是 MarkdownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的文本格式编写文档，Markdown 文件的后缀名为 .md，有如下显著特点： 1.专注于文字内容2.纯文本，易读易写，可以方便地纳入版本控制3.语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版 为什么要使用 Markdown很多小伙伴会有疑问，为什么要使用 Markdown 呢？其实，就当下互联网现状来看 Markdown 有如下 4 条显著特点 1.Markdown 无处不在。2.Markdown 是纯文本可移植的。3.Markdown 是独立于平台的。4.Markdown 能适应未来的变化。 常用的 Markdown 编辑器这里我结合自身的使用经验，推荐大家使用 Typora 编辑工具，或者使用 VS Code 安装 Markdown All in One 插件后使用。 还是那句话，作为学习氪金就没有必要了，Typora 使用 beta 版本学习足够了 Typora 的优点不用多说，支持各种定制化，只要你的前端技能足够牛，你可以按照需要开发各种各样的主题，Typora 都能够很好的渲染出来。 VS Code 更不用多说，宇宙最强编辑器之一。推荐在 VS Code 中编辑 Markdown 的原因有两个： 1.不用再安装别其余的应用2.更好的在 Gitee 或者 GitHub 中渲染，因为一些网站或者开发平台为了安全考虑不会支持太多的渲染。 也就是说，不同的 Markdown 编辑器都有不同的特性，能够支持的渲染也不同 基础语法简介标题要创建标题，只需要在语句前面添加 # 即可，# 的数量代表了标题的级别。例如，添加四个 #，表示创建一个四级标题（例如 #### Header&gt;） Markdown 语法 HTML # Header 1 &lt;h1&gt;Header 1&lt;/h1&gt; ## Header 2 &lt;h2&gt;Header 2&lt;/h2&gt; ### Header 3 &lt;h3&gt;Header 3&lt;/h3&gt; #### Header 4 &lt;h4&gt;Header 4&lt;/h4&gt; ##### Header 5 &lt;h5&gt;Header 5&lt;/h5&gt; ###### Header 6 &lt;h6&gt;Header 6&lt;/h6&gt; 注意还可以在文本下方添加任意数量的 &#x3D;&#x3D; 号来标识一级标题，或者 – 号来标识二级标题一般情况下，我们会考虑在 # 和标题之间添加一个空格 段落要创建段落，只需要用空白行将一行或多行文本进行分隔即可 Markdown 语法 HTML Hello world Coding change the world &lt;p&gt;Hello world&lt;/p&gt; &lt;p&gt;Coding change the world&lt;/p&gt; 注意在编辑 Markdown 时，一般不建议使用空格（spaces）或制表符（ tabs）缩进段落 换行要换行，一般使用 br 即可 强调1.加粗，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）2.斜体，要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）3.粗体和斜体同时使用，要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线 引用1.要创建块引用，请在段落前添加一个 &gt; 符号2.块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号 注意块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效 列表1.有序列表，在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始2.无序列表，在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表 代码1.行内代码，要将单词或短语表示为代码，请将其包裹在反引号 () 中2.转义反引号，要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号()中3.代码块，要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符，或者将其包裹在三个反引号 (&#96;&#96;&#96;) 中 分割线要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容 链接链接文本放在中括号内，链接地址放在后面的括号中，链接 title 可选 超链接 Markdown 语法代码：[超链接显示名](超链接地址 &quot;超链接 title&quot;) 图片要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本 插入图片 Markdown 语法代码：![图片alt](图片链接 &quot;图片 title&quot;) 注意如果要给图片增加链接，请将图像的 Markdown 括在方括号中，然后将链接添加在圆括号中 转义字符语要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 需要特别注意的是，在 Markdown 的块级元素和内联元素中， &lt; 和 &amp; 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML 内嵌 HTML 标签对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可 Markdown 高级使用教程注意 并非所有 Markdown 应用程序都支持扩展语法元素。您需要检查您的应用程序所使用的轻量级标记语言是否支持您要使用的扩展语法元素。如果没有，那么仍然有可能在 Markdown 处理器中启用扩展，本节我们以 Typora 作为 Markdown 编辑器来讲解 表格 创建表格要添加表，可以使用三个或多个连字符（---）创建每列的标题，并使用管道（|）分隔每列。 Markdown 代码如下： 1234| 表头1 | 表头2 | 表头3 || --- | --- | --- || data10 | data20 | data30 || data11 | data21 | data31 | 显示效果如下： 表头1 表头2 表头3 data10 data20 data30 data11 data21 data31 如果您觉得通过代码直接创建表格比较麻烦，那么我们也可以通过，Markdown 编辑器右键直接插入表格，也能设置对齐方式 对齐方式我们还可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（ : ），将列中的文本对齐到左侧，右侧或中心 Markdown 代码如下： 1234| 表头1 | 表头2 | 表头3 || :--- | :---: | ---: || data10 | data20 | data30 || data11 | data21 | data31 | 运行效果如下： 表头1 表头2 表头3 data10 data20 data30 data11 data21 data31 特别注意 我们可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（&#96;）中的单词或短语，而不是代码块）和强调我们不能添加标题，块引用，列表，水平规则，图像或 HTML 标签 代码块 创建代码块我们可以通过把行缩进四个空格或一个制表符来创建代码块，也可以通过在代码块的前后使用三个反引号（&#96;&#96;&#96;）或者三个波浪线（~~~）来创建代码块 Markdown 代码如下： 123456```&#123; &quot;name&quot;: &quot;Typora&quot;, &quot;version&quot;: &quot;beta&quot;&#125;``` 运行效果： 1234&#123; &quot;name&quot;: &quot;Typora&quot;, &quot;version&quot;: &quot;beta&quot;&#125; 语法高亮Typora 处理器支持代码块的语法突出显示，我们只需要在代码块的前三个反引号后面写上语言即可 Markdown 代码如下： 123456```json&#123; &quot;name&quot;: &quot;Typora&quot;, &quot;version&quot;: &quot;beta&quot;&#125;``` 运行效果如下： 1234&#123; &quot;name&quot;: &quot;Typora&quot;, &quot;version&quot;: &quot;beta&quot;&#125; 特别注意 不同的 Markdown 编辑器支持的代码高亮的语言种类不同，这边可以根据实际效果确认Markdown 被渲染到浏览器上时，不同的浏览器所能支持的语言也不同，也需要根据实际效果确认 脚注 脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳至页面底部的脚注内容 创建脚注在方括号（[^1]）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联在输出中，脚注按顺序编号。在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（[^1]:footnote）。 Markdown 代码如下： 12345脚注1[^1] 脚注2[^a][^1]: 这里是脚注 1 的解释[^a]: 这里是脚注 2 的解释 运行效果： 脚注1[^1] 脚注2[^a] [^1]: 这里是脚注 1 的解释[^a]: 这里是脚注 2 的解释 特别注意 并非所有的地方都能放置脚注，除列表，块引号和表之类的其他元素之外的任何位置 任务列表 任务列表使您可以创建带有复选框的项目列表。在支持任务列表的 Markdown 应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号 - 和方括号 [ ]，并在 [ ] 前面加上空格。要选择一个复选框，请在方括号 [x] 之间添加 x Markdown 代码如下： 123- [x] Action 1- [ ] Action 2- [ ] Action 3 运行效果： • Action 1• Action 2• Action 3 删除线 我们可以通过在单词中心放置一条水平线来删除单词。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号 ~~ Markdown 代码： 1~~Hi Jeremy~~ 运行效果： Hi Jeremy Emoji 表情 我们可以在 Markdown 编辑时通过复制粘贴的方式添加表情，或者通过表情码添加表情（表情码的前后需要分别添加一个冒号） Markdown 代码： 1:rocket: 运行效果： :rocket: 特别注意 不同的 Markdown 编辑器支持的表情不同，这边可以根据实际效果确认Markdown 被渲染到网站时，不同的浏览器、网站所能支持的表情也不同，也需要根据实际效果确认 完后总结了一下几乎所有的 emoji 表情，放置在了 GitHub 仓库，大家可以按需下载看一下 GitHub 仓库：https://github.com/JeremyWu917/Github-Markdown-Emojis 高级语法 下面还有一些更加高级的语法，我这边就不详细展开了，大家可以根据需要自己学习一下 公式Markdown 语法： 123$$ xxxxxxxxxx6 1\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 = \\begin&#123;vmatrix&#125; 2\\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\3\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\4\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp; \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\5\\end&#123;vmatrix&#125;6$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$ 运行效果： 横向流程图Markdown 语法： 123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 运行效果： 竖向流程图Markdown 语法： 123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 运行效果： 标准流程图Markdown 语法： 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 运行效果： 横向标准流程图Markdown 语法： 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 运行效果： UML 时序图 1Markdown 语法： 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 运行效果： UML 时序图 2Markdown 语法： 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 运行效果： UML 标准时序图Markdown 语法： 123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 运行效果： 甘特图Markdown 语法： 12345678910111213141516171819%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h 运行效果： 特别注意 不同的 Markdown 编辑器支持的不同，这边可以根据实际效果确认Markdown 被渲染到网站时，不同的浏览器、网站所能支持的也不同，也需要根据实际效果确认 自定义样式您可以利用 HTML、CSS 在 Markdown 编辑器中实现各种各样的样式，我这边举个卡片的例子，旨在抛砖引玉 Markdown 语法： 12345678910&lt;section style=&quot;margin: auto; width:300px; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); text-align: center; border-radius: 10px; box-shadow: 04px8px0rgba(0, 0, 0, 0.2), 06px20px0rgba(0, 0, 0, 0.19); box-shadow: 0 0 20px #a812ff;&quot;&gt; &lt;img style=&quot;width:20%; height:20%;&quot; src=&quot;https://gitee.com/jeremywuiot/img-res-all/raw/master/src/iie_shop/tack_purple_128x128.png&quot;/&gt; &lt;img src=&quot;https://gitee.com/jeremywuiot/img-res-all/raw/master/src/iie_shop/logo_05.png&quot; style=&quot;width:100%; border: 1px solid #eee&quot;/&gt; &lt;br&gt; &lt;img style=&quot;width:15%; height:15%; position: relative; top: 5px;left: 0px;&quot; src=&quot;https://gitee.com/jeremywuiot/img-res-all/raw/master/src/iie_shop/tada.gif&quot; /&gt; &lt;section style=&quot;padding: 1px;&quot;&gt; &lt;p style=&quot;font-size:12px; color: #a812ff&quot;&gt;小城故事🎉&lt;/p&gt; &lt;p style=&quot;font-size:12px; color: #a812ff&quot;&gt;小城故事🙌&lt;/p&gt; &lt;/section&gt;&lt;/section&gt;","tags":["Markdown"],"categories":["Markdown"]},{"title":"Markdown基础教程","path":"//","content":"基础功能什么是Markdown Markdown是一种轻量标记语言,通过简单的语法，使普通文本具有一定的格式。文件后缀名一般为.md 注意：用到的符号必须在英文状态下输入才会生效 插入标题标题有两种写法： 方法一：在文字下方输入 - 或 = 构成的线: 123456MARKDOWN我展示的是一级标题=================我展示的是二级标题----------------- 输出结果： 标题1 方法二：在文字前面插入# 号，内容前面要有空格与#隔开： 1234567MARKDOWN# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 输出结果： 标题2 段落格式要求Markdown 换行挺讲究，会发现在编写的时候直接回车换行发现不生效，那怎么办呢？ 方法一：在段落最后使用加入&lt;br/&gt;标签实现换行。方法二：段落最后按两次回车，直接隔一行写。 例： 123MARKDOWN段落1&lt;br&gt; 段落2 1234MARKDOWN段落1段落2 字体效果改变字体形态相关写法 粗体和斜体使用的是 * 号和 下划线:_符号，符号数量不同效果不同下划线可以通过 HTML 的 &lt;u&gt;&lt;/u&gt; 标签来实现删除线只需要在文字的两端加上两个波浪线 ~~ 即可 123456789MARKDOWN*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___~~带删除线文本~~&lt;u&gt;带下划线文本&lt;/u&gt; 输出结果： 分隔线在一行中使用三个及以上的星号：*、减号：- 或 下划线: _。即可生成分隔线生成的分隔线样式根据主题而定。 1234567MARKDOWN***---******----------__________&lt;hr&gt; 输出结果： 列表Markdown 支持有序列表和无序列表。无序列表可使用星号:*、加号：+、减号-都可以，符号与内容要有空格隔开。有序列表直接数字+.即可,符号与内容要有空格隔开。 12345678910111213MARKDOWN* 无序列表项1* 无序列表项2+ 无序列表项1+ 无序列表项2- 无序列表项1- 无序列表项21. 有序列表12. 有序列表23. 有序列表3 输出结果： 列表嵌套写法：直接在第二行按Tab键或按四下空格缩进一下即可。 1234567MARKDOWN1. 第一项： - 第一项第一个 - 第一项第二个2. 第二项： - 第二项第一个 - 第二项第二个 输出结果： 引用区块在文本前面添加&gt; 符号即可将文本变为引用区块。 12MARKDOWN&gt; 文本内容 输出结果： 代码块可使用三个符号包裹住代码块，并指定一种语言即可生成代码预览区域。此符号一定要在英文状态下才能打出。 键一般位于Tab键上面、数字1键左边。 如果在文字行内插入代码块，可以在代码前后分别插入一个 符号即可。被包裹的文字会变成红色。 如： printf() ，效果：printf()&#96; 网址链接可直接在文章粘贴你的链接,如果网址太长可以使用格式[链接名称](链接地址) 123MARKDOWN链接写法1：https://cn.bing.com/链接写法2：[必应](https://cn.bing.com/) 输出结果： 链接写法1：https://cn.bing.com/链接写法2：必应 插入图片图片和链接插入方式都差不多，就是在前面多了个叹号：![图片描述](图片地址)，图片描述可写可不写图片地址可以是网址。也可以是本地文件名（文件需要存在，且路径正确）。 文章内如何引用本地图片文件：进入hexo的source/_posts目录后，会发现一个写文章内容的.md文件和一个同名的文件夹,把图片丢进文件夹里面就行，然后直接![图片描述](图片文件名)引用即可。 123MARKDOWN图片写法1：![](baidu.png)图片写法2：![百度](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png) 插入表格制作表格可使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。也可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 12345PLAINTEXT| 左对齐 | 右对齐 | 居中对齐 | 默认对齐 || :-----| ----: | :----: | ------ || 单元格 | 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 单元格 | 输出结果： 左对齐 右对齐 居中对齐 默认对齐 单元格 单元格 单元格 单元格 单元格 单元格 单元格 单元格 以上就是Markdown的一些基本写法。 原版高级功能支持 HTML 代码markdown是支持html且正常识别。因此，可以解锁更多自定义写法。 例：更改字体颜色： 1234HTML&lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt;&lt;font color=&quot;green&quot;&gt;绿色&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;蓝&lt;/font&gt; 输出结果： 红色 绿色 蓝色 可以去查阅Html的文档了解更多：菜鸟教程-HTML文档 转义字符如果在输出以下字符无法正常输出,可在字符前面加上反斜杠\\符号。例如我想正常输出” * “号，且不会被识别成格式控制符号，可以写为\\* 名称 字符 写法 反斜杠 \\ \\\\ 星号 * \\* 反引号 &#96; &#96;`&#96; 下划线 _ \\_ 花括号 { } \\&#123; \\&#125; 中括号 [ ] \\[ \\] 括号 ( ) \\( \\) 井号 # \\# 加号 + \\+ 减号 - \\- 点 . \\. 感叹号 ! \\! 竖线 | &#96; 竖线比较特殊，在markdown的表格内不能直接用反斜杠\\|转义，可使用html的字符代码|代替。 数学公式输出数学公式需要对应的插件支持。只需要用$符号把公式包裹起来就行。如果是复杂的公式则可以用两个 $$ 符号。 本主题是安装了MathJax 数学插件的，只需要在含有数学公式内容页面的Front-matter部分添加mathjax: true即可开启公式渲染。 1234567MARKDOWN行内公式（适用于简单公式）：$ x^2 + \\sqrt&#123;y&#125; = z $单独占一行(适用于复杂的公式)：$$\\frac&#123;d&#125;&#123;dx&#125;e^&#123;ax&#125;=ae^&#123;ax&#125;\\quad \\sum_&#123;i=1&#125;^&#123;n&#125;&#123;(X_i - \\overline&#123;X&#125;)^2&#125;$$ 输出结果： 行内公式（适用于简单公式）：x2+y&#x3D;z 单独占一行(适用于复杂的公式)： ddxeax&#x3D;aeax∑i&#x3D;1n(Xi−X―)2 由于公式的字符定义内容有点多，可能要单独写篇文章整合下。想知道更多公式字符定义或写法请自行上网搜索相关格式。 Hexo-Butterfly主题高级功能以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意。以下内容摘录于Butterfly主题官方配置教程。 自定义标签本主题提供了多种不同类型提示标签模块 用法1(预设图标和颜色) 用法2(自定义颜色和图标) 1234MARKDOWN&#123;% note [class] [no-icon] [style] %&#125;任何内容&#123;% endnote %&#125; 名称 用法和参数 class 【可选】图标样式，有不同图标和颜色 可用值： default &#x2F; primary &#x2F; success &#x2F; info &#x2F; warning &#x2F; danger no-icon 【可选】不显示图标，只显示对应的颜色。 可用值：no-icon 或 不写 style 【可选】标签的显示风格 可用值：simple &#x2F; modern &#x2F; flat &#x2F; disabled 把上面表格里的可用参数套入代码指定位置就行如果没指定参数，则输出markdown默认标签引用区块。 比如我想输出个class为warning,style为modern的标签块可这么写： 1234MARKDOWN&#123;% note warning modern %&#125;我是内容&#123;% endnote %&#125; 输出结果： 我是内容 相册相册分类盒子，带描述和背景图，实现跳转到某个页面功能，可用于相册页面主页。 1234PLAINTEXT&lt;div class=&quot;gallery-group-main&quot;&gt;&#123;% galleryGroup [name] [description] [link] [img-url] %&#125;&lt;/div&gt; 参数 作用 name 图库名字 description 图库描述文字 link 图库链接 img-url 封面图片链接,可以是网址，也可以是本地文件链接 可以同时嵌套多个galleryGroup,例： 12345PLAINTEXT&lt;div class=&quot;gallery-group-main&quot;&gt;&#123;% galleryGroup &quot;壁纸&quot; &quot;收藏的一些壁纸&quot; &quot;/Gallery/wallpaper&quot; &quot;/Gallery/01/5.jpg&quot; %&#125;&#123;% galleryGroup &quot;游戏&quot; &quot;一些游戏图片&quot; &quot;/Gallery/games&quot; &quot;/Gallery/02/5.jpg&quot; %&#125;&lt;/div&gt; 效果： Group Image Gallery 壁纸 收藏的一些壁纸 Group Image Gallery 游戏 一些游戏图片 相册图片自动排版Gallery相册会自动根据图片宽高进行排版，可用于相册子页面。 1234MARKDOWN&#123;% gallery %&#125;![图片描述](图片链接)&#123;% endgallery %&#125; 直接在gallery标签内使用markdown的插入图片语句: ![图片描述](图片链接) 就行，数量不限。例： 123456789MARKDOWN&#123;% gallery %&#125;![](/Gallery/02/1.jpg)![](/Gallery/02/2.jpg)![](/Gallery/02/3.jpg)![](/Gallery/02/4.jpg)![](/Gallery/02/5.jpg)![](/Gallery/02/6.jpg)&#123;% endgallery %&#125; 隐藏标签如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个有三种模式：inline 、 Block 、 Toggle。 标签内都不建议有 h1 - h6 等标题 因为会在文章目录会读取出来。 inline Block Toggle inline 就是直接在文本行内插入隐藏元素，只限文字, 12MARKDOWN&#123;% hideInline content,display,bg,color %&#125; 参数 作用 content 隐藏的文本内容 display 按钮显示的文字(可选)，不写则显示Click bg 按钮的背景颜色(可选) color 按钮文字的颜色(可选) content 不能包含英文逗号，可用‚代替。背景和颜色可以用Html的16进制表示，也可以用预设单词:blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green，不写则以默认样式输出。例： 123MARKDOWN奇变偶不变？ &#123;% hideInline 符号看象限,查看答案,black,#fff %&#125;1+1=? &#123;% hideInline 等于2 %&#125; 输出效果： 奇变偶不变？查看答案1+1&#x3D;? Click mermaid绘图插件使用mermaid标签可以绘製Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（饼图），具体可以查看: mermaid官方文档 1234MARKDOWN&#123;% mermaid %&#125;内容&#123;% endmermaid %&#125; mermaid标签不能嵌套在其他隐藏属性的标签里面，会导致输出异常。 查看mermaid官方文档，例如输出个流程图，可以这么写： 12345678MARKDOWN&#123;% mermaid %&#125;graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D;&#123;% endmermaid %&#125; 输出结果： graph TD; A–&gt;B; A–&gt;C; B–&gt;D; C–&gt;D; 由于mermaid内容有点多，可能要单独写篇文章整合下。想知道更多写法的可以先去网上搜索对应的教程或查看: mermaid官方文档 分页标签内容类型比较多可以使用，分页标签功能， 123456PLAINTEXT&#123;% tabs [Unique name], [index] %&#125;&lt;!-- tab [Tab caption] [@icon] --&gt;内容&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 参数 作用 Unique name 唯一名称，如果Tab caption 未指定，则输出唯一名称+序号,名称不能包含英文逗号:, index 默认展开的选项卡序号，从1开始，如果未指定，将选择第一个选项卡1，如果为-1,则选项卡全部折叠。 Tab caption 自定义选项卡的标题 @icon 设置自定义图标，仅支持 FontAwesome 图标名全称，名称前需要包含@符号 输出四个选项卡，唯一名称为：测试，默认展开第二个选项卡，可以这么写： 1234567891011121314151617181920MARKDOWN&#123;% tabs 测试,2 %&#125;&lt;!-- tab --&gt;我未指定选项卡名称&lt;!-- endtab --&gt;&lt;!-- tab 老二 --&gt;我设置了选项卡名称&lt;!-- endtab --&gt;&lt;!-- tab @fas fa-bomb --&gt;我的选项卡名称只有图标&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;我的选项卡名称包含文字和图标&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 输出结果： 测试 1 老二 炸弹 我设置了选项卡名称 按钮可以输出各式各样的按钮。 12MARKDOWN&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125; 参数 作用 url 链接，打开网址或位置 text 按钮的文字 icon [可选]按钮的图标，FontAwesome 图标名全称 color [可选]按钮颜色 可选值: blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green style [可选] 按钮样式，默认实心， 可选值: outline 或 留空 layout [可选] 按钮佈局 默认为line， 可选值: block 或 留空 position [可选] 按钮位置，前提是设置了layout为block 默认为左边。 可选值: center &#x2F; right 或 留空 size [可选] 按钮大小, 可选值:larger 或 留空 下面是各种按钮的写法，其他参数可以自己尝试： 12345678MARKDOWN默认样式按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge %&#125;更大的按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge,,larger %&#125;带图标的按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge,fas fa-bomb %&#125;红色的按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge,fas fa-bomb,red %&#125;不带图标红色的按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge,,red %&#125;默认空心按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge,,outline %&#125;红色空心按钮：&#123;% btn &#x27;https://guguge.top/&#x27;,Guguge,,red outline %&#125; 输出结果: 默认样式按钮：Guguge更大的按钮：Guguge带图标的按钮：Guguge红色的按钮：Guguge不带图标红色的按钮：Guguge默认空心按钮：Guguge红色空心按钮：Guguge 文本行内插入图片Markdown默认的插入图片会独占一行，本标签适用于插入一些尺寸较小的图片，例如表情包什么的。 12MARKDOWN&#123;% inlineImg [src] [height] %&#125; 参数 作用 url 图片链接 height [可选] 图片高度限制, 在文本内插入一张表情包，高度限制为：100px。实例： 12PLAINTEXT这是一张表情包： &#123;% inlineImg /blog/markdown/md11.jpg 100px %&#125; 文字底纹可以给一部分文字设置各种颜色的底纹。 12MARKDOWN&#123;% label text color %&#125; 参数 作用 text 文本内容 color [可选] 颜色,默认为 default 可选值：default &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green 实例： 123MARKDOWN&#123;% label 日照 red %&#125;香炉生&#123;% label 紫烟 purple %&#125;，遥看&#123;% label 瀑布 blue %&#125;挂前川。飞流直下&#123;% label 三千尺 orange %&#125;，疑是&#123;% label 银河 pink %&#125;落九天。 输出结果: 日照 香炉生紫烟 ，遥看瀑布 挂前川。飞流直下三千尺 ，疑是银河 落九天。 Markdown 大全 ⛅注意: 这是Markdown语法的简体中文版文档。如果您正在寻找英文版文档。请参考：Markdown: Syntax。 这份文件是用 Markdown 写的，你可以看看它的原始档 。 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 概述 哲学 行内 HTML 特殊字元自动转换 区块元素 段落和换行 标题 区块引言 清单 代码区块 分隔线 区段元素 连结 强调 代码 图片 其它 跳脱字元 自动连结 概述 哲学Markdown 的目标是实现「易读易写」。 不过最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文字發佈，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext] 1、[atx] 2、[Textile] 3、[reStructuredText] 4、[Grutatext] 5 和 [EtText] 6，然而最大灵感来源其实是纯文字的电子邮件格式。 因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像强调。Markdown 的清单看起来，嗯，就是清单。假如你有使用过电子邮件，区块引言看起来就真的像是引用一段文字。 行内 HTMLMarkdown 的语法有个主要的目的：用来作为一种网路内容的写作用语言。 Markdown 不是要来取代 HTML，甚至也没有要和它相似，它的语法种类不多，只和 HTML 的一部分有关系，重点不是要创造一种更容易写作 HTML 文件的语法，我认为 HTML 已经很容易写了，Markdown 的重点在于，它能让文件更容易阅读、编写。HTML 是一种發佈的格式，Markdown 是一种编写的格式，因此，Markdown 的格式语法只涵盖纯文字可以涵盖的范围。 不在 Markdown 涵盖范围之外的标签，都可以直接在文件裡面用 HTML 撰写。不需要额外标註这是 HTML 或是 Markdown；只要直接加标签就可以了。 只有区块元素──比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行，以利与内容区隔。而且这些（元素）的开始与结尾标签，不可以用 tab 或是空白来缩排。Markdown 的产生器有智慧型判断，可以避免在区块标签前后加上没有必要的 &lt;p&gt; 标签。 举例来说，在 Markdown 文件裡加上一段 HTML 表格： 123456789This is a regular paragraph.&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph. 请注意，Markdown 语法在 HTML 区块标签中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的*强调*。 HTML 的区段标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 则不受限制，可以在 Markdown 的段落、清单或是标题裡任意使用。依照个人习惯，甚至可以不用Markdown 格式，而採用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的连结或是影像标示语法。 HTML 区段标签和区块标签不同，在区段标签的范围内， Markdown 的语法是有效的。 特殊字元自动转换在 HTML 文件中，有两个字元需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 &lt; 和 &amp;。 &amp; 符号其实很容易让写作网路文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;T」 ，还得转换网址内的 &amp; 符号，如果你要连结到： 1http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转成： 1http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到连结标签的 href 属性裡。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。 Markdown 允许你直接使用这些符号，但是你要小心跳脱字元的使用，如果你是在HTML 实体中使用 &amp; 符号的话，它不会被转换，而在其它情形下，它则会被转换成 &amp;。所以你如果要在文件中插入一个着作权的符号，你可以这样写： 1&amp;copy; Markdown 将不会对这段文字做修改，但是如果你这样写： 1AT&amp;T Markdown 就会将它转为： 1AT&amp;amp;T 类似的状况也会發生在 &lt; 符号上，因为 Markdown 支援 行内 HTML ，如果你是使用 &lt; 符号作为 HTML 标签使用，那 Markdown 也不会对它做任何转换，但是如果你是写： 14 &lt; 5 Markdown 将会把它转换为： 14 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件裡面写出 HTML code。） 区块元素 段落和换行一个段落是由一个以上相连接的行句组成，而一个以上的空行则会切分出不同的段落（空行的定义是显示上看起来像是空行，便会被视为空行。比方说，若某一行只包含空白和 tab，则该行也会被视为空行），一般的段落不需要用空白或断行缩排。 「一个以上相连接的行句组成」这句话其实暗示了 Markdown 允许段落内的强迫断行，这个特性和其他大部分的 text-to-HTML 格式不一样（包括 MovableType 的「Convert Line Breaks」选项），其它的格式会把每个断行都转成 &lt;br /&gt; 标签。 如果你真的想要插入 &lt;br /&gt; 标签的话，在行尾加上两个以上的空白，然后按 enter。 是的，这确实需要花比较多功夫来插入 &lt;br /&gt; ，但是「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引言 和多段落的 清单 在使用换行来排版的时候，不但更好用，还更好阅读。 标题Markdown 支援两种标题的语法，[Setext] 1 和 [atx] 2 形式。 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果。 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# This is an H1## This is an H2###### This is an H6 你可以选择性地「关闭」atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字数量决定标题的阶数）： 12345# This is an H1 ### This is an H2 ##### This is an H3 ###### BlockquotesMarkdown 使用 email 形式的区块引言，如果你很熟悉如何在 email 信件中引言，你就知道怎么在 Markdown 文件中建立一个区块引言，那会看起来像是你强迫断行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引言可以有阶层（例如：引言内的引言），只要根据层数加上不同数量的 &gt; ： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引言的区块内也可以使用其他的 Markdown 语法，包括标题、清单、代码区块等： 12345678&gt; ## This is a header.&gt; &gt; 1. This is the first list item.&gt; 2. This is the second list item.&gt; &gt; Here&#x27;s some example code:&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何标准的文字编辑器都能简单地建立 email 样式的引言，例如 BBEdit ，你可以选取文字后然后从选单中选择增加引言阶层。 清单Markdown 支援有序清单和无序清单。 无序清单使用星号、加号或是减号作为清单标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序清单则使用数字接着一个英文句点： 1231. Bird2. McHale3. Parish 很重要的一点是，你在清单标记上使用的数字并不会影响输出的 HTML 结果，上面的清单所产生的 HTML 标记为： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的清单标记写成： 1231. Bird1. McHale1. Parish 或甚至是： 1233. Bird1. McHale8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的清单数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支援有序清单的 start 属性。 清单项目标记通常是放在最左边，但是其实也可以缩排，最多三个空白，项目标记后面则一定要接着至少一个空白或 tab。 要让清单看起来更漂亮，你可以把内容用固定的缩排整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你很懒，那也不一定需要： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果清单项目间用空行分开， Markdown 会把项目的内容在输出时用 &lt;p&gt;标签包起来，举例来说： 12* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是这个： 123* Bird* Magic 会被转换为： 1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 清单项目可以包含多个段落，每个项目下的段落都必须缩排 4 个空白或是一个 tab ： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩排，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&#x27;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在清单项目内放进引言，那 &gt; 就需要缩排： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩排两次，也就是 8 个空白或是两个 tab： 123* A list item with a code block: &lt;code goes here&gt; 当然，项目清单很可能会不小心产生，像是下面这样的写法： 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜线。 11986\\. What a great season. 代码区块和程式相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩排 4 个空白或是 1 个 tab 就可以，例如，下面的输入： 123This is a normal paragraph: This is a code block. Markdown 会转换成： 1234&lt;p&gt;This is a normal paragraph:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;This is a code block.&lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩排（4 个空白或是 1 个 tab），都会被移除，例如： 12345Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： 123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beepend tell&lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩排的那一行（或是文件结尾）。 在代码区块裡面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要複製贴上，再加上缩排就可以了，剩下的 Markdown 都会帮你处理，例如： 123&lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; 会被转换为： 1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线你可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号中间插入空白。下面每种写法都可以建立分隔线： 123456789* * *********- - ---------------------------------------- 区段元素 连结Markdown 支援两种形式的连结语法： 行内和参考两种形式。 不管是哪一种，连结的文字都是用 [方括号] 来标记。 要建立一个行内形式的连结，只要在方块括号后面马上接着括号并插入网址连结即可，如果你还想要加上连结的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 会产生： 12345&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果你是要连结到同样主机的资源，你可以使用相对路径： 1See my [About](/about/) page for details. 参考形式的连结使用另外一个方括号接在连结文字的括号后面，而在第二个方括号裡面要填入用以辨识连结的标签： 1This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上空白： 1This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标签的连结内容定义出来： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 连结定义的形式为： 方括号，裡面输入连结的辨识用标签 接着一个冒号 接着一个以上的空白或 tab 接着连结的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种连结的定义都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &#x27;Optional Title Here&#x27;[foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的连结 title。 连结网址也可以用方括号包起来： 1[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩排，网址太长的话，这样会比较好看： 12[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生连结的时候用到，并不会直接出现在文件之中。 连结辨识标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个连结是一样的： 12[link text][a][link text][A] 预设的连结标签功能让你可以省略指定连结标签，这种情形下，连结标签和连结文字会视为相同，要用预设连结标签只要在连结文字后面加上一个空的方括号，如果你要让 “Google” 连结到 google.com，你可以简化成： 1[Google][] 然后定义连结内容： 1[Google]: http://google.com/ 由于连结文字可能包含空白，所以这种简化的标签内也可以包含多个文字： 1Visit [Daring Fireball][] for more information. 然后接着定义连结： 1[Daring Fireball]: http://daringfireball.net/ 连结的定义可以放在文件中的任何一个地方，我比较偏好直接放在连结出现段落的后面，你也可以把它放在文件最后面，就像是註解一样。 下面是一个参考式连结的范例： 123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用连结名称的方式写： 123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 1234&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内形式写的同样一段内容的 Markdown 文件，提供作为比较之用： 123I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的连结其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字元，但是用行内形式的连结却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文字还要多。 使用 Markdown 的参考式连结，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的资讯移到段落文字之外，你就可以增加连结而不让文章的阅读感觉被打断。 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 会转成： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： 1un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： 1\\*this text is surrounded by literal asterisks\\* 代码反引号把它包起来（`），例如： 1Use the `printf()` function. 会产生： 1&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： 1``There is a literal backtick (`) here.`` 这段语法会产生： 1&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： 123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` 会产生： 123&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和方括号都会被转成 HTML 实体，这样会比较容易插入 HTML 原始码，Markdown 会把下面这段： 1Please don&#x27;t use any `&lt;blink&gt;` tags. 转为： 1&lt;p&gt;Please don&#x27;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： 1`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： 12&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片很明显地，要在纯文字应用中设计一个 「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和连结很相似的语法来标记图片，同样也允许两种样式： 行内和参考。 行内图片的语法看起来像是： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一对方括号，裡面放上图片的替代文字 接着一对普通括号，裡面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： 1![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 1[id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动连结Markdown 支援比较简短的自动连结形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成连结，连结的文字就和连结位置一样，例如： 1&lt;http://example.com/&gt; Markdown 会转为： 1&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 自动的邮件连结也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字元转成 16 进位码的 HTML 实体，这样的格式可以溷淆一些不好的信箱地址收集机器人，例如： 1&lt;address@example.com&gt; Markdown 会转成： 1234&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器裡面，这段字串会变成一个可以点击的「address@example.com」连结。 （这种作法虽然可以溷淆不少的机器人，但并无法全部挡下来，不过这样也比什么都不做好些。无论如何，公开你的信箱终究会引来广告信件的。） 跳脱字元Markdown 可以利用反斜线来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜线： 1\\*literal asterisks\\* Markdown 支援在下面这些符号前面加上反斜线来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 大括号[] 方括号() 括号# 井字号+ 加号- 减号. 英文句点! 惊叹号 补充复选框 1234MD- [x] 复选框 1- [x] 复选框 2- [ ] 复选框 3 复选框 1 复选框 2 复选框 3 html 折叠语法 标题 当前皮肤支持选项卡 默认 预设选择 tabs 没有预设值 自定义 Tab 名 + 只有 icon + icon 和 Tab 名 1234567891011121314MD&#123;% tabs test1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125;","tags":["Markdown"],"categories":["Markdown"]},{"title":"XC's Blog","path":"/about/index.html","content":"📚关于我 热爱前端、热爱IT、热爱互联网 喜欢钻研互联网，喜欢参与开源项目的讨论 最喜欢的编辑器 VS Code 💌本站镜像 PS:根据适合自己访问较快的镜像访问即可！ 主站 Vercel镜像 Netlify镜像 Cloudflare镜像 Netlify自带域 Render节点 Gitee XC-Blog状态监控 GitHub Qexo管理 🥇目标技术栈： 前端三剑客（H5&#x2F;C3&#x2F;JS） 学习ECMAScript 6-12 语法特性 (对象属性、合并对象、条件属性)… 学习ajax、json、xml 前后端交互等技术… 学习node.js、webpack、axios、jQuery… 学习主流框架(Vue、React、Angular)… 努力成为一名合格的前端工程师~💪 💘关于博客 XC’s Blog 记录生活 and 学习文章 本站使用 Hexo ➕ GitHub 搭建而成，主题使用的是一款简单的卡片式 UI 设计主题 Butterfly 欢迎各位交换友链，具体可在友联页查看 📧您可以在社交媒体上与我联系： QQ WeChat GitHub CSDN BiliBili 网易云 🏳‍🌈其他个人项目： HTML笔记 HTML笔记 综合案例 个人主页 个人收录 个人主页 HTML笔记 HTML笔记 HTML练习题 Gridea笔记"}]